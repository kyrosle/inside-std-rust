<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iterator - rust-inside-std-book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="引言.html">引言</a></li><li class="chapter-item expanded affix "><a href="01-RUST库体系概述.html">RUST库体系概述</a></li><li class="chapter-item expanded affix "><a href="02-内存.html">内存</a></li><li class="chapter-item expanded affix "><a href="03-固有函数库及基础类型.html">固有函数库及基础类型</a></li><li class="chapter-item expanded affix "><a href="04-基础Trait.html">基础Trait</a></li><li class="chapter-item expanded affix "><a href="05-Iterator.html" class="active">Iterator</a></li><li class="chapter-item expanded affix "><a href="06-基本类型续.html">基本类型续</a></li><li class="chapter-item expanded affix "><a href="07-内部可变性类型.html">内部可变性类型</a></li><li class="chapter-item expanded affix "><a href="08-智能指针类型(一).html">智能指针类型(一)</a></li><li class="chapter-item expanded affix "><a href="09-智能指针类型(二).html">智能指针类型(二)</a></li><li class="chapter-item expanded affix "><a href="10-智能指针类型(三).html">智能指针类型(三)</a></li><li class="chapter-item expanded affix "><a href="11-智能指针类型(四).html">智能指针类型(四)</a></li><li class="chapter-item expanded affix "><a href="12-std库(一)FFI及内存管理.html">std库(一)FFI及内存管理</a></li><li class="chapter-item expanded affix "><a href="13-std库(二)文件描述符及进程管理.html">std库(二)文件描述符及进程管理</a></li><li class="chapter-item expanded affix "><a href="14-std库(三)线程间锁通信.html">std库(三)线程间锁通信</a></li><li class="chapter-item expanded affix "><a href="15-std库(四)线程临界区类型.html">std库(四)线程临界区类型</a></li><li class="chapter-item expanded affix "><a href="16-std库(五)线程管理.html">std库(五)线程管理</a></li><li class="chapter-item expanded affix "><a href="17-std库(六)mpsc通信.html">std库(六)mpsc通信</a></li><li class="chapter-item expanded affix "><a href="18-std库(七)RUST的RUNTIME.html">std库(七)RUST的RUNTIME</a></li><li class="chapter-item expanded affix "><a href="19-std库(八)RUST文件系统.html">std库(八)RUST文件系统</a></li><li class="chapter-item expanded affix "><a href="20-std库(九)RUST的IO.html">std库(九)RUST的IO</a></li><li class="chapter-item expanded affix "><a href="21-RUST的异步编程.html">RUST的异步编程</a></li><li class="chapter-item expanded affix "><a href="后记.html">后记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-inside-std-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust的iterator实现代码分析"><a class="header" href="#rust的iterator实现代码分析">RUST的Iterator实现代码分析</a></h1>
<p>代码路径：<br />
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\iter*.*</p>
<p>Iterator在函数式编程中是居于最核心的地位。在函数式编程中，最关键的就是把问题的解决方式设计成能够使用Iterator方案来解决。RUST基本上可以说是原生的Iterator语言，几乎所有的核心关键复合类型都对Iterator作出实现。</p>
<h2 id="rust的iterator与其他语言iterator比较"><a class="header" href="#rust的iterator与其他语言iterator比较">RUST的Iterator与其他语言Iterator比较</a></h2>
<p>RUST定义了三种迭代器:</p>
<ol>
<li>对变量本身进行遍历的的into_iter，需要实现如下trait：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}</span></code></pre></pre>
<p>into_iter返回的迭代器迭代时，会消费变量及容器，完全迭代后容器将不再存在。</p>
<ol start="2">
<li>对变量不可变引用进行遍历的iter,类型一般实现以下方法获得此迭代器: </li>
</ol>
<p><code>pub fn iter(&amp;self) -&gt; I:Iterator</code>
这种迭代器在程序中经常使用，例如，遍历游戏玩家的列表以进行统计</p>
<ol start="3">
<li>对变量的可变引用进行遍历的iter_mut,类型一般实现以下方法获得此迭代器：</li>
</ol>
<p><code>pub fn iter_mut(&amp;self) -&gt; I:Iterator </code>
这种迭代器的一个例子是遍历游戏玩家，更新玩家在线时间。</p>
<p>其他语言一般仅实现第3种迭代器。</p>
<p>对变量本身遍历的迭代器是RUST独有的所有权和drop机制带来的一种迭代器。在适合的场景下会缩减代码量及提高效率。</p>
<p>一般的，RUST要求额外实现下面的两种机制<br />
T::iter() 等同于 &amp;T::into_iter()<br />
T::iter_mut() 等同于 &amp;mut T::into_iter()</p>
<h2 id="iterator-trait-定义"><a class="header" href="#iterator-trait-定义">Iterator Trait 定义</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    /// 每次迭代时返回的变量类型.
    type Item;
    
    //灵魂方法
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    
    //size_hint返回值是此迭代器最少产生多少个有效迭代输出，最多产生多少有有效迭代输出。
    //所以，诸如(0..10).int_iter(), 最少是10个，最多也是10个，
    //而（0..10).filter(|x| x%2 == 0), 因为编译器不会提前计算，所以符合条件的最少可能是0个，最多是10个
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (0, None)
    }

    //将Iterator中所有的成员做累积操作
    //init作为f的初始值输入，
    fn fold&lt;B, F&gt;(mut self, init: B, mut f: F) -&gt; B
    where
        Self: Sized,
        F: FnMut(B, Self::Item) -&gt; B,
    {
        let mut accum = init;
        while let Some(x) = self.next() {
            accum = f(accum, x);
        }
        accum
    }

    //其他方法
    ...
    ...
}

//在定义一个trait后，
//要考虑针对已经实现这种trait的
//类型的引用/可变引用/切片/数组
//能否用adapter的方式实现该trait
//下面是Iterator的一个例子
impl&lt;I: Iterator + ?Sized&gt; Iterator for &amp;mut I {
    type Item = I::Item;
    fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt; {
        (**self).next()
    }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (**self).size_hint()
    }
    fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), usize&gt; {
        (**self).advance_by(n)
    }
    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt; {
        (**self).nth(n)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="iterator与其他集合类型转换结构与分析"><a class="header" href="#iterator与其他集合类型转换结构与分析">Iterator与其他集合类型转换结构与分析</a></h2>
<p>RUST提供了<em>集合类型</em>与Iterator互相转换的trait：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//从Iterator创建集合
pub trait FromIterator&lt;A&gt;: Sized {
    //从Iterator中创建集合
    fn from_iter&lt;T: IntoIterator&lt;Item = A&gt;&gt;(iter: T) -&gt; Self;
}

//对实现Iterator trait的集合类型实现IntoIterator
impl&lt;I: Iterator&gt; IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    fn into_iter(self) -&gt; I {
        self
    }
}

//此trait用于从一个Iterator给集合扩充成员
pub trait Extend&lt;A&gt; {
    //将Iterator的成员增加到集合
    fn extend&lt;T: IntoIterator&lt;Item = A&gt;&gt;(&amp;mut self, iter: T);

    /// 仅增加一个成员
    fn extend_one(&amp;mut self, item: A) {
        //Option实现了Iterator
        self.extend(Some(item));
    }

    //扩充容量以备后用
    fn extend_reserve(&amp;mut self, additional: usize) {
        let _ = additional;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Iterator中的转换方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    ...
    ...

    fn collect&lt;B: FromIterator&lt;Self::Item&gt;&gt;(self) -&gt; B
    where
        Self: Sized,
    {
        FromIterator::from_iter(self)
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>以上说明，对于任意的集合类型，只要实现了FromIterator trait，即可通过collect生成。从而使得不同集合类型之间的转换变得统一，方便及松耦合。</p>
<h2 id="opsrange类型的iterator实现"><a class="header" href="#opsrange类型的iterator实现">ops::Range类型的Iterator实现</a></h2>
<p>代码路径：</p>
<p>%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\iter\range.rs</p>
<p>Range被直接实现Iterator trait，没有用其他辅助结构。
定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;A: Step&gt; Iterator for ops::Range&lt;A&gt; {
    type Item = A;
    
    fn next(&amp;mut self) -&gt; Option&lt;A&gt; {
        self.spec_next()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        if self.start &lt; self.end {
            let hint = Step::steps_between(&amp;self.start, &amp;self.end);
            (hint.unwrap_or(usize::MAX), hint)
        } else {
            (0, Some(0))
        }
    }

    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;A&gt; {
        self.spec_nth(n)
    }
    ...
    ...
    
}
<span class="boring">}</span></code></pre></pre>
<p>Range Iterator的具体实现RangeIteratorImpl trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;A: Step&gt; RangeIteratorImpl for ops::Range&lt;A&gt; {
    type Item = A;

    default fn spec_next(&amp;mut self) -&gt; Option&lt;A&gt; {
        if self.start &lt; self.end {
            //self.start.clone()是为了不转移self.start的所有权
            let n =
                Step::forward_checked(self.start.clone(), 1).expect(&quot;`Step` invariants not upheld&quot;);
            //mem::replace将self.start赋值为n，返回self.start的值，这个方式适用于任何类型，且处理了所有权问题
            //mem::replace是效率最高的代码方式
            Some(mem::replace(&amp;mut self.start, n))
        } else {
            None
        }
    }

    ...
}
<span class="boring">}</span></code></pre></pre>
<p>由上面的代码可以看出，每一次next实际都对Range本身做出了修改，这一修改是使用mem::replace实现的。要理解这是为什么。</p>
<p>只有基于实现<code>Step Trait</code>的类型的Range才支持了Iterator, 而代码关键是Step Trait的方法，
<code>Step Trait</code>的定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Step: Clone + PartialOrd + Sized {
    /// 从start 到end一共多少step
    fn steps_between(start: &amp;Self, end: &amp;Self) -&gt; Option&lt;usize&gt;;

    /// 向前count步返回值
    fn forward_checked(start: Self, count: usize) -&gt; Option&lt;Self&gt;;

    /// 向前count步 返回值，出错退出
    fn forward(start: Self, count: usize) -&gt; Self {
        Step::forward_checked(start, count).expect(&quot;overflow in `Step::forward`&quot;)
    }

    /// 向前不检查 count步
    unsafe fn forward_unchecked(start: Self, count: usize) -&gt; Self {
        Step::forward(start, count)
    }

    /// 向后count步
    fn backward_checked(start: Self, count: usize) -&gt; Option&lt;Self&gt;;

    /// 向后count步，出错退出
    fn backward(start: Self, count: usize) -&gt; Self {
        Step::backward_checked(start, count).expect(&quot;overflow in `Step::backward`&quot;)
    }
    
    /// 向后count步，出错退出
    unsafe fn backward_unchecked(start: Self, count: usize) -&gt; Self {
        Step::backward(start, count)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>照此，可以实现一个自定义类型的类型, 并支持Step Trait，如此，即可使用Range符号的Iterator。例如，一个二维的点的range,例如Range&lt;(i32, i32)&gt;的变量((0,0)..(10,10)), 三维的点的range，数列等。</p>
<p>一下是为所有整数类型实现Step的宏：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>macro_rules! step_identical_methods {
    () =&gt; {
        unsafe fn forward_unchecked(start: Self, n: usize) -&gt; Self {
            // 调用代码需要保证加法不会越界.
            unsafe { start.unchecked_add(n as Self) }
        }

        unsafe fn backward_unchecked(start: Self, n: usize) -&gt; Self {
            // 调用代码需要保证减法不会越界.
            unsafe { start.unchecked_sub(n as Self) }
        }

        fn forward(start: Self, n: usize) -&gt; Self {
            // debug 编译情况下 以下代码对溢出会panic，release以下代码会被优化掉
            if Self::forward_checked(start, n).is_none() {
                let _ = Self::MAX + 1;
            }
            // release 编译采用的加法 
            start.wrapping_add(n as Self)
        }

        fn backward(start: Self, n: usize) -&gt; Self {
            // debug编译，以下代码在debug目标对溢出会panic，release会被优化掉.
            if Self::backward_checked(start, n).is_none() {
                let _ = Self::MIN - 1;
            }
            // release编译采用的加法
            start.wrapping_sub(n as Self)
        }
    };
}

macro_rules! step_integer_impls {
    {
        //比CPU字长小的无符号整数类型及有符号整数类型
        narrower than or same width as usize:
            $( [ $u_narrower:ident $i_narrower:ident ] ),+;
        //比CPU字长大的无符号整数类型及有符号整数类型
        wider than usize:
            $( [ $u_wider:ident $i_wider:ident ] ),+;
    } =&gt; {
        $(
            //为所有比CPU字长小的无符号整数类型的Step实现
            impl Step for $u_narrower {
                //通用实现
                step_identical_methods!();

                fn steps_between(start: &amp;Self, end: &amp;Self) -&gt; Option&lt;usize&gt; {
                    if *start &lt;= *end {
                        // u_nrrower类型字长必须小于usize字长
                        Some((*end - *start) as usize)
                    } else {
                        None
                    }
                }

                fn forward_checked(start: Self, n: usize) -&gt; Option&lt;Self&gt; {
                    //将类型转换可能不成功显化，这是需要养成的RUST的特有思维
                    match Self::try_from(n) {
                        //checked_add完成溢出检查
                        Ok(n) =&gt; start.checked_add(n),
                        Err(_) =&gt; None, 
                    }
                }

                fn backward_checked(start: Self, n: usize) -&gt; Option&lt;Self&gt; {
                    match Self::try_from(n) {
                        Ok(n) =&gt; start.checked_sub(n),
                        Err(_) =&gt; None, // if n is out of range, `unsigned_start - n` is too
                    }
                }
            }
            
            //略
            ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Range实现Iterator的代码不复杂，但是从类型转换及加减法的处理上深刻的体现了RUST的安全理念。</p>
<h2 id="slice的iterator实现"><a class="header" href="#slice的iterator实现">slice的Iterator实现</a></h2>
<p>代码路径：<br />
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\slice\iter.rs</p>
<p>首先定义了适合&amp;[T]的Iter结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T: 'a&gt; {
    //当前元素的指针，与end用不同的类型表示
    ptr: NonNull&lt;T&gt;,
    //尾元素指针，用ptr == end以快速检测iterator是否为空
    end: *const T, 
    //这里PhantomData 主要用来做生命周期标识，用来做Iter结构体与切片之间的生命周期关系检测
    _marker: PhantomData&lt;&amp;'a T&gt;, 
}

pub struct IterMut&lt;'a, T: 'a&gt; {
    ptr: NonNull&lt;T&gt;,
    end: *mut T, 
    _marker: PhantomData&lt;&amp;'a mut T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这里，一个疑惑就是为什么不用下标及切片长度来作为Iter结构。这是因为可变的Iterator实现无法支持。
例如，给出如下结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IterMut &lt;'a, T:'a&gt; {
    current: usize,
    len: usize,
    slice: 'a mut &amp;[T]
}
<span class="boring">}</span></code></pre></pre>
<p>显然，当IterMut结构是可变借用时，无法再返回一个内部成员的借用用作迭代器的迭代返回值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; IterMut&lt;'a, T&gt; {
    pub(super) fn new(slice: &amp;'a mut [T]) -&gt; Self {
        let ptr = slice.as_mut_ptr();
        unsafe {
            assume(!ptr.is_null());

            let end = if mem::size_of::&lt;T&gt;() == 0 {
                (ptr as *mut u8).wrapping_add(slice.len()) as *mut T
            } else {
                ptr.add(slice.len())
            };

            Self { ptr: NonNull::new_unchecked(ptr), end, _marker: PhantomData }
        }
    }
    
    ...
    ...
}
//用宏来实现切片的Iterator trait
iterator! {struct IterMut -&gt; *mut T, &amp;'a mut T, mut, {mut}, {}}

//上面的宏定义
macro_rules! iterator {
    (
        struct $name:ident -&gt; $ptr:ty,
        $elem:ty,
        $raw_mut:tt,
        {$( $mut_:tt )?},
        {$($extra:tt)*}
    ) =&gt; {
        // 正向next函数辅助宏，实际的逻辑见post_inc_start函数
        macro_rules! next_unchecked {
            ($self: ident) =&gt; {&amp; $( $mut_ )? *$self.post_inc_start(1)}
        }

        // 反向的next函数
        macro_rules! next_back_unchecked {
            ($self: ident) =&gt; {&amp; $( $mut_ )? *$self.pre_dec_end(1)}
        }

        // 0长度元素next的移动
        macro_rules! zst_shrink {
            ($self: ident, $n: ident) =&gt; {
                //0元素数组因为不能移动指针，所以移动尾指针
                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;
            }
        }
        
        //具体的方法实现 
        // $name 即 IterMut
        impl&lt;'a, T&gt; $name&lt;'a, T&gt; {
            // 从Iterator获得切片.
            fn make_slice(&amp;self) -&gt; &amp;'a [T] {
                // Iter::ptr::as_ptr，由内存首地址和切片长度创建切片指针，然后转换为引用
                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }
            }

            //实质的next
            unsafe fn post_inc_start(&amp;mut self, offset: isize) -&gt; * $raw_mut T {
                if mem::size_of::&lt;T&gt;() == 0 {
                    //0字节元素偏移实现，调整end的值，ptr不变
                    zst_shrink!(self, offset);
                    self.ptr.as_ptr()
                } else {
                    //非0字节元素，返回首地址，然后后移正确的字节
                    let old = self.ptr.as_ptr();
                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().offset(offset)) };
                    old
                }
            }

            // 从尾部做Iterator的实际实现函数
            unsafe fn pre_dec_end(&amp;mut self, offset: isize) -&gt; * $raw_mut T {
                if mem::size_of::&lt;T&gt;() == 0 {
                    //对于0字节元素，从头部及从尾部逻辑相同
                    zst_shrink!(self, offset);
                    self.ptr.as_ptr()
                } else {
                    //尾部的end即偏移后的位置。
                    self.end = unsafe { self.end.offset(-offset) };
                    self.end
                }
            }
        }

        //Iterator的实现, 即
        //impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt;
        impl&lt;'a, T&gt; Iterator for $name&lt;'a, T&gt; {
            // $elem即&amp;'a T
            type Item = $elem;

            fn next(&amp;mut self) -&gt; Option&lt;$elem&gt; {
                unsafe {
                    //安全性确认
                    assume(!self.ptr.as_ptr().is_null());
                    if mem::size_of::&lt;T&gt;() != 0 {
                        assume(!self.end.is_null());
                    }
                    if is_empty!(self) {
                        //Iter为空的话，返回None
                        None
                    } else {
                        //实际调用post_inc_start(1)
                        Some(next_unchecked!(self))
                    }
                }
            }

            fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
                //用len!宏计算Iter的长度
                let exact = len!(self);
                (exact, Some(exact))
            }

            fn count(self) -&gt; usize {
                len!(self)
            }

            fn nth(&amp;mut self, n: usize) -&gt; Option&lt;$elem&gt; {
                //如果n大于Iter的长度，清空
                if n &gt;= len!(self) {
                    if mem::size_of::&lt;T&gt;() == 0 {
                        self.end = self.ptr.as_ptr();
                    } else {
                        unsafe {
                            self.ptr = NonNull::new_unchecked(self.end as *mut T);
                        }
                    }
                    return None;
                }
                // 否则，失效前n-1个元素，然后做next
                unsafe {
                    self.post_inc_start(n as isize);
                    Some(next_unchecked!(self))
                }
            }

            fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), usize&gt; {
                //取长度与n中的小值
                let advance = cmp::min(len!(self), n);

                //失效advance-1个值
                unsafe { self.post_inc_start(advance as isize) };
                //返回
                if advance == n { Ok(()) } else { Err(advance) }
            }

            //从尾部Iterator
            fn last(mut self) -&gt; Option&lt;$elem&gt; {
                //实质调用post_dec_end(1)
                self.next_back()
            }

            //其他，略
            ...
            ...
            
        }
    }
}

//判断Iterator是否为空的宏
macro_rules! is_empty {
    // 可以满足0字节元素的切片及非0字节元素的切片
    ($self: ident) =&gt; {
        //Iter::ptr == Iter::end
        $self.ptr.as_ptr() as *const T == $self.end
    };
}

//取Iterator长度的宏
macro_rules! len {
    ($self: ident) =&gt; {{
        let start = $self.ptr;
        let size = size_from_ptr(start.as_ptr());
        //判断元素是否为0字节
        if size == 0 {
            // 用end减start得到0字节元素的切片长度
            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)
        } else {
            //非0字节，用内存字节数除以单元素长度
            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };
            unsafe { exact_div(diff, size) }
        }
    }};
}


<span class="boring">}</span></code></pre></pre>
<p>对于切片，RUST的所有权，借用等规定导致其迭代器实际上是一个非常好的编码训练工具，代码粗略看一遍后值得自己将其实现一遍，可以有效提高对RUST的认识和编码水平。</p>
<h2 id="字符串iterator代码分析"><a class="header" href="#字符串iterator代码分析"><a id="str_iter">字符串Iterator代码分析</a></a></h2>
<p>字符串&amp;str本质上是一个[u8]类型，并在此类型的基础上实现了对utf-8的处理。
因此，对字符串的Iterator的设计自然想到用适配器的模式来重用[u8]切片类型的Iterator的基础设施。</p>
<p>题外话，&amp;str.len()返回字符串切片字节占用数，&amp;str.chars().count()返回字符数目。
字符串切片获取Iterator有如下3个函数
&amp;str::chars() 获得以UTF-8编码的字符串的Iterator
&amp;str::bytes() 获得一个[u8]的Iterator
&amp;str::char_indices() 获得一个元组，第一个成员是字符字节数组的序号，第二个成员是字符本身
bytes()主要用于提高在程序员确定采用ASCII字符串下的运行效率。
我们以&amp;str::chars()的Iterator来看一下具体的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Chars&lt;'a&gt; {
    //利用slice通用的iter做实例化,实际是一个adapter设计模式
    pub(super) iter: slice::Iter&lt;'a, u8&gt;,
}

pub fn chars(&amp;self) -&gt; Chars&lt;'_&gt; {
    //self.as_bytes()获得一个&amp;[u8]
    Chars { iter: self.as_bytes().iter() }
}
impl&lt;'a&gt; Iterator for Chars&lt;'a&gt; {
    type Item = char;

    fn next(&amp;mut self) -&gt; Option&lt;char&gt; {
        //next_code_point见后面代码分析
        next_code_point(&amp;mut self.iter).map(|ch| {
            unsafe { char::from_u32_unchecked(ch) }
        })
    }

    fn count(self) -&gt; usize {
        // 利用切片iterator的filter来实现
        self.iter.filter(|&amp;&amp;byte| !utf8_is_cont_byte(byte)).count()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let len = self.iter.len();
        //最少按四个字节一个字符，最多按一个字节一个字符
        ((len + 3) / 4, Some(len))
    }

    fn last(mut self) -&gt; Option&lt;char&gt; {
        self.next_back()
    }

}

pub fn next_code_point&lt;'a, I: Iterator&lt;Item = &amp;'a u8&gt;&gt;(bytes: &amp;mut I) -&gt; Option&lt;u32&gt; {
    // iterator.next 
    let x = *bytes.next()?;
    if x &lt; 128 {
        //ascii字符
        return Some(x as u32);
    }

    //因为是字符串，此时第二个字节一定会有
    let init = utf8_first_byte(x, 2); 
    //获取下一个字节，一定存在   
    let y = unwrap_or_0(bytes.next());
    let mut ch = utf8_acc_cont_byte(init, y);
    if x &gt;= 0xE0 {
        // 三个字节的UTF-8
        let z = unwrap_or_0(bytes.next());
        let y_z = utf8_acc_cont_byte((y &amp; CONT_MASK) as u32, z);
        ch = init &lt;&lt; 12 | y_z;
        if x &gt;= 0xF0 {
            //四个字节的UTF-8
            let w = unwrap_or_0(bytes.next());
            ch = (init &amp; 7) &lt;&lt; 18 | utf8_acc_cont_byte(y_z, w);
        }
    }

    Some(ch)
}
<span class="boring">}</span></code></pre></pre>
<p>&amp;str的Iterator实现是一个说明Iterator设计模式优越性的经典实例。如果直接使用循环，则&amp;str与&amp;[T]必然会有很多的重复代码，使用Iterator模式后，重复代码被抽象到了Iterator模块中。&amp;str复用了&amp;[T]的iter。</p>
<h2 id="array-的iterator实现"><a class="header" href="#array-的iterator实现">array 的Iterator实现</a></h2>
<h3 id="unsize-trait"><a class="header" href="#unsize-trait">Unsize Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Unsize&lt;T: ?Sized&gt; {
    // Empty.
}
<span class="boring">}</span></code></pre></pre>
<p>实现了Unsize Trait，可以把一个固定内存大小的变量强制转换为相关的可变大小类型， 如[T;N]实现了Unsize&lt;[T]&gt;, 因此[T;N]可以转换为[T]，一般是指针转换。</p>
<h3 id="iter所用的结构"><a class="header" href="#iter所用的结构">Iter所用的结构</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T, const N: usize&gt; {
    /// data是迭代中的数组.
    /// 这个数组中，只有data[alive]是有效的，访问其他的部分，即data[..alive.start] 及data[end..]会发生UB
    /// [MaybeUninit&lt;T&gt;;N]的用法需要体会，
    data: [MaybeUninit&lt;T&gt;; N],

    /// 表明数组中有效的成员的下标范围.
    /// 必须满足:
    /// - `alive.start &lt;= alive.end`
    /// - `alive.end &lt;= N`
    alive: Range&lt;usize&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>上面这个结构是因为需要对array内成员做消费设计的。因为数组成员不支持所有权转移，所以采用了这种设计方式。数组的Iterator实现是理解所有权的一个极佳例子。</p>
<h3 id="into_iter实现"><a class="header" href="#into_iter实现">into_iter实现</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; IntoIter&lt;T, N&gt; {
    pub fn new(array: [T; N]) -&gt; Self {
        // 
        // 因为RUST特性目前还不支持数组的transmute，所以用了内存跨类型的transmute_copy，此函数将从栈中申请一块内存。
        // 拷贝完毕后，原数组的所有权已经转移到data，data内数据事实上已经初始化，但仍然还是MaybeUninit&lt;T&gt;的类型。此时，需要对原数组调用mem::forget反应所有权已经失去。
        // mem::forget不会导致内存泄漏。
        unsafe {
            let iter = Self { data: mem::transmute_copy(&amp;array), alive: 0..N };
            mem::forget(array);
            iter
        }
    }

    pub fn as_slice(&amp;self) -&gt; &amp;[T] {
        // 仅针对有效的部分返回切片引用。已经消费的不返回。
        unsafe {
            //此处调用SliceIndex::&lt;Range&gt;::get_unchecked
            //slice是&amp;[MaybeUninit&lt;T&gt;]类型
            let slice = self.data.get_unchecked(self.alive.clone());
            MaybeUninit::slice_assume_init_ref(slice)
        }
    }

    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe {
            //此处调用SliceIndex::&lt;Range&gt;::get_unchecked_mut
            //slice 是 &amp; mut [MaybeUninit&lt;T&gt;]类型
            let slice = self.data.get_unchecked_mut(self.alive.clone());
            MaybeUninit::slice_assume_init_mut(slice)
        }
    }
}

impl&lt;T, const N: usize&gt; Iterator for IntoIter&lt;T, N&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // 下面使用Range的Iterator特性实现next. alive的start会变化，从而导致start之前的数组元素无法再被访问。因为已经被消费掉。
        // Option::map完成下标值传递。
        self.alive.next().map(|idx| {
            // SliceIndex::&lt;usize&gt;::get_unchecked, MaybeUninit::&lt;T&gt;::assume_init_read()
            // 前面有过说明，assume_init_read()从堆栈中申请了T大小的内存，然后进行内存拷贝，然后返回变量
            // 此时array元素的所有权转移到返回值。
            unsafe { self.data.get_unchecked(idx).assume_init_read() }
        })
    }
    ...
    ...
}

impl&lt;T, const N: usize&gt; Drop for IntoIter&lt;T, N&gt; {
    // 这里没有被消费掉的成员必须显示释放掉。
    fn drop(&amp;mut self) {
        // as_mut_slice()获得所有具有所有权的元素，这些元素需要调用drop来释放。这里，data变量中的元素始终封装在MaybeUninit&lt;T&gt;中
        unsafe { ptr::drop_in_place(self.as_mut_slice()) }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>数组的Iterator最关键的点就是如何将数组成员的所有权取出，这是RUST语法带来的额外的麻烦和复杂性。最终的解决办法显示了RUST编码的所有权转移的一些通用的底层技巧。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; IntoIterator for [T; N] {
    type Item = T;
    type IntoIter = IntoIter&lt;T, N&gt;;

    /// 创建消费型的iterator, 如果T不实现`Copy`, 则调用此函数后，数组不可再被访问。
    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter::new(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上创建消费数组成员的Iterator。</p>
<h3 id="iter-iter_mut实现"><a class="header" href="#iter-iter_mut实现">iter(), iter_mut()实现</a></h3>
<p>下面的数组成员引用的Iterator实质上是将数组强制转换为切片类型，应用切片类型的迭代器。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T, const N: usize&gt; IntoIterator for &amp;'a [T; N] {
    type Item = &amp;'a T;
    type IntoIter = Iter&lt;'a, T&gt;;
    
    fn into_iter(self) -&gt; Iter&lt;'a, T&gt; {
        //点号导致self强制转换成[T], 然后调用切片类型的iter
        self.iter()
    }
}

impl&lt;'a, T, const N: usize&gt; IntoIterator for &amp;'a mut [T; N] {
    type Item = &amp;'a mut T;
    type IntoIter = IterMut&lt;'a, T&gt;;
    
    
    fn into_iter(self) -&gt; IterMut&lt;'a, T&gt; {
        //self被强制转换为切片类型
        self.iter_mut()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="iterator的适配器代码分析"><a class="header" href="#iterator的适配器代码分析">Iterator的适配器代码分析</a></h2>
<h3 id="map-适配器代码分析"><a class="header" href="#map-适配器代码分析">Map 适配器代码分析</a></h3>
<p>Map相关代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait Iterator {
    //其他内容
    ...
    ...

    //创建map Iterator
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
    where
        Self: Sized,
        F: FnMut(Self::Item) -&gt; B,
    {
        Map::new(self, f)
    }
    ...
}

//此结构是一个adapter的结构
pub struct Map&lt;I, F&gt; {
    // Map的底层Iterator
    pub(crate) iter: I,
    // Map操作闭包函数
    f: F,
}

impl&lt;I, F&gt; Map&lt;I, F&gt; {
    //由Iterator::map 函数和这个函数可以理解Iterator的lazy特性，
    //Iterator的创建实际上仅仅建立了数据结构，直到next才有操作。
    pub(in crate::iter) fn new(iter: I, f: F) -&gt; Map&lt;I, F&gt; {
        Map { iter, f }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Map适配器结构相当直接而简单。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//针对Map实现Iterator
impl&lt;B, I: Iterator, F&gt; Iterator for Map&lt;I, F&gt;
where
    F: FnMut(I::Item) -&gt; B,
{
    type Item = B;

    fn next(&amp;mut self) -&gt; Option&lt;B&gt; {
        //利用底层Iterator的next，Option::map实现next
        self.iter.next().map(&amp;mut self.f)
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.iter.size_hint()
    }

    //其他函数，其实现技巧与next类似
    ...
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="chain-适配器代码分析"><a class="header" href="#chain-适配器代码分析">Chain 适配器代码分析</a></h3>
<p>相关代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    ...
    ...
    //创建Chain Iterator
    fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, U::IntoIter&gt;
    where
        Self: Sized,
        U: IntoIterator&lt;Item = Self::Item&gt;,
    {
        Chain::new(self, other.into_iter())
    }
    ...
    ...
}


pub struct Chain&lt;A, B&gt; {
    //迭代器A
    a: Option&lt;A&gt;,
    //迭代器B
    b: Option&lt;B&gt;,
}
impl&lt;A, B&gt; Chain&lt;A, B&gt; {
    pub(in super::super) fn new(a: A, b: B) -&gt; Chain&lt;A, B&gt; {
        Chain { a: Some(a), b: Some(b) }
    }
}

macro_rules! fuse {
    ($self:ident . $iter:ident . $($call:tt)+) =&gt; {
        //$iter可能已经被置为None
        match $self.$iter {
            //若$iter不为None,则调用iter的系列函数
            Some(ref mut iter) =&gt; match iter.$($call)+ {
                //函数返回None
                None =&gt; {
                    //设置$iter为None,并返回None
                    $self.$iter = None;
                    None
                }
                //其他返回函数返回值
                item =&gt; item,
            },
            //a为None时返回None
            None =&gt; None,
        }
    };
}

//与fuse类似，略
macro_rules! maybe {
    ($self:ident . $iter:ident . $($call:tt)+) =&gt; {
        match $self.$iter {
            Some(ref mut iter) =&gt; iter.$($call)+,
            None =&gt; None,
        }
    };
}

impl&lt;A, B&gt; Iterator for Chain&lt;A, B&gt;
where
    A: Iterator,
    B: Iterator&lt;Item = A::Item&gt;,
{
    type Item = A::Item;

    fn next(&amp;mut self) -&gt; Option&lt;A::Item&gt; {
        //先执行self.a.next
        match fuse!(self.a.next()) {
            //若self.a.next返回None，则执行self.b.next
            None =&gt; maybe!(self.b.next()),
            //不为None，返回a的返回值
            item =&gt; item,
        }
    }
    ...
    ...
}

<span class="boring">}</span></code></pre></pre>
<h3 id="其他"><a class="header" href="#其他">其他</a></h3>
<p>Iterator的adapter还有很多，如StepBy, Filter, Zip, Intersperse等等。具体请参考标准库手册。基本上所有的adapter都是遵循Adapter的设计模式来实现的。且每一个适配器的结构及代码逻辑都是比较简单且易理解的。</p>
<h3 id="小结"><a class="header" href="#小结">小结</a></h3>
<p>RUST的Iterater的adapter是突出的体现RUST的语法优越性的特性，借助Trait和强大的泛型机制，与c/c++/java相比较，RUST以很少的代码在标准库就实现了最丰富的adapter。而其他语言标准库往往不存在这些适配器，需要其他库来实现。
Iterator的adapter实现了强大的基于Iterator的函数式编程基础设施。函数式编程的基础框架之一便是基于Iterator和闭包实现丰富的adapter。这也凸显了RUST在语言级别对函数式编程的良好支持。</p>
<h2 id="option的iterator实现代码分析"><a class="header" href="#option的iterator实现代码分析">Option的Iterator实现代码分析</a></h2>
<p>Option实现Iterator是比较令人疑惑的，毕竟用Iterator肯定代码更多，逻辑也复杂。主要目的应该是为了重用Iterator构建的各种adapter，及为了函数式编程的需要。仅分析IntoIterator Trait所涉及的结构及方法
相关类型结构定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//into_iter的结构
pub struct IntoIter&lt;A&gt; {
    //实际的Iterator实现结构
    inner: Item&lt;A&gt;,
}

//Item同时满足into_iter(), iter(), iter_mut()
//标准库编码者的设计方式，当然也可以用其他设计
struct Item&lt;A&gt; {
    opt: Option&lt;A&gt;,
}

impl&lt;T&gt; IntoIterator for Option&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;

    //创建Iterator的实现结构体，self所有权传入结构体
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter { inner: Item { opt: self } }
    }
}

//具体实现者
impl&lt;A&gt; Iterator for Item&lt;A&gt; {
    type Item = A;

    fn next(&amp;mut self) -&gt; Option&lt;A&gt; {
        //所有权传出，并用None替换原变量的值
        self.opt.take()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        match self.opt {
            Some(_) =&gt; (1, Some(1)),
            None =&gt; (0, Some(0)),
        }
    }
}

//消费变量的Iterator实现
impl&lt;A&gt; Iterator for IntoIter&lt;A&gt; {
    type Item = A;

    fn next(&amp;mut self) -&gt; Option&lt;A&gt; {
        self.inner.next()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.inner.size_hint()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Result&lt;T,E&gt;的 Iterator与Option<T>的Iterator非常相似，略</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="04-基础Trait.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="06-基本类型续.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="04-基础Trait.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="06-基本类型续.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
