<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基本类型续 - rust-inside-std-book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="引言.html">引言</a></li><li class="chapter-item expanded affix "><a href="01-RUST库体系概述.html">RUST库体系概述</a></li><li class="chapter-item expanded affix "><a href="02-内存.html">内存</a></li><li class="chapter-item expanded affix "><a href="03-固有函数库及基础类型.html">固有函数库及基础类型</a></li><li class="chapter-item expanded affix "><a href="04-基础Trait.html">基础Trait</a></li><li class="chapter-item expanded affix "><a href="05-Iterator.html">Iterator</a></li><li class="chapter-item expanded affix "><a href="06-基本类型续.html" class="active">基本类型续</a></li><li class="chapter-item expanded affix "><a href="07-内部可变性类型.html">内部可变性类型</a></li><li class="chapter-item expanded affix "><a href="08-智能指针类型(一).html">智能指针类型(一)</a></li><li class="chapter-item expanded affix "><a href="09-智能指针类型(二).html">智能指针类型(二)</a></li><li class="chapter-item expanded affix "><a href="10-智能指针类型(三).html">智能指针类型(三)</a></li><li class="chapter-item expanded affix "><a href="11-智能指针类型(四).html">智能指针类型(四)</a></li><li class="chapter-item expanded affix "><a href="12-std库(一)FFI及内存管理.html">std库(一)FFI及内存管理</a></li><li class="chapter-item expanded affix "><a href="13-std库(二)文件描述符及进程管理.html">std库(二)文件描述符及进程管理</a></li><li class="chapter-item expanded affix "><a href="14-std库(三)线程间锁通信.html">std库(三)线程间锁通信</a></li><li class="chapter-item expanded affix "><a href="15-std库(四)线程临界区类型.html">std库(四)线程临界区类型</a></li><li class="chapter-item expanded affix "><a href="16-std库(五)线程管理.html">std库(五)线程管理</a></li><li class="chapter-item expanded affix "><a href="17-std库(六)mpsc通信.html">std库(六)mpsc通信</a></li><li class="chapter-item expanded affix "><a href="18-std库(七)RUST的RUNTIME.html">std库(七)RUST的RUNTIME</a></li><li class="chapter-item expanded affix "><a href="19-std库(八)RUST文件系统.html">std库(八)RUST文件系统</a></li><li class="chapter-item expanded affix "><a href="20-std库(九)RUST的IO.html">std库(九)RUST的IO</a></li><li class="chapter-item expanded affix "><a href="21-RUST的异步编程.html">RUST的异步编程</a></li><li class="chapter-item expanded affix "><a href="后记.html">后记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-inside-std-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust基本类型代码分析二"><a class="header" href="#rust基本类型代码分析二">RUST基本类型代码分析(二)</a></h1>
<h2 id="整形类型标准库代码分析"><a class="header" href="#整形类型标准库代码分析">整形类型标准库代码分析</a></h2>
<h3 id="nonzero数据类型"><a class="header" href="#nonzero数据类型">NonZero数据类型</a></h3>
<p><code>NonZeroU8, NonZeroU16，NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize</code>
<code>NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize</code>
以上为NonZero的类型，内存结构与相应的整形数据完全相同，可以转换。上文提过，当需要0表示特殊含义时，使用NonZero类型以保证代码安全。
重要函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//利用宏简化定义代码
macro_rules! nonzero_integers {
    ( $($Ty: ident($Int: ty); )+ ) =&gt; {
        $(
            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
            #[repr(transparent)]
            pub struct $Ty($Int);

            impl $Ty {
                pub const unsafe fn new_unchecked(n: $Int) -&gt; Self {
                    unsafe { Self(n) }
                }

                pub const fn new(n: $Int) -&gt; Option&lt;Self&gt; {
                    if n != 0 {
                        Some(unsafe { Self(n) })
                    } else {
                        None
                    }
                }

                pub const fn get(self) -&gt; $Int {
                    self.0
                }

            }
            
            //const 方式实现trait 
            impl const From&lt;$Ty&gt; for $Int {
                fn from(nonzero: $Ty) -&gt; Self {
                    nonzero.0
                }
            }
            //本类型和本类型&quot;|&quot;运算符重载
            impl const BitOr for $Ty {
                type Output = Self;
                fn bitor(self, rhs: Self) -&gt; Self::Output {
                    unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                }
            }
            //本类型与基础类型的&quot;|&quot;运算符重载
            impl const BitOr&lt;$Int&gt; for $Ty {
                type Output = Self;
                fn bitor(self, rhs: $Int) -&gt; Self::Output {
                    unsafe { $Ty::new_unchecked(self.get() | rhs) }
                }
            }
            //基础类型与本类型的&quot;|&quot;运算符重载
            impl const BitOr&lt;$Ty&gt; for $Int {
                type Output = $Ty;
                fn bitor(self, rhs: $Ty) -&gt; Self::Output {
                    unsafe { $Ty::new_unchecked(self | rhs.get()) }
                }
            }
            //&quot;|=&quot;运算符重载
            impl const BitOrAssign for $Ty {
                fn bitor_assign(&amp;mut self, rhs: Self) {
                    *self = *self | rhs;
                }
            }

            impl const BitOrAssign&lt;$Int&gt; for $Ty {
                fn bitor_assign(&amp;mut self, rhs: $Int) {
                    *self = *self | rhs;
                }
            }

            //其他运算符的重载,略
            ...
            ...
        )+
    }
}

nonzero_integers! {
    NonZeroU8(u8);
    NonZeroU16(u16);
    NonZeroU32(u32);
    NonZeroU64(u64);
    NonZeroU128(u128);
    NonZeroUsize(usize);
    NonZeroI8(i8);
    NonZeroI16(i16);
    NonZeroI32(i32);
    NonZeroI64(i64);
    NonZeroI128(i128);
    NonZeroIsize(isize);
}
<span class="boring">}</span></code></pre></pre>
<p>NonZero 类型典型的体现了RUST程序设计的安全原则，所有的异常应该用类型系统表示出来，以强制获得处理。不要用临时性的措施。这样可以最大限度的避免bug的产生。</p>
<h3 id="整形数据ops数学运算符位运算符重载实现代码分析"><a class="header" href="#整形数据ops数学运算符位运算符重载实现代码分析">整形数据ops数学运算符，位运算符重载实现代码分析</a></h3>
<p>以Add为例说明：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Add&lt;Rhs = Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

//利用宏简化操作
macro_rules! add_impl {
    ($($t:ty)*) =&gt; ($(
        impl const Add for $t {
            type Output = $t;
            //&quot;+&quot;号编译器默认实现是uncheckd_add
            //这里使用self，是一个消费操作。
            fn add(self, other: $t) -&gt; $t { self + other }
        }

        forward_ref_binop! { impl const Add, add for $t, $t }
    )*)
}

//利用宏实现所有整形和浮点型运算符的重载
add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
<span class="boring">}</span></code></pre></pre>
<p>其他数学运算符及位运算符与此接近，因为代码逻辑简单，请参考标准库手册，略</p>
<h2 id="bool类型方法代码分析"><a class="header" href="#bool类型方法代码分析">bool类型方法代码分析</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn then_some&lt;T&gt;(self, t: T) -&gt; Option&lt;T&gt;
    where
        //~const Destruct，没有找到确切的资料，
        //应该是如果T实现Drop，则必须是 impl const Drop
        //此处~const使得const在需要的时候非const化 
        T: ~const Destruct,
    {
        if self { Some(t) } else { None }
    }
    pub const fn then&lt;T, F&gt;(self, f: F) -&gt; Option&lt;T&gt;
    where
        F: ~const FnOnce() -&gt; T,
        F: ~const Destruct,
    {
        if self { Some(f()) } else { None }
    }
<span class="boring">}</span></code></pre></pre>
<p>利用Option对Try trait的支持，以上函数可以规避代码中的if..else.., 从而支持函数链式调用。</p>
<h2 id="rust字符char类型标准库代码分析"><a class="header" href="#rust字符char类型标准库代码分析">RUST字符(char)类型标准库代码分析</a></h2>
<p>RUST的字符标准库主要是编程中常用到的字符相关操作,本节摘录一些显示RUST编码特点的内容。</p>
<p>由字符串转换为字符类型：<br />
见如下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromStr for char {
    type Err = ParseCharError;
    
    //因为字符串用utf-8编码，而char是4字节变量，所以从字符串获取字符类型
    //不是简单的字符数组取值的关系，
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        //s.chars()请参考前文
        let mut chars = s.chars();
        //下面对字符串做判断，字符串中应该只有一个字符存在，否则为错误
        //具体完成utf-8的字符到char的转换在chars.next()中完成, 请参考前文
        match (chars.next(), chars.next()) {
            //无法得到字符
            (None, _) =&gt; Err(ParseCharError { kind: CharErrorKind::EmptyString }),
            //存在一个字符
            (Some(c), None) =&gt; Ok(c),
            //其他情况
            _ =&gt; Err(ParseCharError { kind: CharErrorKind::TooManyChars }),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>str::chars()函数请见前文<a href="#str_iter">字符串Iterator代码分析</a><br />
u32转换为char,代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TryFrom&lt;u32&gt; for char {
    type Error = CharTryFromError;

    fn try_from(i: u32) -&gt; Result&lt;Self, Self::Error&gt; {
        if (i &gt; MAX as u32) || (i &gt;= 0xD800 &amp;&amp; i &lt;= 0xDFFF) {
            Err(CharTryFromError(()))
        } else {
            // RUST不支持as从u32转换到char，这里只能用tranmute暴力转换
            Ok(unsafe { transmute(i) })
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>从任一进制的数值转换为char,代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn from_digit(num: u32, radix: u32) -&gt; Option&lt;char&gt; {
    //不支持大于36进制的数，因为无法用英文字母表示了
    if radix &gt; 36 {
        panic!(&quot;from_digit: radix is too high (maximum 36)&quot;);
    }
    if num &lt; radix {
        //转换为u8，后面可以与Byte类型做加法, b'0'是Byte类型的字面量
        let num = num as u8;
        if num &lt; 10 { Some((b'0' + num) as char) } else { Some((b'a' + num - 10) as char) }
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>将字符转换为某一进制的数值,以下例子充分的说明了RUST的安全性，相对于只有一种加法的C，RUST显著的降低了程序Bug出现的可能性</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn to_digit(self, radix: u32) -&gt; Option&lt;u32&gt; {
        assert!(radix &lt;= 36, &quot;to_digit: radix is too high (maximum 36)&quot;);
        // 利用wrapping_sub同时处理大于及小于'0'的字符，并且规避溢出
        let mut digit = (self as u32).wrapping_sub('0' as u32);
        if radix &gt; 10 {
            if digit &lt; 10 {
                return Some(digit);
            }
            // 用saturating_add保证digit不会折返
            digit = (self as u32 | 0b10_0000).wrapping_sub('a' as u32).saturating_add(10);
        }
        //利用bool类型的方法简化了编程
        (digit &lt; radix).then_some(digit)
    }
<span class="boring">}</span></code></pre></pre>
<p>将字符转换为&quot;\u{xxxx}&quot;的形式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//escape_unicode充分的展示了函数式编程的设计思想
//即以迭代器为中心来设计问题解决方案，
//对于任何一个问题，首先就看是否能设计一个实现Iterator Trait的结构来解决问题
pub fn escape_unicode(self) -&gt; EscapeUnicode {
   let c = self as u32;

    // c|1避免有32个0出现
    let msb = 31 - (c | 1).leading_zeros();

    // 计算有多少个字符
    let ms_hex_digit = msb / 4;
    //生成结构，以便用Iterator解决问题
    EscapeUnicode {
        c: self,
        state: EscapeUnicodeState::Backslash,
        hex_digit_idx: ms_hex_digit as usize,
    }
}

pub struct EscapeUnicode {
    c: char,
    state: EscapeUnicodeState,

    // 当前还有多少个字符没有转换 
    hex_digit_idx: usize,
}

// 显示转换的当前状态 
#[derive(Clone, Debug)]
enum EscapeUnicodeState {
    //转换完成
    Done,
    //下一步应输出右括号
    RightBrace,
    //下一步应输出字母
    Value,
    //下一步应输出左括号
    LeftBrace,
    //输出Type的字符
    Type,
    //输出斜杠，第一个状态
    Backslash,
}

impl Iterator for EscapeUnicode {
    type Item = char;

    fn next(&amp;mut self) -&gt; Option&lt;char&gt; {
        match self.state {
            EscapeUnicodeState::Backslash =&gt; {
                self.state = EscapeUnicodeState::Type;
                Some('\\')
            }
            EscapeUnicodeState::Type =&gt; {
                self.state = EscapeUnicodeState::LeftBrace;
                Some('u')
            }
            EscapeUnicodeState::LeftBrace =&gt; {
                self.state = EscapeUnicodeState::Value;
                Some('{')
            }
            EscapeUnicodeState::Value =&gt; {
                let hex_digit = ((self.c as u32) &gt;&gt; (self.hex_digit_idx * 4)) &amp; 0xf;
                let c = from_digit(hex_digit, 16).unwrap();
                if self.hex_digit_idx == 0 {
                    self.state = EscapeUnicodeState::RightBrace;
                } else {
                    self.hex_digit_idx -= 1;
                }
                Some(c)
            }
            EscapeUnicodeState::RightBrace =&gt; {
                self.state = EscapeUnicodeState::Done;
                Some('}')
            }
            EscapeUnicodeState::Done =&gt; None,
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let n = self.len();
        (n, Some(n))
    }

    fn count(self) -&gt; usize {
        self.len()
    }

    fn last(self) -&gt; Option&lt;char&gt; {
        match self.state {
            EscapeUnicodeState::Done =&gt; None,

            EscapeUnicodeState::RightBrace
            | EscapeUnicodeState::Value
            | EscapeUnicodeState::LeftBrace
            | EscapeUnicodeState::Type
            | EscapeUnicodeState::Backslash =&gt; Some('}'),
        }
    }
}

impl fmt::Display for EscapeUnicode {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        //利用Iterator输出转换字符串 
        for c in self.clone() {
            f.write_char(c)?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>EscapeUnicode 实现了Display Trait。可以调用to_string来输出字符串
RUST的字符模块的其他转换函数与EscapeUnicode采用了类似的设计，下面列出这些转换函数，但代码分析省略
<code>pub fn escape_debug(self) -&gt; EscapeDebug</code> char的Debug转换输出
<code>pub fn to_lowercase(self) -&gt; ToLowercase</code> char转换为小写
<code>pub fn to_uppercase(self) -&gt; ToUppercase</code> char转换为大写</p>
<p>编码为UTF-8的字符串</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //dst应该保证有足够的空间放置utf-8字符串，&amp;mut str的地址就是dst
    pub fn encode_utf8(self, dst: &amp;mut [u8]) -&gt; &amp;mut str {
        unsafe { from_utf8_unchecked_mut(encode_utf8_raw(self as u32, dst)) }
    }

    pub unsafe fn from_utf8_unchecked_mut(v: &amp;mut [u8]) -&gt; &amp;mut str {
        //调用者保证v能被安全的转换
        unsafe { &amp;mut *(v as *mut [u8] as *mut str) 
    }

    pub fn encode_utf8_raw(code: u32, dst: &amp;mut [u8]) -&gt; &amp;mut [u8] {
        let len = len_utf8(code);
        match (len, &amp;mut dst[..]) {
            //rust语法的强大展现，逻辑很简单，分析略
            (1, [a, ..]) =&gt; {
                *a = code as u8;
            }
            (2, [a, b, ..]) =&gt; {
                *a = (code &gt;&gt; 6 &amp; 0x1F) as u8 | TAG_TWO_B;
                *b = (code &amp; 0x3F) as u8 | TAG_CONT;
            }
            (3, [a, b, c, ..]) =&gt; {
                *a = (code &gt;&gt; 12 &amp; 0x0F) as u8 | TAG_THREE_B;
                *b = (code &gt;&gt; 6 &amp; 0x3F) as u8 | TAG_CONT;
                *c = (code &amp; 0x3F) as u8 | TAG_CONT;
            }
            (4, [a, b, c, d, ..]) =&gt; {
                *a = (code &gt;&gt; 18 &amp; 0x07) as u8 | TAG_FOUR_B;
                *b = (code &gt;&gt; 12 &amp; 0x3F) as u8 | TAG_CONT;
                *c = (code &gt;&gt; 6 &amp; 0x3F) as u8 | TAG_CONT;
                *d = (code &amp; 0x3F) as u8 | TAG_CONT;
            }
            _ =&gt; panic!(
                &quot;encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}&quot;,
                len,
                code,
                dst.len(),
            ),
        };
        &amp;mut dst[..len]
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="字符串标准库代码分析"><a class="header" href="#字符串标准库代码分析">字符串标准库代码分析</a></h2>
<p>字符串模块的一个核心是Iterator，已经在Iterator章节中有过说明。<br />
除了Iterator，字符串其他的方法及函数库代码摘要分析如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn len(&amp;self) -&gt; usize {
        //字符串的len是字符串字节数目
        self.as_bytes().len()
    }
    //是否是字符的边界 
    pub fn is_char_boundary(&amp;self, index: usize) -&gt; bool {
        // 0 位置总是边界
        if index == 0 {
            return true;
        }

        match self.as_bytes().get(index) {
            
            None =&gt; index == self.len(),

            // 巧妙的对字符边界的总结: b &lt; 128 || b &gt;= 192
            Some(&amp;b) =&gt; (b as i8) &gt;= -0x40,
        }
    }
    //目前I的类型仅支持：
    // usize, ..(RangeFull), start..(RangeFrom), start..end(Range)
    // start..=end(RangeInclusive), ..end(RangeTo), ..=end(RangeToInclusive)  
    // get函数不会panic,但更习惯用str[usize],或者str[Range]来完成 
    pub fn get&lt;I: SliceIndex&lt;str&gt;&gt;(&amp;self, i: I) -&gt; Option&lt;&amp;I::Output&gt; {
        i.get(self)
    }
    //对i.get给出一个分析
    unsafe impl SliceIndex&lt;str&gt; for ops::Range&lt;usize&gt; {
        type Output = str;
        
        fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;Self::Output&gt; {
            //必须满足Range的两端都在字符边界处，否则返回None
            if self.start &lt;= self.end
                &amp;&amp; slice.is_char_boundary(self.start)
                &amp;&amp; slice.is_char_boundary(self.end)
            {
                // 重新建立了一个&amp;[str],具体见下面的函数
                Some(unsafe { &amp;*self.get_unchecked(slice) })
            } else {
                None
            }
        }
        //最终离不开内存和裸指针
        unsafe fn get_unchecked(self, slice: *const str) -&gt; *const Self::Output {
            let slice = slice as *const [u8];
            let ptr = unsafe { slice.as_ptr().add(self.start) };
            let len = self.end - self.start;
            ptr::slice_from_raw_parts(ptr, len) as *const str
        }
        ...
    }
    
    //其他可以用Index实现的get_xxx函数及split_at函数，略
    ...
<span class="boring">}</span></code></pre></pre>
<p>下面通过字符串的查找函数给出RUST良好的程序结构设计的一个例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //字符串查找函数，可以用模式匹配查找子串
    //支持如下例子中的查找    
    /// let s = &quot;Löwe 老虎 Léopard Gepardi&quot;;
    /// 字符的查找
    /// assert_eq!(s.find('L'), Some(0));
    /// assert_eq!(s.find('é'), Some(14));
    /// 
    /// 子字符串的查找
    /// assert_eq!(s.find(&quot;pard&quot;), Some(17));
    /// 
    /// 满足函数要求的字符或字符串的查找
    /// assert_eq!(s.find(char::is_lowercase), Some(1));
    /// assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));
    /// assert_eq!(s.find(|c: char| (c &lt; 'o') &amp;&amp; (c &gt; 'a')), Some(4));
    /// 
    /// 字符数组的查找，注意RUST中字符数组与字符串是不同的两个类型
    /// assert_eq!(s.find(['老', 'G']))
<span class="boring">}</span></code></pre></pre>
<p>由以上注释可以看到，rust的字符串查找函数功能强大，使用直观且易于理解。后继代码将展现RUST具备的：</p>
<ol>
<li>良好的扩展性，即使是原生类型，也可以直接在其上增加自定义Trait, 从而得到最直观的代码表现，而其他语言如C++/Java是无法在已经定义好的类型上做扩充的。只能创建新类型来实现对已有类型的功能扩展。不但在代码上不直观及冗余，也造成了额外的学习负担。</li>
<li>Trait语义的强大，即使对于闭包类型，也可以实现Trait。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find&lt;'a, P: Pattern&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; Option&lt;usize&gt; {
        //利用Pattern Trait支持了众多类型的查找
        pat.into_searcher(self).next_match().map(|(i, _)| i)
    }
<span class="boring">}</span></code></pre></pre>
<p>要设计这样一个find方法:</p>
<ol>
<li>显然，参数需要是一个泛型，但泛型应该支持同样的接口，即Pattern trait</li>
<li>需要利用find的输入泛型参数，self来构造一个结构，并以这个结构为基础来实现方法完成查找。Pattern trait 的类型显然不可能作为这个结构(字符，字符切片，字符数组，闭包函数，字符串). 这个结构只能由Pattern trait的方法构造，事实上，Pattern trait最重要的工作就是构造这个结构。</li>
<li>2构造的结构应该支持统一的接口，真正的实现查找</li>
</ol>
<p>具体的实现定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //模式 Trait 定义及公共行为
    pub trait Pattern&lt;'a&gt;: Sized {
        /// 与具体类型相适配的搜索算法的实现类型，类型必须实现Searcher Trait
        type Searcher: Searcher&lt;'a&gt;;

        /// 创建Searcher，根据输入的str及类型自身属性
        fn into_searcher(self, haystack: &amp;'a str) -&gt; Self::Searcher;

        /// 检查str是否存在对模式匹配的内容
        fn is_contained_in(self, haystack: &amp;'a str) -&gt; bool {
            self.into_searcher(haystack).next_match().is_some()
        }

        //略
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>以下为Searcher trait定义。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //Pattern匹配搜索算法的具体实现Trait
    pub unsafe trait Searcher&lt;'a&gt; {
        /// Searcher针对的字符串
        fn haystack(&amp;self) -&gt; &amp;'a str;

        /// 执行下一次搜索， 返回搜索算法给出的:
        ///   [SearchStep::Match(a,b)] haystack[a..b]匹配了模式
        ///   [SearchStep::Reject(a,b)] haystack[a..b]不能匹配模式
        ///   [SearchStep::Done]
        /// next的返回结果应该上次放回的结果首尾相连。即如果上次返回Match(0,1), next的返回
        /// 应该是Reject(1,_)或Match(1,_)。第一个返回必须是Reject(0,_)或match(0,_), Done之前
        /// 的返回应该是Reject(_, haystack.len()-1)或Match(_, haystack.len())
        fn next(&amp;mut self) -&gt; SearchStep;

        /// 找到下一个匹配结果是Match的匹配结果
        fn next_match(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
            loop {
                match self.next() {
                    SearchStep::Match(a, b) =&gt; return Some((a, b)),
                    SearchStep::Done =&gt; return None,
                    _ =&gt; continue,
                }
            }
        }

        /// 找到下一个Reject
        fn next_reject(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
            loop {
                match self.next() {
                    SearchStep::Reject(a, b) =&gt; return Some((a, b)),
                    SearchStep::Done =&gt; return None,
                    _ =&gt; continue,
                }
            }
        }
   }

    pub enum SearchStep {
        /// 匹配时输出Match及子字符串的位置
        Match(usize, usize),
        /// 确定不匹配的子字符串的位置信息, 可以有多个不匹配的子字符串
        Reject(usize, usize),
        /// 字符串已经遍历完毕
        Done,
    }
<span class="boring">}</span></code></pre></pre>
<p>下面为单字符的Pattern trait的系列实现，仅展示一下相应的逻辑关系。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //针对char类型的Searcher Trait具现化类型
    pub struct CharSearcher&lt;'a&gt; { /*略*/ }
    //实现Searcher Trait
    unsafe impl&lt;'a&gt; Searcher&lt;'a&gt; for CharSearcher&lt;'a&gt; {
        //略
        ...
    }

    // 针对char 的Pattern实现, 支持如 &quot;abc&quot;.find('a') 的形态
    impl&lt;`a, `b&gt; Pattern&lt;`a&gt; for char { 
        type Searcher = CharSearcher
        
        //略
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>下面为多字符的Pattern trait的实现，因为是比较典型的设计，所以重点的进行分析：
首先，设计字符匹配的trait，并在闭包，字符数组及其引用，字符切片类型中实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //支持  &quot;abc&quot;.find(&amp;['a','b'])的形态
    //      &quot;abc&quot;.find(&amp;['a','b'][..]) 的形态 &amp;['a','b'][..] 实质是&amp;[char]类型，注意与&amp;str类型的区别
    //      &quot;abc&quot;.find(|ch| ch &gt; 'a' &amp;&amp; ch &lt; 'c') 的形态
    
    //利用MultiCharEq trait 综合[char; N], &amp;[char], FnMut(char)-&gt;bool 
    //字符匹配操作
    trait MultiCharEq {
        fn matches(&amp;mut self, c: char) -&gt; bool;
    }
    
    //为FnMut(char)-&gt;bool 实现MultiCharEq
    impl&lt;F&gt; MultiCharEq for F
    where
        F: FnMut(char) -&gt; bool,
    {
        fn matches(&amp;mut self, c: char) -&gt; bool {
            (*self)(c)
        }
    }
    
    //为[char;N]实现 MultiCharEq
    impl&lt;const N: usize&gt; MultiCharEq for [char; N] {
        fn matches(&amp;mut self, c: char) -&gt; bool {
            self.iter().any(|&amp;m| m == c)
        }
    }

    impl&lt;const N: usize&gt; MultiCharEq for &amp;[char; N] {
        fn matches(&amp;mut self, c: char) -&gt; bool {
            self.iter().any(|&amp;m| m == c)
        }
    }
    
    // 为&amp;[char]实现MultiCharEq
    impl MultiCharEq for &amp;[char] {
        #[inline]
        fn matches(&amp;mut self, c: char) -&gt; bool {
            self.iter().any(|&amp;m| m == c)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>然后是基于泛型的统一的Pattern trait和Searcher的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   //利用输入类型构造一个泛型结构
   struct MultiCharEqPattern&lt;C: MultiCharEq&gt;(C);

   //与MultiCharEqPattern相匹配的Searcher Trait具现的结构体
   struct MultiCharEqSearcher&lt;'a, C: MultiCharEq&gt; {
       char_eq: C,
       haystack: &amp;'a str,
       char_indices: super::CharIndices&lt;'a&gt;,
   }
   
   // 实现Pattern
   impl&lt;'a, C: MultiCharEq&gt; Pattern&lt;'a&gt; for MultiCharEqPattern&lt;C&gt; {
       type Searcher = MultiCharEqSearcher&lt;'a, C&gt;;
       
       //创建泛型Searcher结构
       fn into_searcher(self, haystack: &amp;'a str) -&gt; MultiCharEqSearcher&lt;'a, C&gt; {
           MultiCharEqSearcher { haystack, char_eq: self.0, char_indices: haystack.char_indices()}
       }
   }

   //针对泛型Searcher结构实现Searcher trait
   unsafe impl&lt;'a, C: MultiCharEq&gt; Searcher&lt;'a&gt; for MultiCharEqSearcher&lt;'a, C&gt; {
       fn haystack(&amp;self) -&gt; &amp;'a str {
           self.haystack
       }

       fn next(&amp;mut self) -&gt; SearchStep {
           let s = &amp;mut self.char_indices;
           //pre_len用来计算char在字符串中占用了几个字节
           let pre_len = s.iter.iter.len();
           if let Some((i, c)) = s.next() {
               let len = s.iter.iter.len();
               //计算当前字符占用的字节数
               let char_len = pre_len - len;
               if self.char_eq.matches(c) {
                   return SearchStep::Match(i, i + char_len);
               } else {
                   return SearchStep::Reject(i, i + char_len);
               }
           }
           SearchStep::Done
       }
   }
<span class="boring">}</span></code></pre></pre>
<p>下面是如何将MultiCharEqPattern及MultiCharEqSearcher应用在各类型的Pattern实现中。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    /////////////////////////////////////////////////////////////////////////////
    //利用宏简化代码
    macro_rules! pattern_methods {
        ($t:ty, $pmap:expr, $smap:expr) =&gt; {
            type Searcher = $t;

            fn into_searcher(self, haystack: &amp;'a str) -&gt; $t {
                //这里实际上是用self创建了MultiCharEqPattern(self)
                //随后用MutiEqPattern(self)创建MultiCharEqSearcher
                //然后封装MultiCharEqSearcher，创建一个与self类型关联的Searcher类型的Searcher
                ($smap)(($pmap)(self).into_searcher(haystack))
            }

            fn is_contained_in(self, haystack: &amp;'a str) -&gt; bool {
                ($pmap)(self).is_contained_in(haystack)
            }

            fn is_prefix_of(self, haystack: &amp;'a str) -&gt; bool {
                ($pmap)(self).is_prefix_of(haystack)
            }

            fn strip_prefix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt; {
                ($pmap)(self).strip_prefix_of(haystack)
            }

            fn is_suffix_of(self, haystack: &amp;'a str) -&gt; bool
            where
                $t: ReverseSearcher&lt;'a&gt;,
            {
                ($pmap)(self).is_suffix_of(haystack)
            }

            fn strip_suffix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;
            where
                $t: ReverseSearcher&lt;'a&gt;,
            {
                ($pmap)(self).strip_suffix_of(haystack)
            }
        };
    }

    // 利用宏简化代码
    macro_rules! searcher_methods {
        (forward) =&gt; {
            fn haystack(&amp;self) -&gt; &amp;'a str {
                self.0.haystack()
            }
            fn next(&amp;mut self) -&gt; SearchStep {
                //实质是MultiCharEqSearcher&lt;&gt;::next
                self.0.next()
            }
            fn next_match(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
                self.0.next_match()
            }
            fn next_reject(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
                self.0.next_reject()
            }
        };
        (reverse) =&gt; {
            fn next_back(&amp;mut self) -&gt; SearchStep {
                self.0.next_back()
            }
            fn next_match_back(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
                self.0.next_match_back()
            }
            fn next_reject_back(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
                self.0.next_reject_back()
            }
        };
    }

    //下面这个结构比较清晰的说明了 Pattern, MultiCharEqPattern, MultiCharEqSearcher的关系
    //使得代码更清晰
    pub struct CharArraySearcher&lt;'a, const N: usize&gt;(
        &lt;MultiCharEqPattern&lt;[char; N]&gt; as Pattern&lt;'a&gt;&gt;::Searcher,
    );

    /// 针对&amp;[char;N]的Pattern, MultiCharEqPattern, MultiCharEqSearcher的关系
    pub struct CharArrayRefSearcher&lt;'a, 'b, const N: usize&gt;(
        &lt;MultiCharEqPattern&lt;&amp;'b [char; N]&gt; as Pattern&lt;'a&gt;&gt;::Searcher,
    );
    
    // 利用上面的宏对[char;N]类型的Pattern Trait实现
    impl&lt;'a, const N: usize&gt; Pattern&lt;'a&gt; for [char; N] {
        pattern_methods!(CharArraySearcher&lt;'a, N&gt;, MultiCharEqPattern, CharArraySearcher);
    }
    // 对[char;N]的searcher关联类型的Searcher Trait实现，
    unsafe impl&lt;'a, const N: usize&gt; Searcher&lt;'a&gt; for CharArraySearcher&lt;'a, N&gt; {
        searcher_methods!(forward);
    }

    unsafe impl&lt;'a, const N: usize&gt; ReverseSearcher&lt;'a&gt; for CharArraySearcher&lt;'a, N&gt; {
        searcher_methods!(reverse);
    }

    // 针对&amp;[char;N]的Pattern Trait 实现
    impl&lt;'a, 'b, const N: usize&gt; Pattern&lt;'a&gt; for &amp;'b [char; N] {
        pattern_methods!(CharArrayRefSearcher&lt;'a, 'b, N&gt;, MultiCharEqPattern, CharArrayRefSearcher);
    }

    // 对&amp;[char;N]的searcher关联类型的Searcher Trait 实现
    unsafe impl&lt;'a, 'b, const N: usize&gt; Searcher&lt;'a&gt; for CharArrayRefSearcher&lt;'a, 'b, N&gt; {
        searcher_methods!(forward);
    }

    unsafe impl&lt;'a, 'b, const N: usize&gt; ReverseSearcher&lt;'a&gt; for CharArrayRefSearcher&lt;'a, 'b, N&gt; {
        searcher_methods!(reverse);
    }

    //针对&amp;[char]的Searcher具现化结构体
    pub struct CharSliceSearcher&lt;'a, 'b&gt;(&lt;MultiCharEqPattern&lt;&amp;'b [char]&gt; as Pattern&lt;'a&gt;&gt;::Searcher);

    //Searcher Trait 实现
    unsafe impl&lt;'a, 'b&gt; Searcher&lt;'a&gt; for CharSliceSearcher&lt;'a, 'b&gt; {
        searcher_methods!(forward);
    }

    unsafe impl&lt;'a, 'b&gt; ReverseSearcher&lt;'a&gt; for CharSliceSearcher&lt;'a, 'b&gt; {
        searcher_methods!(reverse);
    }

    impl&lt;'a, 'b&gt; DoubleEndedSearcher&lt;'a&gt; for CharSliceSearcher&lt;'a, 'b&gt; {}

    // 对&amp;[char]的Pattern Trait的实现
    impl&lt;'a, 'b&gt; Pattern&lt;'a&gt; for &amp;'b [char] {
        pattern_methods!(CharSliceSearcher&lt;'a, 'b&gt;, MultiCharEqPattern, CharSliceSearcher);
    }

    //针对FnMut(char)-&gt;bool的Searcher具现化结构体
    pub struct CharPredicateSearcher&lt;'a, F&gt;(&lt;MultiCharEqPattern&lt;F&gt; as Pattern&lt;'a&gt;&gt;::Searcher)
    where
        F: FnMut(char) -&gt; bool;

    //Searcher Trait 实现
    unsafe impl&lt;'a, F&gt; Searcher&lt;'a&gt; for CharPredicateSearcher&lt;'a, F&gt;
    where
        F: FnMut(char) -&gt; bool,
    {
        searcher_methods!(forward);
    }

    unsafe impl&lt;'a, F&gt; ReverseSearcher&lt;'a&gt; for CharPredicateSearcher&lt;'a, F&gt;
    where
        F: FnMut(char) -&gt; bool,
    {
        searcher_methods!(reverse);
    }

    impl&lt;'a, F&gt; DoubleEndedSearcher&lt;'a&gt; for CharPredicateSearcher&lt;'a, F&gt; where F: FnMut(char) -&gt; bool {}

    //针对FnMut(char)-&gt;bool的Pattern Trait 实现
    impl&lt;'a, F&gt; Pattern&lt;'a&gt; for F
    where
        F: FnMut(char) -&gt; bool,
    {
        pattern_methods!(CharPredicateSearcher&lt;'a, F&gt;, MultiCharEqPattern, CharPredicateSearcher);
    }
<span class="boring">}</span></code></pre></pre>
<p>多字符搜索代码不复杂，但结构设计则可圈可点。而且似乎是不得不这样做设计。RUST利用泛型及trait能够自然的得到比较好的设计结果。<br />
我们针对泛型做一个方法时，自然会对泛型用一个共用的trait——Pattern来约束。因为方法实现需要不同于泛型但紧密关联的另一个结构体，那这个结构体类型便自然的形成trait里的一个关联类型Searcher。而这个关联类型也自然应该用另一个trait——Searcher来约束。<br />
Searcher的变量应该在Pattern的方法被创建出来。Searcher trait应该提供查找的方法。<br />
这就是RUST语法自然导致好的设计的一个例子。</p>
<p>以下对子字符串搜索给出一些详细的解释，主要说明TwoWay算法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span> 
<span class="boring">fn main() {
</span>    //针对str实现的pattern， 支持如&quot;abc&quot;.find(&quot;ab&quot;)的形态
    impl&lt;'a, 'b&gt; Pattern&lt;'a&gt; for &amp;'b str {
        //StrSeacher见下面该结构的代码注释
        type Searcher = StrSearcher&lt;'a, 'b&gt;;

        fn into_searcher(self, haystack: &amp;'a str) -&gt; StrSearcher&lt;'a, 'b&gt; {
            StrSearcher::new(haystack, self)
        }
        
        //略
    }

    pub struct StrSearcher&lt;'a, 'b&gt; {
        // 被查找目标字符串
        haystack: &amp;'a str,
        // 查找的子字符串
        needle: &amp;'b str,
        // 查找算法实现体
        searcher: StrSearcherImpl,
    }

    enum StrSearcherImpl {
        //两种搜索算法，后继还可以根据需要再扩充其他的算法
        Empty(EmptyNeedle),
        TwoWay(TwoWaySearcher),
    }

   
    impl&lt;'a, 'b&gt; StrSearcher&lt;'a, 'b&gt; {
        fn new(haystack: &amp;'a str, needle: &amp;'b str) -&gt; StrSearcher&lt;'a, 'b&gt; {
            if needle.is_empty() {
                //略
                ...
                ...
            } else {
                StrSearcher {
                    haystack,
                    needle,
                    searcher: StrSearcherImpl::TwoWay(TwoWaySearcher::new(
                        needle.as_bytes(),
                        haystack.len(),
                    )),
                }
            }
        }
    }

    unsafe impl&lt;'a, 'b&gt; Searcher&lt;'a&gt; for StrSearcher&lt;'a, 'b&gt; {
        fn haystack(&amp;self) -&gt; &amp;'a str {
            self.haystack
        }

        fn next(&amp;mut self) -&gt; SearchStep {
            //此处隐藏StrSearcher后继不会更换算法。如果更换搜索算法，应该将StrSearcher整体做替换
            //
            match self.searcher {
                StrSearcherImpl::Empty(ref mut searcher) =&gt; {
                    //略
                    ...
                    ...
                }
                StrSearcherImpl::TwoWay(ref mut searcher) =&gt; {
                    if searcher.position == self.haystack.len() {
                        return SearchStep::Done;
                    }
                    let is_long = searcher.memory == usize::MAX;
                    match searcher.next::&lt;RejectAndMatch&gt;(
                        self.haystack.as_bytes(),
                        self.needle.as_bytes(),
                        is_long,
                    ) {
                        SearchStep::Reject(a, mut b) =&gt; {
                            // 因为searcher使用&amp;[u8]来搜索，返回可能不是字节边界
                            while !self.haystack.is_char_boundary(b) {
                                b += 1;
                            }
                            searcher.position = cmp::max(b, searcher.position);
                            SearchStep::Reject(a, b)
                        }
                        //这个表示语法注意一下
                        otherwise =&gt; otherwise,
                    }
                }
            }
        }

        fn next_match(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
            match self.searcher {
                StrSearcherImpl::Empty(..) =&gt; loop {
                    //略
                    ...
                },
                StrSearcherImpl::TwoWay(ref mut searcher) =&gt; {
                    let is_long = searcher.memory == usize::MAX;
                    // 如果匹配，那匹配点一定是字符边界
                    if is_long {
                        searcher.next::&lt;MatchOnly&gt;(
                            self.haystack.as_bytes(),
                            self.needle.as_bytes(),
                            true,
                        )
                    } else {
                        searcher.next::&lt;MatchOnly&gt;(
                            self.haystack.as_bytes(),
                            self.needle.as_bytes(),
                            false,
                        )
                    }
                }
            }
        }
    }
    /*  查找子字符串算法的关键问题如下：
        1. 每次比较的匹配的位置在哪里？
        2. 不匹配时应移动多少个位置开始新一次匹配？

        显然，如果子字符串不存在周期性的重复，那每次比较如果不同就只能后移一个字符然后开始新的匹配
        所以，算法主要就是在子字符串中存在周期性重复的字符的情况下来如何更好的提高效率
        TwoWay算法仅在子字符串整体有周期性时发生左右，仅是内部少量字符的周期性，TwoWay算法不考虑。
        设待比较字符串为H, 子字符串为S, 周期字符串为w, 周期为p，w的前缀为w-则S为 w(w|w-)+
        对于S，TwoWay算法找到一个crit_pos, 先从S的crit_pos的位置开始与H做比较到S的尾部，如果对应字符位置crit_pos+i
        的比较不成功，会在S上偏移i，清除记录，然后继续比较。
        如果直到尾部比较都成功，则会记录，然后开始比较头部，如果头部比较不成功，则偏移p，后继比较会考虑比较成功的记录。
        
        TwoWay不是最快的算法，但占用内存少，且也在一定程度上提高了效率。是比较适合的库方法
        */
    struct TwoWaySearcher {
        // constants
        /// 每次比较的开始位置，从此位置向尾部
        crit_pos: usize,
        /// 每次反向比较的开始位置，从此位置向前部
        crit_pos_back: usize,
        // 周期
        period: usize,
        /// 子字符串的位图，用来做一个快速甄别和判断
        byteset: u64,

        // 在待比较字符串的位置,从头部向后查找
        position: usize,
        // 待比较字符串的位置，从尾部向前查找
        end: usize,
        /// 在尾部比较成功后，记录已经比较过的字符串
        memory: usize,
        /// 同上，不过是反方向比较
        memory_back: usize,
    }

    impl TwoWaySearcher {
        fn new(needle: &amp;[u8], end: usize) -&gt; TwoWaySearcher {
            let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);
            let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);
            
            //找到更偏向尾部的位置
            let (crit_pos, period) = if crit_pos_false &gt; crit_pos_true {
                (crit_pos_false, period_false)
            } else {
                (crit_pos_true, period_true)
            };

            //这里可以看出，只有从头部开始的周期字符串获得支持
            if needle[..crit_pos] == needle[period..period + crit_pos] {
                let crit_pos_back = needle.len()
                    - cmp::max(
                        TwoWaySearcher::reverse_maximal_suffix(needle, period, false),
                        TwoWaySearcher::reverse_maximal_suffix(needle, period, true),
                    );

                TwoWaySearcher {
                    crit_pos,
                    crit_pos_back,
                    period,
                    byteset: Self::byteset_create(&amp;needle[..period]),

                    position: 0,
                    end,
                    memory: 0,
                    memory_back: needle.len(),
                }
            } else {
                // 字符串内没有周期性，及仅具备局部周期的字符串

                TwoWaySearcher {
                    crit_pos,
                    crit_pos_back: crit_pos,
                    period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,
                    byteset: Self::byteset_create(needle),

                    position: 0,
                    end,
                    memory: usize::MAX, // Dummy value to signify that the period is long
                    memory_back: usize::MAX,
                }
            }
        }

        fn byteset_create(bytes: &amp;[u8]) -&gt; u64 {
            bytes.iter().fold(0, |a, &amp;b| (1 &lt;&lt; (b &amp; 0x3f)) | a)
        }

        fn byteset_contains(&amp;self, byte: u8) -&gt; bool {
            (self.byteset &gt;&gt; ((byte &amp; 0x3f) as usize)) &amp; 1 != 0
        }

        fn next&lt;S&gt;(&amp;mut self, haystack: &amp;[u8], needle: &amp;[u8], long_period: bool) -&gt; S::Output
        where
            S: TwoWayStrategy,
        {
            // `next()` uses `self.position` as its cursor
            let old_pos = self.position;
            let needle_last = needle.len() - 1;
            'search: loop {
                // Check that we have room to search in
                // position + needle_last can not overflow if we assume slices
                // are bounded by isize's range.
                let tail_byte = match haystack.get(self.position + needle_last) {
                    Some(&amp;b) =&gt; b,
                    None =&gt; {
                        self.position = haystack.len();
                        return S::rejecting(old_pos, self.position);
                    }
                };
                
                //及早返回不匹配的信息
                if S::use_early_reject() &amp;&amp; old_pos != self.position {
                    return S::rejecting(old_pos, self.position);
                }

                // 用位图判断出tail_byte不在子字符串中，可以立刻偏移到下一个字节再比较
                if !self.byteset_contains(tail_byte) {
                    self.position += needle.len();
                    if !long_period {
                        self.memory = 0;
                    }
                    continue 'search;
                }

                // 如果memory有值且大于crip_pos, 那就从memory开始比较，memory前的已经匹配完毕
                // long_period 没有memory的逻辑，和暴力比较无差异
                let start =
                    if long_period { self.crit_pos } else { cmp::max(self.crit_pos, self.memory) };
                for i in start..needle.len() {
                    if needle[i] != haystack[self.position + i] {
                        self.position += i - self.crit_pos + 1;
                        if !long_period {
                            self.memory = 0;
                        }
                        continue 'search;
                    }
                }

                // See if the left part of the needle matches
                let start = if long_period { 0 } else { self.memory };
                for i in (start..self.crit_pos).rev() {
                    if needle[i] != haystack[self.position + i] {
                        //period后面的字符已经比较完毕，period一般大于crit_pos
                        self.position += self.period;
                        if !long_period {
                            self.memory = needle.len() - self.period;
                        }
                        continue 'search;
                    }
                }

                // 比较全部完成，
                let match_pos = self.position;

                // 为下一次比较做准备
                self.position += needle.len();
                if !long_period {
                    self.memory = 0; // set to needle.len() - self.period for overlapping matches
                }

                return S::matching(match_pos, match_pos + needle.len());
            }
        }

        // 略

    }
    // TwoWayStrategy allows the algorithm to either skip non-matches as quickly
    // as possible, or to work in a mode where it emits Rejects relatively quickly.
    trait TwoWayStrategy {
        type Output;
        fn use_early_reject() -&gt; bool;
        fn rejecting(a: usize, b: usize) -&gt; Self::Output;
        fn matching(a: usize, b: usize) -&gt; Self::Output;
    }

    /// Skip to match intervals as quickly as possible
    enum MatchOnly {}

    impl TwoWayStrategy for MatchOnly {
        type Output = Option&lt;(usize, usize)&gt;;

        fn use_early_reject() -&gt; bool {
            false
        }
        fn rejecting(_a: usize, _b: usize) -&gt; Self::Output {
            None
        }
        fn matching(a: usize, b: usize) -&gt; Self::Output {
            Some((a, b))
        }
    }

    /// Emit Rejects regularly
    enum RejectAndMatch {}

    impl TwoWayStrategy for RejectAndMatch {
        type Output = SearchStep;

        fn use_early_reject() -&gt; bool {
            true
        }
        fn rejecting(a: usize, b: usize) -&gt; Self::Output {
            SearchStep::Reject(a, b)
        }
        fn matching(a: usize, b: usize) -&gt; Self::Output {
            SearchStep::Match(a, b)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>以上对字符串查找的方法进行了分析，利用Pattern的还有以下的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //生成一个支持Iterator的结构完成split
    pub fn split&lt;'a, P: Pattern&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; Split&lt;'a, P&gt; {
        Split(SplitInternal {
            start: 0,
            end: self.len(),
            matcher: pat.into_searcher(self),
            allow_trailing_empty: true,
            finished: false,
        })
    }

    //略
    ...
    ...
<span class="boring">}</span></code></pre></pre>
<h2 id="切片标准库代码分析"><a class="header" href="#切片标准库代码分析">切片标准库代码分析</a></h2>
<h3 id="切片排序"><a class="header" href="#切片排序">切片排序</a></h3>
<h4 id="插入排序"><a class="header" href="#插入排序">插入排序</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 插入排序, 复杂度O(n^2).
fn insertion_sort&lt;T, F&gt;(v: &amp;mut [T], is_less: &amp;mut F)
where
    F: FnMut(&amp;T, &amp;T) -&gt; bool,
{
    //排序场景下，基本不能使用iterator
    for i in 1..v.len() {
        //利用
        shift_tail(&amp;mut v[..i + 1], is_less);
    }
}

/// 将最后的值左移到遇到更小的值.
fn shift_tail&lt;T, F&gt;(v: &amp;mut [T], is_less: &amp;mut F)
where
    F: FnMut(&amp;T, &amp;T) -&gt; bool,
{
    let len = v.len();
    
    // 因为是对泛型排序，RUST的排序算法比较复杂， 需要指出，&amp;mut [T] 保证了外界不会有对数组或数组元素的引用，而数组元素本身的内存
    // 浅拷贝等同于所有权转移，不会出现内存安全问题。
    unsafe {
        if len &gt;= 2 &amp;&amp; is_less(v.get_unchecked(len - 1), v.get_unchecked(len - 2)) {
            // ManuallyDrop把drop的权利从rust编译器接管
            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));
            // CopyOnDrop会在drop的时候做src到dest的拷贝
            let mut hole = CopyOnDrop { src: &amp;mut *tmp, dest: v.get_unchecked_mut(len - 2) };
            ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);
            
            //正常的排序内存置换操作
            for i in (0..len - 2).rev() {
                if !is_less(&amp;*tmp, v.get_unchecked(i)) {
                    break;
                }

                ptr::copy_nonoverlapping(v.get_unchecked(i), v.get_unchecked_mut(i + 1), 1);
                hole.dest = v.get_unchecked_mut(i);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>上面的排序算法最重要的是理解在元素转移的过程为什么没有影响所有权，为什么没有引发内存安全问题。这个例子充分说明了内存先关函数的重要性。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="05-Iterator.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="07-内部可变性类型.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="05-Iterator.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="07-内部可变性类型.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
