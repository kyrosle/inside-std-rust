<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>std库(一)FFI及内存管理 - rust-inside-std-book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="引言.html">引言</a></li><li class="chapter-item expanded affix "><a href="01-RUST库体系概述.html">RUST库体系概述</a></li><li class="chapter-item expanded affix "><a href="02-内存.html">内存</a></li><li class="chapter-item expanded affix "><a href="03-固有函数库及基础类型.html">固有函数库及基础类型</a></li><li class="chapter-item expanded affix "><a href="04-基础Trait.html">基础Trait</a></li><li class="chapter-item expanded affix "><a href="05-Iterator.html">Iterator</a></li><li class="chapter-item expanded affix "><a href="06-基本类型续.html">基本类型续</a></li><li class="chapter-item expanded affix "><a href="07-内部可变性类型.html">内部可变性类型</a></li><li class="chapter-item expanded affix "><a href="08-智能指针类型(一).html">智能指针类型(一)</a></li><li class="chapter-item expanded affix "><a href="09-智能指针类型(二).html">智能指针类型(二)</a></li><li class="chapter-item expanded affix "><a href="10-智能指针类型(三).html">智能指针类型(三)</a></li><li class="chapter-item expanded affix "><a href="11-智能指针类型(四).html">智能指针类型(四)</a></li><li class="chapter-item expanded affix "><a href="12-std库(一)FFI及内存管理.html" class="active">std库(一)FFI及内存管理</a></li><li class="chapter-item expanded affix "><a href="13-std库(二)文件描述符及进程管理.html">std库(二)文件描述符及进程管理</a></li><li class="chapter-item expanded affix "><a href="14-std库(三)线程间锁通信.html">std库(三)线程间锁通信</a></li><li class="chapter-item expanded affix "><a href="15-std库(四)线程临界区类型.html">std库(四)线程临界区类型</a></li><li class="chapter-item expanded affix "><a href="16-std库(五)线程管理.html">std库(五)线程管理</a></li><li class="chapter-item expanded affix "><a href="17-std库(六)mpsc通信.html">std库(六)mpsc通信</a></li><li class="chapter-item expanded affix "><a href="18-std库(七)RUST的RUNTIME.html">std库(七)RUST的RUNTIME</a></li><li class="chapter-item expanded affix "><a href="19-std库(八)RUST文件系统.html">std库(八)RUST文件系统</a></li><li class="chapter-item expanded affix "><a href="20-std库(九)RUST的IO.html">std库(九)RUST的IO</a></li><li class="chapter-item expanded affix "><a href="21-RUST的异步编程.html">RUST的异步编程</a></li><li class="chapter-item expanded affix "><a href="后记.html">后记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-inside-std-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="茶歇"><a class="header" href="#茶歇">茶歇</a></h1>
<p>前面章节已经基本把core库及alloc库分析完毕。这两个库是不依赖于操作系统的。<br />
后继主要分析的std库，即在library/std/src目录下的代码，将紧密的与操作系统发生关联。<br />
C程序员开发一个大型的跨操作系统的应用时。在操作系统的C标准库的基础上实现一个适配层，屏蔽不同操作系统的
C标准库的差异是必须的一个工作。<br />
RUST的标准库也同样，在library/std/src/sys; library/std/src/os下实现了对不同操作系统的适配层。这一适配层完成的工作：</p>
<ol>
<li>定义RUST本身对于操作系统的统一的类型结构，方法及函数。提供给标准库其他模块使用。</li>
<li>将1中定义适配按照操作系统完成对系统调用的类型，函数的适配。 </li>
</ol>
<p>RUST适配操作系统调用的难度在于要将操作系统的资源及操作转换为适合RUST的所有权，借用及生命周期概念的类型及操作。<br />
因为操作系统的系统调用基本上都是C语言，RUST设计了非常方便及简单的与C的交互机制，RUST与C的交互类似于C++与C的交互，几乎是无缝的融合。而在操作系统适配层这个层面，与其说是RUST程序，不如说是RUST语法的C程序。C程序员感觉到十分的熟悉和亲切。</p>
<p>在适配层之上，RUST按照自身语法的要求，对适配层的实现做了若干扩展。如针对RUST全局静态变量的扩展。这一部分代码放在library/std/src/syscommon 目录下。</p>
<p>操作系统的适配层提供的结构显然还太过于底层及复杂，RUST在此基础上实现了更符合现代语言的类型结构，方法，函数，作为标准库的外界接口提供给RUST的程序员。</p>
<p>后继分析如下进行：</p>
<ol>
<li>按照操作系统的内存管理，文件描述符，进程/线程管理，进程/线程间通信，IO, 网络，文件, 时间，异步编程，杂项的顺序做分析</li>
<li>分析先给出RUST对操作系统适配层及适配层扩展实现，主要给出linux的相关实现代码摘要分析。适当的给一下wasi的代码分析。</li>
<li>RUST在2的基础上实现的标准库外部接口。</li>
</ol>
<h1 id="rust中与c语言互通"><a class="header" href="#rust中与c语言互通">RUST中与C语言互通</a></h1>
<p>因为涉及到大量的C语言库函数的调用，所以，我们首先要搞清楚如何与C语言互操作的内容。RUST与C语言互操作，主要就是完成RUST到C语言的类型转换，以及函数调用语义的实现。<br />
代码路径： library/std/src/ffi/<em>.</em></p>
<h2 id="c语言类型定义适配"><a class="header" href="#c语言类型定义适配">C语言类型定义适配</a></h2>
<p>代码路径：library/core/ffi/mod.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! type_alias_no_nz {
    {
      $Docfile:tt, $Alias:ident = $Real:ty;
      $( $Cfg:tt )*
    } =&gt; {
        #[doc = include_str!($Docfile)]
        $( $Cfg )*
        #[unstable(feature = &quot;core_ffi_c&quot;, issue = &quot;94501&quot;)]
        pub type $Alias = $Real;
    }
}

macro_rules! type_alias {
    {
      $Docfile:tt, $Alias:ident = $Real:ty, $NZAlias:ident = $NZReal:ty;
      $( $Cfg:tt )*
    } =&gt; {
        type_alias_no_nz! { $Docfile, $Alias = $Real; $( $Cfg )* }

        #[doc = concat!(&quot;Type alias for `NonZero` version of [`&quot;, stringify!($Alias), &quot;`]&quot;)]
        #[unstable(feature = &quot;raw_os_nonzero&quot;, issue = &quot;82363&quot;)]
        $( $Cfg )*
        pub type $NZAlias = $NZReal;
    }
}

//以下的定义，对所有C语言的类型以&quot;c_xxxx&quot;来命名，并用类型别名的形式定义为RUST的类型
//以下做了简化，仅针对linux操作系统
type_alias! { &quot;c_char.md&quot;, c_char = c_char_definition::c_char, NonZero_c_char = c_char_definition::NonZero_c_char;
type_alias! { &quot;c_schar.md&quot;, c_schar = i8, NonZero_c_schar = NonZeroI8; }
type_alias! { &quot;c_uchar.md&quot;, c_uchar = u8, NonZero_c_uchar = NonZeroU8; }
type_alias! { &quot;c_short.md&quot;, c_short = i16, NonZero_c_short = NonZeroI16; }
type_alias! { &quot;c_ushort.md&quot;, c_ushort = u16, NonZero_c_ushort = NonZeroU16; }
type_alias! { &quot;c_int.md&quot;, c_int = i32, NonZero_c_int = NonZeroI32; }
type_alias! { &quot;c_uint.md&quot;, c_uint = u32, NonZero_c_uint = NonZeroU32; }
type_alias! { &quot;c_long.md&quot;, c_long = i32, NonZero_c_long = NonZeroI32;
type_alias! { &quot;c_ulong.md&quot;, c_ulong = u32, NonZero_c_ulong = NonZeroU32;
type_alias! { &quot;c_longlong.md&quot;, c_longlong = i64, NonZero_c_longlong = NonZeroI64; }
type_alias! { &quot;c_ulonglong.md&quot;, c_ulonglong = u64, NonZero_c_ulonglong = NonZeroU64; }
type_alias_no_nz! { &quot;c_float.md&quot;, c_float = f32; }
type_alias_no_nz! { &quot;c_double.md&quot;, c_double = f64; 

pub type c_size_t = usize;
pub type c_ptrdiff_t = isize;
pub type c_ssize_t = isize;

mod c_char_definition {
    cfg_if! {
        if #[cfg(any(
            all(
                target_os = &quot;linux&quot;,
                any(
                    target_arch = &quot;aarch64&quot;,
                    target_arch = &quot;arm&quot;,
                    target_arch = &quot;powerpc&quot;,
                    target_arch = &quot;powerpc64&quot;,
                    target_arch = &quot;s390x&quot;,
                    target_arch = &quot;riscv64&quot;,
                    target_arch = &quot;riscv32&quot;
                )
            ),
            all(target_os = &quot;fuchsia&quot;, target_arch = &quot;aarch64&quot;)
        ))] {
            pub type c_char = u8;
            pub type NonZero_c_char = crate::num::NonZeroU8;
        } 
    }        
}
//以下是针对C语言的可变参数 VA_ARG给出的相关RUST匹配
pub enum c_void {
    __variant1,
    __variant2,
}

pub struct VaListImpl&lt;'f&gt; {
    gp_offset: i32,
    fp_offset: i32,
    overflow_arg_area: *mut c_void,
    reg_save_area: *mut c_void,
    _marker: PhantomData&lt;&amp;'f mut &amp;'f c_void&gt;,
}

pub struct VaList&lt;'a, 'f: 'a&gt; {
    inner: &amp;'a mut VaListImpl&lt;'f&gt;,

    _marker: PhantomData&lt;&amp;'a mut VaListImpl&lt;'f&gt;&gt;,
}

impl&lt;'f&gt; VaListImpl&lt;'f&gt; {
    pub fn as_va_list&lt;'a&gt;(&amp;'a mut self) -&gt; VaList&lt;'a, 'f&gt; {
        VaList { inner: self, _marker: PhantomData }
    }
}
impl&lt;'f&gt; Clone for VaListImpl&lt;'f&gt; {
    #[inline]
    fn clone(&amp;self) -&gt; Self {
        let mut dest = crate::mem::MaybeUninit::uninit();
        // SAFETY: we write to the `MaybeUninit`, thus it is initialized and `assume_init` is legal
        unsafe {
            va_copy(dest.as_mut_ptr(), self);
            dest.assume_init()
        }
    }
}

impl&lt;'f&gt; VaListImpl&lt;'f&gt; {
    /// Advance to the next arg.
    #[inline]
    pub unsafe fn arg&lt;T: sealed_trait::VaArgSafe&gt;(&amp;mut self) -&gt; T {
        // SAFETY: the caller must uphold the safety contract for `va_arg`.
        unsafe { va_arg(self) }
    }

    /// Copies the `va_list` at the current location.
    pub unsafe fn with_copy&lt;F, R&gt;(&amp;self, f: F) -&gt; R
    where
        F: for&lt;'copy&gt; FnOnce(VaList&lt;'copy, 'f&gt;) -&gt; R,
    {
        let mut ap = self.clone();
        let ret = f(ap.as_va_list());
        // SAFETY: the caller must uphold the safety contract for `va_end`.
        unsafe {
            va_end(&amp;mut ap);
        }
        ret
    }
}

extern &quot;rust-intrinsic&quot; {
    //以下缺少了C语言va_start的对应，RUST不需要
    /// Destroy the arglist `ap` after initialization with `va_start` or
    /// `va_copy`.
    fn va_end(ap: &amp;mut VaListImpl&lt;'_&gt;);

    /// Copies the current location of arglist `src` to the arglist `dst`.
    fn va_copy&lt;'f&gt;(dest: *mut VaListImpl&lt;'f&gt;, src: &amp;VaListImpl&lt;'f&gt;);

    /// Loads an argument of type `T` from the `va_list` `ap` and increment the
    /// argument `ap` points to.
    fn va_arg&lt;T: sealed_trait::VaArgSafe&gt;(ap: &amp;mut VaListImpl&lt;'_&gt;) -&gt; T;
}

<span class="boring">}</span></code></pre></pre>
<h2 id="系统调用的封装"><a class="header" href="#系统调用的封装">系统调用的封装</a></h2>
<p>操作系统的系统调用一般出错返回-1, 为了简化对此情况的处理，将这个出错封装到RUST的Result类型，RUST实现了以下机制:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//对系统调用出错的判断
pub trait IsMinusOne {
    fn is_minus_one(&amp;self) -&gt; bool;
}

macro_rules! impl_is_minus_one {
    ($($t:ident)*) =&gt; ($(impl IsMinusOne for $t {
        fn is_minus_one(&amp;self) -&gt; bool {
            *self == -1
        }
    })*)
}

//对所有系统调用可能的返回类型实现了出错判断trait
impl_is_minus_one! { i8 i16 i32 i64 isize }

//对系统调用进行出错处理的封装，将错误转换为Result类型
pub fn cvt&lt;T: IsMinusOne&gt;(t: T) -&gt; crate::io::Result&lt;T&gt; {
    //Error是对操作系统错误的封装
    if t.is_minus_one() { Err(crate::io::Error::last_os_error()) } else { Ok(t) }
}

//对于被中断的系统调用做额外的处理封装
pub fn cvt_r&lt;T, F&gt;(mut f: F) -&gt; crate::io::Result&lt;T&gt;
where
    T: IsMinusOne,
    F: FnMut() -&gt; T,
{
    loop {
        match cvt(f()) {
            //如果返回是调用被中断, 则再次执行系统调用
            Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
            other =&gt; return other,
        }
    }
}

//对系统调用的返回值进行判断，转换为io::Result的结果
pub fn cvt_nz(error: libc::c_int) -&gt; crate::io::Result&lt;()&gt; {
    if error == 0 { Ok(()) } else { Err(crate::io::Error::from_raw_os_error(error)) }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="cstr及cstring代码分析"><a class="header" href="#cstr及cstring代码分析">CStr及CString代码分析</a></h2>
<p>代码路径：library/std/src/ffi/c_str.rs<br />
RUST定义CStr及CString主要的目的就是与C的各种库函数交互。<br />
因此CStr及CString不涉及字符串的迭代器，格式化，加减，分裂，字符查找等等操作。只是负责做String及str与C语言之间的转换及与转换相关及调试相关的若干功能。<br />
之所以设计CString，是因为如果需要保存C语言的字符串，需要用堆内存的方式来完成。同时，传递给C语言的字符串，需要位于堆内存中代码才会比较简单及安全。<br />
一般的处理C语言交互传入的字符串的过程是:首先需要用CStr将字符串进行包装，使得保证后继操作复合RUST的安全规则；如果需要对字符串做保存，那需要用CStr生成一个CString。当然，也可以直接转化为String，要根据具体的情况和需求处理，但仅使用String的方式在某些场景下显然效率不高并且也是不合适的。<br />
如果是需要将RUST的str转换成C语言的字符串，则先转换成CString.</p>
<p>CString及CStr类型结构定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CString {
    // C语言的字符串是一个以0位结尾的字节数组. 通常的，申请的空间大小会大于字符串长度，因此
    // 下面的切片长度不能用于判断字符串长度
    inner: box&lt;[u8]&gt;,
}
pub struct CStr {
    // 此处没有太好的办法，C语言对字符串实际上会存储在一个申请后就固定的字节数组里，然后用指针表示字符串类型
    // 但RUST显然不可能用裸指针来实现，切片类型是最接近的。但要注意C语言中的实际上是个固定的数组
    inner: [c_char],
}
<span class="boring">}</span></code></pre></pre>
<p>CStr主要的需求是对C语言的char*进行封装并定义转换方法，将C语言的字符串安全化。并在需要的时候转化成str或CString类型</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl CStr {
    //主要的创建方法，这个函数接收一个已经由C语言模块传递过来的char *指针，然后创建RUST
    //需要的CStr引用 并返回
    // 调用代码应该保证传入参数的正确性。此函数返回的引用生命周期由调用代码的上下文决定
    // 生命周期的正确性也由调用代码保证。
    pub unsafe fn from_ptr&lt;'a&gt;(ptr: *const c_char) -&gt; &amp;'a CStr {
        //将* const c_char转换成 &amp;[u8]
        unsafe {
            //调用C语言的库函数libc::strlen获得字符串长度，这里实际可以用RUST自行实现
            let len = sys::strlen(ptr);
            let ptr = ptr as *const u8;
            //先创建&amp;[u8], 然后创建Self类型引用
            Self::_from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))
        }
    }

    pub fn from_bytes_until_nul(bytes: &amp;[u8]) -&gt; Result&lt;&amp;CStr, FromBytesUntilNulError&gt; {
        //core库实现了memchr，查找到字符串尾部字节位置
        let nul_pos = memchr::memchr(0, bytes);
        match nul_pos {
            Some(nul_pos) =&gt; {
                // slice仅保留有效的字节.
                let subslice = &amp;bytes[..nul_pos + 1];
                // 见后继的分析
                Ok(unsafe { CStr::from_bytes_with_nul_unchecked(subslice) })
            }
            None =&gt; Err(FromBytesUntilNulError(())),
        }
    }
    //从准备好的[u8]创建CStr的引用并返回
    pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &amp;[u8]) -&gt; &amp;CStr {
        debug_assert!(!bytes.is_empty() &amp;&amp; bytes[bytes.len() - 1] == 0);
        //见后继的分析
        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }
    }

    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &amp;[u8]) -&gt; &amp;Self {
        // 利用裸指针转换，注意这里CStr结构定义没有用#[repr(transparent)]或#[repr(C)]，这里直接做转换的根据感觉有些不足，
        //返回的生命周期要小于bytes，但因为bytes基本上是从一个裸指针转换而来的，所以
        //这里的&amp;Self的生命周期的正确性还是要由调用代码负责
        unsafe { &amp;*(bytes as *const [u8] as *const Self) }
    }

    //将CStr转换成C语言的字符串，需要保证复合C语言字符串的规则
    //此函数可能引发一个潜在问题如下例：
    /// use std::ffi::CString;
    ///
    /// let ptr = CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr();
    /// unsafe {
    ///     // 这里会出现悬垂指针,见后面的解释
    ///     *ptr;
    /// }
    /// ```
    ///
    /// 以上悬垂指针是因为`as_ptr`没有生命周期，因为CString创建的变量又没有变量声明与之绑定，所以其在执行完as_ptr后立即被释放。
    /// 可使用如下的方法
    /// ```no_run
    /// # #![allow(unused_must_use)]
    /// use std::ffi::CString;
    /// 
    /// //声明一个变量，生命周期一般会到作用域的尾部。
    /// let hello = CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;);
    /// let ptr = hello.as_ptr();
    /// unsafe {
    ///     // `ptr` is valid because `hello` is in scope
    ///     *ptr;
    /// }
    /// ```
    pub const fn as_ptr(&amp;self) -&gt; *const c_char {
        self.inner.as_ptr()
    }

    //转换成去掉尾部0的[u8]切片引用
    pub fn to_bytes(&amp;self) -&gt; &amp;[u8] {
        let bytes = self.to_bytes_with_nul();
        // SAFETY: to_bytes_with_nul returns slice with length at least 1
        unsafe { bytes.get_unchecked(..bytes.len() - 1) }
    }

    //转换成[u8]切片引用,尾部仍然有0
    pub fn to_bytes_with_nul(&amp;self) -&gt; &amp;[u8] {
        unsafe { &amp;*(&amp;self.inner as *const [c_char] as *const [u8]) }
    }

    //转换成&amp;str
    pub fn to_str(&amp;self) -&gt; Result&lt;&amp;str, str::Utf8Error&gt; {
        str::from_utf8(self.to_bytes())
    }

    //转换成CString
    pub fn into_c_string(self: Box&lt;CStr&gt;) -&gt; CString {
        //将堆内存从Box取出
        let raw = Box::into_raw(self) as *mut [u8];
        //重新形成Box结构，然后创建CString
        CString { inner: unsafe { Box::from_raw(raw) } }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>CString的相关实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl CString {
    pub fn new&lt;T: Into&lt;Vec&lt;u8&gt;&gt;&gt;(t: T) -&gt; Result&lt;CString, NulError&gt; {
        trait SpecNewImpl {
            fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt;;
        }

        impl&lt;T: Into&lt;Vec&lt;u8&gt;&gt;&gt; SpecNewImpl for T {
            default fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt; {
                let bytes: Vec&lt;u8&gt; = self.into();
                match memchr::memchr(0, &amp;bytes) {
                    Some(i) =&gt; Err(NulError(i, bytes)),
                    None =&gt; Ok(unsafe { CString::_from_vec_unchecked(bytes) }),
                }
            }
        }

        //此函数用来防止多次申请内存
        fn spec_new_impl_bytes(bytes: &amp;[u8]) -&gt; Result&lt;CString, NulError&gt; {
            // 此处checked_add的优化效率最高，bytes中没有0，所以需要加1
            let capacity = bytes.len().checked_add(1).unwrap();

            // 申请堆内存，并将bytes写入堆内存,此处申请可以防止重复申请，但无论成功与否都会申请内存
            let mut buffer = Vec::with_capacity(capacity);
            //此时还没有给buffer的尾部赋0
            buffer.extend(bytes);

            // 看bytes内是否有0值
            match memchr::memchr(0, bytes) {
                //有0，出错了，将buffer在参数返回，由外部代码处理
                Some(i) =&gt; Err(NulError(i, buffer)),
                //无0，生成CString，生成函数中会赋0
                None =&gt; Ok(unsafe { CString::_from_vec_unchecked(buffer) }),
            }
        }

        //可以从[u8]切片生成CString
        impl SpecNewImpl for &amp;'_ [u8] {
            fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt; {
                spec_new_impl_bytes(self)
            }
        }

        //支持从str生成CString
        impl SpecNewImpl for &amp;'_ str {
            fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt; {
                spec_new_impl_bytes(self.as_bytes())
            }
        }

        //支持从可变[u8]生成CString
        impl SpecNewImpl for &amp;'_ mut [u8] {
            fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt; {
                spec_new_impl_bytes(self)
            }
        }

        t.spec_new_impl()
    }

    //从Vec创建CString,实际是从String创建的支持函数
    pub unsafe fn from_vec_unchecked(v: Vec&lt;u8&gt;) -&gt; Self {
        debug_assert!(memchr::memchr(0, &amp;v).is_none());
        unsafe { Self::_from_vec_unchecked(v) }
    }

    //Vec&lt;u8&gt;已经完成安全检查，不会出错
    unsafe fn _from_vec_unchecked(mut v: Vec&lt;u8&gt;) -&gt; Self {
        //以下就是增加尾部的0值
        v.reserve_exact(1);
        v.push(0);
        //将堆内存从Vec结构转移至Box结构
        Self { inner: v.into_boxed_slice() }
    }

    //从C语言字符串创建CString, 此时c语言的字符串应该是前期RUST代码申请的堆内存
    //要规避不是RUST申请的堆内存的情况
    pub unsafe fn from_raw(ptr: *mut c_char) -&gt; CString {
        // ptr应该从CString::into_raw得到的,此方法使用后，可以省略一次内存拷贝
        unsafe {
            //得到字符串长度
            let len = sys::strlen(ptr) + 1; // Including the NUL byte
            //形成正确的切片引用 
            let slice = slice::from_raw_parts_mut(ptr, len as usize);
            //形成CString
            CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }
        }
    }

    pub fn into_raw(self) -&gt; *mut c_char {
        //CString已经包含了0值
        Box::into_raw(self.into_inner()) as *mut c_char
    }

    //转换成String类型
    pub fn into_string(self) -&gt; Result&lt;String, IntoStringError&gt; {
        String::from_utf8(self.into_bytes()).map_err(|e| IntoStringError {
            error: e.utf8_error(),
            inner: unsafe { Self::_from_vec_unchecked(e.into_bytes()) },
        })
    }

    pub fn into_bytes(self) -&gt; Vec&lt;u8&gt; {
        //消费了CString，Box中的堆内存转移到Vec
        let mut vec = self.into_inner().into_vec();
        //删掉尾部的0值
        let _nul = vec.pop();
        debug_assert_eq!(_nul, Some(0u8));
        vec
    }

    pub fn into_bytes_with_nul(self) -&gt; Vec&lt;u8&gt; {
        //不对尾部的0值做处理
        self.into_inner().into_vec()
    }

    //将CString转换为[u8]切片引用
    pub fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        // 删除尾部的0值
        unsafe { self.inner.get_unchecked(..self.inner.len() - 1) }
    }

    //保留尾部的0值
    pub fn as_bytes_with_nul(&amp;self) -&gt; &amp;[u8] {
        &amp;self.inner
    }

    //转换为CStr的引用
    pub fn as_c_str(&amp;self) -&gt; &amp;CStr {
        &amp;*self
    }

    
    pub fn into_boxed_c_str(self) -&gt; Box&lt;CStr&gt; {
        //Box取出堆内存指针，然后转换，再封装入Box，RUST这个实在是麻烦
        unsafe { Box::from_raw(Box::into_raw(self.into_inner()) as *mut CStr) }
    }

    fn into_inner(self) -&gt; Box&lt;[u8]&gt; {
        //将Box取出，如果直接解封装的方式，因为会调用self的drop函数，会再调用内部的Box的drop。
        //用MannuallyDrop来规避是不想再重构了，这个代码的例子不应学习
        //如果有需要inner，那就不应该用Box&lt;[u8]&gt;这种方式来设计
        //这个设计导致必须用下面这种技巧，带来理解上的复杂性
        let this = mem::ManuallyDrop::new(self);
        unsafe { ptr::read(&amp;this.inner) }
    }

    //从Vec生成CString
    pub unsafe fn from_vec_with_nul_unchecked(v: Vec&lt;u8&gt;) -&gt; Self {
        debug_assert!(memchr::memchr(0, &amp;v).unwrap() + 1 == v.len());
        unsafe { Self::_from_vec_with_nul_unchecked(v) }
    }

    //同上，无需再检查0值
    unsafe fn _from_vec_with_nul_unchecked(v: Vec&lt;u8&gt;) -&gt; Self {
        Self { inner: v.into_boxed_slice() }
    }

    //此函数为从String转换为CString准备
    pub fn from_vec_with_nul(v: Vec&lt;u8&gt;) -&gt; Result&lt;Self, FromVecWithNulError&gt; {
        //确定0值的位置
        let nul_pos = memchr::memchr(0, &amp;v);
        match nul_pos {
            //如果0值的位置正确
            Some(nul_pos) if nul_pos + 1 == v.len() =&gt; {
                // 创建CString
                Ok(unsafe { Self::_from_vec_with_nul_unchecked(v) })
            }
            //出错处理
            Some(nul_pos) =&gt; Err(FromVecWithNulError {
                error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),
                bytes: v,
            }),
            None =&gt; Err(FromVecWithNulError {
                error_kind: FromBytesWithNulErrorKind::NotNulTerminated,
                bytes: v,
            }),
        }
    }
}

//drop函数
impl Drop for CString {
    fn drop(&amp;mut self) {
        unsafe {
            //消费了Box，堆内存已经拷贝到栈，然后将C语言的字符串设置为空字符串。
            *self.inner.get_unchecked_mut(0) = 0;
            
        }
    }
}

impl ops::Deref for CString {
    type Target = CStr;

    fn deref(&amp;self) -&gt; &amp;CStr {
        unsafe { CStr::_from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>CString, CStr其他代码略。</p>
<h2 id="代码工程中的一个技巧"><a class="header" href="#代码工程中的一个技巧">代码工程中的一个技巧</a></h2>
<p>在对不同的CPU架构，不同的操作系统进行适配的时候，通常在代码中采用如下的组织方式：</p>
<ol>
<li>有接口定义文件，在C语言中一般用头文件，在RUST中用mod.rs文件，这个文件负责向其他模块提供一致的API访问界面.</li>
<li>每种CPU架构或者每种操作系统各自建立一个目录(模块).</li>
<li>每种CPU架构或者每种操作系统各自实现接口的代码都在此目录下实现.</li>
<li>利用编译参数控制对于特定CPU架构，操作系统仅编译特定目录下的代码.<br />
举例如下：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod common;

cfg_if::cfg_if! {
    if #[cfg(unix)] {
        mod unix;
        pub use self::unix::*;
    } else if #[cfg(windows)] {
        mod windows;
        pub use self::windows::*;
    } else if #[cfg(target_os = &quot;solid_asp3&quot;)] {
        mod solid;
        pub use self::solid::*;
    } else if #[cfg(target_os = &quot;hermit&quot;)] {
        mod hermit;
        pub use self::hermit::*;
    } else if #[cfg(target_os = &quot;wasi&quot;)] {
        mod wasi;
        pub use self::wasi::*;
    } else if #[cfg(target_family = &quot;wasm&quot;)] {
        mod wasm;
        pub use self::wasm::*;
    } else if #[cfg(all(target_vendor = &quot;fortanix&quot;, target_env = &quot;sgx&quot;))] {
        mod sgx;
        pub use self::sgx::*;
    } else {
        mod unsupported;
        pub use self::unsupported::*;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上的mod.rs实现RUST对编译的控制，按照事先的target_os的配置控制了编译的目录。这是RUST的一个优势，C语言需要在Makefile里面来控制编译的目录。
RUST用<code>pub use self::windows::*</code>的语法，将特定的操作系统的模块重导出为 <code>std::sys::*</code>，从而对其他的RUST模块实现了对不同操作系统API接口访问的统一。
类似的设计方式可能会在多种场景下遇到，例如对不同数据库API的适配，对不同3D API的适配等等。</p>
<h2 id="osstring-代码分析"><a class="header" href="#osstring-代码分析">OsString 代码分析</a></h2>
<p>操作系统系统调用采用的字符串类型很可能与C语言不同,单纯只有CStr及CString满足不了需求。按照与CStr及CString类似的实现，RUST也实现了OsStr及OsString。显然，这个模块包括了操作系统相关及操作系统无关的两个部分：
操作系统无关部分代码路径如下：<br />
library/src/std/src/ffi/os_str.rs<br />
操作系统相关部分代码路径如下，(仅列出linux及windows)： 
library/src/std/src/sys/unix/os_str.rs<br />
library/src/std/src/sys/windows/os_str.rs</p>
<p>linux操作系统相关部分的接口类型结构定义： </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct Buf {
    pub inner: Vec&lt;u8&gt;,
}

#[repr(transparent)]
pub struct Slice {
    pub inner: [u8],
}
<span class="boring">}</span></code></pre></pre>
<p>windows操作系统相关部分的接口结构定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Buf {
    pub inner: Wtf8Buf,
}
pub struct Slice {
    pub inner: Wtf8,
}
pub struct Wtf8Buf {
    bytes: Vec&lt;u8&gt;,
}
pub struct Wtf8 {
    bytes: [u8],
}
<span class="boring">}</span></code></pre></pre>
<p>OsString及OsStr的定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OsString {
    inner: Buf,
}

pub struct OsStr {
    inner: Slice,
}
<span class="boring">}</span></code></pre></pre>
<p>OsString及OsStr实际上是两个适配器，每个方法基本上都是做个透传，如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl OsString {
    pub fn new() -&gt; OsString {
        OsString { inner: Buf::from_string(String::new()) }
    }
    
    pub fn into_string(self) -&gt; Result&lt;String, OsString&gt; {
        self.inner.into_string().map_err(|buf| OsString { inner: buf })
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>OsString及OStr在unix上的结构定义与RUST的String及str基本一致，代码略</p>
<h1 id="std的内存管理分析"><a class="header" href="#std的内存管理分析">std的内存管理分析</a></h1>
<p>std库与core库在内存管理RUST提供的机制是统一的。即Allocator trait 与 GlobalAlloc trait。<br />
从std库可以发现RUST为什么将内存管理分成了Allocator及GlobalAlloc两个trait。<br />
GlobalAlloc trait是操作系统无关及操作系统相关的界面接口。GlobalAlloc的主要功能就是对操作系统的系统调用进行封装，并完成RUST的内存类型与操作系统的系统调用的类型转换。<br />
Allocator是RUST自身的内存管理模块，其他的RUST模块如果有内存需求，同过Allocator triat来完成。Allocator使用GlobalAlloc完成对操作系统的使用。</p>
<p>std库用System 作为这两个trait的实现载体，core库中用Global重新实现了Allocator，Global没有实现GlobalAlloc,因为Global需要适配非操作系统情况，具体请参考02-内存一章, System的代码如下：</p>
<p>以下是unix操作系统相关的部分，代码位置：library/std/src/sys/unix/alloc.rs<br />
不同的操作系统，其内存申请的系统调用都不一致，因此对GlobalAlloc的实现也不一致。<br />
类unix的操作系统主要使用了libc的库函数实现操作系统的系统调用。后继还会看到更多的libc中与操作系统交互的代码，分析RUST std库的代码，必须熟练的掌握libc库。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//单元结构体，仅用来作为内存管理的实现载体
pub struct System;

unsafe impl GlobalAlloc for System {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        // 用libc来实现内存申请，这里适配的难点在于对齐的适配，
        // libc的malloc对齐是不能指定的。  
        // 只有在申请的内存对齐小于MIN_ALIGN而且申请的内存大小大于对齐大小时
        // 才能调用libc的malloc做申请.  
        // 对齐的内存申请C程序员不是太长接触
        if layout.align() &lt;= MIN_ALIGN &amp;&amp; layout.align() &lt;= layout.size() {
            libc::malloc(layout.size()) as *mut u8
        } else {
            //见随后的分析
            aligned_malloc(&amp;layout)
        }
    }

    unsafe fn alloc_zeroed(&amp;self, layout: Layout) -&gt; *mut u8 {
        // 一样需要处理对齐
        if layout.align() &lt;= MIN_ALIGN &amp;&amp; layout.align() &lt;= layout.size() {
            libc::calloc(layout.size(), 1) as *mut u8
        } else {
            let ptr = self.alloc(layout);
            //不能用calloc处理时需要清零
            if !ptr.is_null() {
                ptr::write_bytes(ptr, 0, layout.size());
            }
            ptr
        }
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, _layout: Layout) {
        //都使用free做释放
        libc::free(ptr as *mut libc::c_void)
    }

    unsafe fn realloc(&amp;self, ptr: *mut u8, layout: Layout, new_size: usize) -&gt; *mut u8 {
        //对齐处理
        if layout.align() &lt;= MIN_ALIGN &amp;&amp; layout.align() &lt;= new_size {
            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8
        } else {
            //无法对齐时的处理，
            realloc_fallback(self, ptr, layout, new_size)
        }
    }
}

//此函数用于libc的realloc无法支持RUST语义时使用
pub unsafe fn realloc_fallback(
    alloc: &amp;System,
    ptr: *mut u8,
    old_layout: Layout,
    new_size: usize,
) -&gt; *mut u8 {
    // Docs for GlobalAlloc::realloc require this to be valid:
    let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());

    let new_ptr = GlobalAlloc::alloc(alloc, new_layout);
    if !new_ptr.is_null() {
        let size = cmp::min(old_layout.size(), new_size);
        ptr::copy_nonoverlapping(ptr, new_ptr, size);
        GlobalAlloc::dealloc(alloc, ptr, old_layout);
    }
    new_ptr
}
cfg_if::cfg_if! {
    if #[cfg(target_os = &quot;wasi&quot;)] {
        //wasi提供aligned_alloc的支持
        unsafe fn aligned_malloc(layout: &amp;Layout) -&gt; *mut u8 {
            libc::aligned_alloc(layout.align(), layout.size()) as *mut u8
        }
    } else {
        //其他需要用posix_memalign来完成
        unsafe fn aligned_malloc(layout: &amp;Layout) -&gt; *mut u8 {
            let mut out = ptr::null_mut();
            // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.
            // Since these are all powers of 2, we can just use max.
            let align = layout.align().max(crate::mem::size_of::&lt;usize&gt;());
            let ret = libc::posix_memalign(&amp;mut out, align, layout.size());
            if ret != 0 { ptr::null_mut() } else { out as *mut u8 }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST程序需要处理内存对齐，所以调用了一些不常见的libc内存函数。 
以下为操作系统无关部分的内存管理实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl System {
    //具体的内存申请实现，与Global类似，可参考前文的解释
    fn alloc_impl(&amp;self, layout: Layout, zeroed: bool) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        match layout.size() {
            0 =&gt; Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
            size =&gt; unsafe {
                let raw_ptr = if zeroed {
                    //System也实现了GlobalAlloc trait，这与core库中不同，core库中对GlobalAlloc trait中方法的调用是使用了编译器提供了包装。这使得core库即可以适用于用户态也可以适用于内核态。但std库就是在用户态，所以解决方法更直接。
                    GlobalAlloc::alloc_zeroed(self, layout)
                } else {
                    GlobalAlloc::alloc(self, layout)
                };
                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                Ok(NonNull::slice_from_raw_parts(ptr, size))
            },
        }
    }

    //内存不足，需要增加空间的申请操作
    unsafe fn grow_impl(
        &amp;self,
        ptr: NonNull&lt;u8&gt;,
        old_layout: Layout,
        new_layout: Layout,
        zeroed: bool,
    ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        debug_assert!(
            new_layout.size() &gt;= old_layout.size(),
            &quot;`new_layout.size()` must be greater than or equal to `old_layout.size()`&quot;
        );

        match old_layout.size() {
            //旧的空间是0，那相当于申请一个新空间的操作
            0 =&gt; self.alloc_impl(new_layout, zeroed),

            //旧的内存块与新内存块的对齐是一致的
            old_size if old_layout.align() == new_layout.align() =&gt; unsafe {
                //直接调用realloc的逻辑即可，
                let new_size = new_layout.size();

                intrinsics::assume(new_size &gt;= old_layout.size());
                //realloc的逻辑保证旧的内存块的内容被保留
                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);
                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                if zeroed {
                    //旧内存块的内容不变，仅对新内存块处理
                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);
                }
                //形成新的NonNull&lt;[u8]&gt;返回
                Ok(NonNull::slice_from_raw_parts(ptr, new_size))
            },
            
            //旧内存块与新内存块的对齐不一致
            old_size =&gt; unsafe {
                //需要按照新的内存布局参数重新申请一块内存
                let new_ptr = self.alloc_impl(new_layout, zeroed)?;
                //将旧内存块的内容拷贝到新内存
                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);
                //将旧内存块释放掉
                Allocator::deallocate(&amp;self, ptr, old_layout);
                Ok(new_ptr)
            },
        }
    }
}

// 实现Allocator trait, std库后继会使用此trait完成内存管理操作。
unsafe impl Allocator for System {
    //申请内存块
    fn allocate(&amp;self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        self.alloc_impl(layout, false)
    }
    //申请内存块，并将内存块清零
    fn allocate_zeroed(&amp;self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        self.alloc_impl(layout, true)
    }
    //释放内存块
    unsafe fn deallocate(&amp;self, ptr: NonNull&lt;u8&gt;, layout: Layout) {
        if layout.size() != 0 {
            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }
        }
    }
    //增长内存空间
    unsafe fn grow(
        &amp;self,
        ptr: NonNull&lt;u8&gt;,
        old_layout: Layout,
        new_layout: Layout,
    ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        unsafe { self.grow_impl(ptr, old_layout, new_layout, false) }
    }
    //增长内存空间，增长的部分进行清零
    unsafe fn grow_zeroed(
        &amp;self,
        ptr: NonNull&lt;u8&gt;,
        old_layout: Layout,
        new_layout: Layout,
    ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        unsafe { self.grow_impl(ptr, old_layout, new_layout, true) }
    }
    //收缩内存空间，此时必须重新申请内存。
    unsafe fn shrink(
        &amp;self,
        ptr: NonNull&lt;u8&gt;,
        old_layout: Layout,
        new_layout: Layout,
    ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        debug_assert!(
            new_layout.size() &lt;= old_layout.size(),
            &quot;`new_layout.size()` must be smaller than or equal to `old_layout.size()`&quot;
        );
        
        match new_layout.size() {
            // 收缩空间至0, 实际上就是释放内存
            0 =&gt; unsafe {
                Allocator::deallocate(&amp;self, ptr, old_layout);
                //返回一个dangling的指针表示悬垂指针。此处应该用Option&lt;NonNull&lt;[u8]&gt;&gt;返回才符合
                //rust的习惯用法吧，目前的返回代码后继有额外的判断负担
                Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))
            },

            //如果内存对齐相同
            new_size if old_layout.align() == new_layout.align() =&gt; unsafe {
                intrinsics::assume(new_size &lt;= old_layout.size());
                //realloc函数会保留原内存内容
                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);
                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                Ok(NonNull::slice_from_raw_parts(ptr, new_size))
            },

            //对齐不同，必须重新申请内存
            new_size =&gt; unsafe {
                let new_ptr = Allocator::allocate(&amp;self, new_layout)?;
                //将原内存内容拷贝入新内存
                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);
                //释放原内存
                Allocator::deallocate(&amp;self, ptr, old_layout);
                Ok(new_ptr)
            },
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上是std库的通用实现,代码位置：library/std/src/alloc.rs</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="11-智能指针类型(四).html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="13-std库(二)文件描述符及进程管理.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="11-智能指针类型(四).html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="13-std库(二)文件描述符及进程管理.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
