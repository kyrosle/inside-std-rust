<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>std库(四)线程临界区类型 - rust-inside-std-book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="引言.html">引言</a></li><li class="chapter-item expanded affix "><a href="01-RUST库体系概述.html">RUST库体系概述</a></li><li class="chapter-item expanded affix "><a href="02-内存.html">内存</a></li><li class="chapter-item expanded affix "><a href="03-固有函数库及基础类型.html">固有函数库及基础类型</a></li><li class="chapter-item expanded affix "><a href="04-基础Trait.html">基础Trait</a></li><li class="chapter-item expanded affix "><a href="05-Iterator.html">Iterator</a></li><li class="chapter-item expanded affix "><a href="06-基本类型续.html">基本类型续</a></li><li class="chapter-item expanded affix "><a href="07-内部可变性类型.html">内部可变性类型</a></li><li class="chapter-item expanded affix "><a href="08-智能指针类型(一).html">智能指针类型(一)</a></li><li class="chapter-item expanded affix "><a href="09-智能指针类型(二).html">智能指针类型(二)</a></li><li class="chapter-item expanded affix "><a href="10-智能指针类型(三).html">智能指针类型(三)</a></li><li class="chapter-item expanded affix "><a href="11-智能指针类型(四).html">智能指针类型(四)</a></li><li class="chapter-item expanded affix "><a href="12-std库(一)FFI及内存管理.html">std库(一)FFI及内存管理</a></li><li class="chapter-item expanded affix "><a href="13-std库(二)文件描述符及进程管理.html">std库(二)文件描述符及进程管理</a></li><li class="chapter-item expanded affix "><a href="14-std库(三)线程间锁通信.html">std库(三)线程间锁通信</a></li><li class="chapter-item expanded affix "><a href="15-std库(四)线程临界区类型.html" class="active">std库(四)线程临界区类型</a></li><li class="chapter-item expanded affix "><a href="16-std库(五)线程管理.html">std库(五)线程管理</a></li><li class="chapter-item expanded affix "><a href="17-std库(六)mpsc通信.html">std库(六)mpsc通信</a></li><li class="chapter-item expanded affix "><a href="18-std库(七)RUST的RUNTIME.html">std库(七)RUST的RUNTIME</a></li><li class="chapter-item expanded affix "><a href="19-std库(八)RUST文件系统.html">std库(八)RUST文件系统</a></li><li class="chapter-item expanded affix "><a href="20-std库(九)RUST的IO.html">std库(九)RUST的IO</a></li><li class="chapter-item expanded affix "><a href="21-RUST的异步编程.html">RUST的异步编程</a></li><li class="chapter-item expanded affix "><a href="后记.html">后记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-inside-std-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="rust的临界区变量实现"><a class="header" href="#rust的临界区变量实现">RUST的临界区变量实现</a></h2>
<p>代码路径: library/std/src/sync/*.rs</p>
<h3 id="mutext的实现"><a class="header" href="#mutext的实现"><code>Mutex&lt;T&gt;</code>的实现</a></h3>
<p><code>Mutex&lt;T&gt;</code>是最典型的临界区变量。RUST的设计目标是在使用<code>Mutex&lt;T&gt;</code>时代码中不必关注其的跨线程操作的安全性，使用方式与内部可变性类型的使用相类似。这一设计思路实际在<code>RefCell&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>等类型设计上是一脉相承的：</p>
<ol>
<li>设计一个基础类型结构，将要操作的真实类型变量封装在其内，并拥有其所有权，</li>
<li>设计一个借用类型结构，由基础类型结构的某一方法生成，在此方法中完成附加安全操作，如计数增加，加锁等。</li>
<li>借用类型结构实现解引用方法，返回真实类型变量的引用或可变引用，由此可以对真实变类型变量进行访问，修改操作</li>
<li>借用类型结构的drop方法会执行安全逆操作，如减少计数或解锁。</li>
</ol>
<p><code>Mutex&lt;T&gt;</code>的设计如下：</p>
<ol>
<li>基本类型<code>Mutex&lt;T&gt;</code>，负责临界区的数据存储及Mutex锁</li>
<li><code>MutexGuard&lt;'a, T&gt;</code>作为<code>Mutex&lt;T&gt;</code>的借用类型结构, lock()作为借用方法，返回<code>MutexGuard&lt;T&gt;</code>，可以直接对其解引用后获得内部变量的引用/可变引用，随后执行临界区数据操作及读写。生命周期结束后，<code>MutexGuard&lt;T&gt;</code>的drop会解锁操作，从而使得加锁解锁操作实际上代码不必关心。lock()本身完全可以等同于一个borrow()的调用。</li>
<li><code>Mutex&lt;T&gt;</code>本身是一个内部可变型的类型, 实现多处共享且可修改</li>
<li>线程panic时的Poison处理,使得其他语言极少关注的情况在RUST中自然得解。 </li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mutex&lt;T: ?Sized&gt; {
    //临界区的锁
    inner: sys::MovableMutex,
    //标识Mutex在线程panic时处于锁状态
    poison: poison::Flag,
    //临界区数据, Mutex本身是一个内部可变性的类型
    data: UnsafeCell&lt;T&gt;,
}

unsafe impl&lt;T: ?Sized + Send&gt; Send for Mutex&lt;T&gt; {}
unsafe impl&lt;T: ?Sized + Send&gt; Sync for Mutex&lt;T&gt; {}

<span class="boring">}</span></code></pre></pre>
<p>用于<code>Mutex&lt;T&gt;</code>配合的借用封装类型结构<code>MutexGuard</code>如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//用于lock调用后的对原始变量的访问引用。并包含了poison用于在自身生命周期终结的时候
//更新Mutex&lt;T&gt;的Flag
pub struct MutexGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a Mutex&lt;T&gt;,
    poison: poison::Guard,
}

//标识MutexGuard的当前线程panic状态
pub struct Guard {
    panicking: bool,
}

//支持函数, LockResult请参考14-线程间锁通信
pub fn map_result&lt;T, U, F&gt;(result: LockResult&lt;T&gt;, f: F) -&gt; LockResult&lt;U&gt;
where
    F: FnOnce(T) -&gt; U,
{
    match result {
        Ok(t) =&gt; Ok(f(t)),
        Err(PoisonError { guard }) =&gt; Err(PoisonError::new(f(guard))),
    }
}

//MutexGuard创建关联函数
impl&lt;'mutex, T: ?Sized&gt; MutexGuard&lt;'mutex, T&gt; {
    unsafe fn new(lock: &amp;'mutex Mutex&lt;T&gt;) -&gt; LockResult&lt;MutexGuard&lt;'mutex, T&gt;&gt; {
        //如果Mutex&lt;T&gt;的poison为假，即使本线程已经panic，也返回Ok类型
        //因为不是在加锁时遇到panic，所以临界区数据一致性没有受到破坏。
        poison::map_result(lock.poison.borrow(), |guard| MutexGuard { lock, poison: guard })
    }
}

//deref，返回临界区数据的引用
impl&lt;T: ?Sized&gt; Deref for MutexGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        //利用UnsafeCell获得内部可变性
        unsafe { &amp;*self.lock.data.get() }
    }
}

//返回临界区数据的可变引用
impl&lt;T: ?Sized&gt; DerefMut for MutexGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

//drop方法
impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            //更新Mutex&lt;T&gt;的Flag,一般的，如果在上锁的状态下线程panic
            //会导致对所有栈变量做drop调用，从而此drop被调用
            //self.lock.poison被更新为true
            self.lock.poison.done(&amp;self.poison);
            //解锁
            self.lock.inner.raw_unlock();
        }
    }
}

//获取Mutex
pub fn guard_lock&lt;'a, T: ?Sized&gt;(guard: &amp;MutexGuard&lt;'a, T&gt;) -&gt; &amp;'a sys::MovableMutex {
    &amp;guard.lock.inner
}

//获取线程panic状态
pub fn guard_poison&lt;'a, T: ?Sized&gt;(guard: &amp;MutexGuard&lt;'a, T&gt;) -&gt; &amp;'a poison::Flag {
    &amp;guard.lock.poison
}

<span class="boring">}</span></code></pre></pre>
<p>在<code>Mutex&lt;T&gt;</code>结构中，poison导致更新一般在发生panic时，线程drop<code>MutexGuard&lt;T&gt;</code>时进行标志更新。值得说明的时，上锁后线程异常退出是很少被考虑到的安全问题，RUST的标准库则给出了解决方案。</p>
<p><code>Mutex&lt;T&gt;</code>的代码分析如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//只能创建固定尺寸类型的临界区
impl&lt;T&gt; Mutex&lt;T&gt; {
    //对数据创建一个临界区
    pub fn new(t: T) -&gt; Mutex&lt;T&gt; {
        Mutex {
            //创建系统MovableMutex类型
            inner: sys::MovableMutex::new(),
            //poison为false
            poison: poison::Flag::new(),
            //必须用内部可变性类型
            data: UnsafeCell::new(t),
        }
    }
}

impl&lt;T: ?Sized&gt; Mutex&lt;T&gt; {
    // 获取锁，允许阻塞，返回guard结构用于访问临界区数据及处理锁的释放
    pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
        unsafe {
            //先做锁操作
            self.inner.raw_lock();
            //在MutexGuard的new中处理线程panic问题
            MutexGuard::new(self)
        }
    }

    //试图获取锁，不会阻塞
    pub fn try_lock(&amp;self) -&gt; TryLockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
        unsafe {
            if self.inner.try_lock() {
                //上锁成功，生成MutexGuard
                Ok(MutexGuard::new(self)?)
            } else {
                //失败，提示应该阻塞
                Err(TryLockError::WouldBlock)
            }
        }
    }

    //立即解锁，不希望等待guard生命周期终结，
    pub fn unlock(guard: MutexGuard&lt;'_, T&gt;) {
        drop(guard);
    }

    //是否有线程在panic时锁住了临界区
    pub fn is_poisoned(&amp;self) -&gt; bool {
        self.poison.get()
    }

    //消费Mutex&lt;T&gt;,并获取临界区数据
    pub fn into_inner(self) -&gt; LockResult&lt;T&gt;
    where
        T: Sized,
    {
        //获取临界区数据
        let data = self.data.into_inner();
        //根据是否有线程在panic时加锁,
        poison::map_result(self.poison.borrow(), |_| data)
    }

    //获取临界区数据的可变引用，如果已经执行过lock,
    //此处会编译失败
    pub fn get_mut(&amp;mut self) -&gt; LockResult&lt;&amp;mut T&gt; {
        let data = self.data.get_mut();
        poison::map_result(self.poison.borrow(), |_| data)
    }
}

<span class="boring">}</span></code></pre></pre>
<p>RUST的<code>Mutex&lt;T&gt;</code>再一次揭示了RUST标准库对编程员简化编程的努力及一些标准思维及技巧。</p>
<h3 id="condvar实现分析"><a class="header" href="#condvar实现分析"><code>Condvar</code>实现分析</a></h3>
<p>RUST的Condvar是与<code>MutexGuard&lt;'a, T&gt;</code>临界区变量相关联在一起。RUST的Condvar摆脱了其他语言的那些复杂概念与代码形式，使用方式逻辑上非常顺理成章。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//仅仅是对操作系统的Condvar的一个封装
pub struct Condvar {
    inner: sys::Condvar,
}

impl Condvar {
    
    pub fn new() -&gt; Condvar {
        Condvar { inner: sys::Condvar::new() }
    }

    // 等待信号通知，并可能进入阻塞,因为用MutexGuard, 解脱了与Mutex相互关联的复杂概念，
    // 且Mutex一定已经lock，且临界区数据包括在内，使得Condvar更易被理解及使用
    pub fn wait&lt;'a, T&gt;(&amp;self, guard: MutexGuard&lt;'a, T&gt;) -&gt; LockResult&lt;MutexGuard&lt;'a, T&gt;&gt; {
        let poisoned = unsafe {
            //获取关联的imp::Mutex
            let lock = mutex::guard_lock(&amp;guard);
            self.inner.wait(lock);
            //获取Mutex的poison
            mutex::guard_poison(&amp;guard).get()
        };
        if poisoned { Err(PoisonError::new(guard)) } else { Ok(guard) }
    }

    //函数式编程，将对临界区的操作封装在闭包中
    pub fn wait_while&lt;'a, T, F&gt;(
        &amp;self,
        mut guard: MutexGuard&lt;'a, T&gt;,
        mut condition: F,
    ) -&gt; LockResult&lt;MutexGuard&lt;'a, T&gt;&gt;
    where
        F: FnMut(&amp;mut T) -&gt; bool,
    {
        while condition(&amp;mut *guard) {
            guard = self.wait(guard)?;
        }
        Ok(guard)
    }

    // 简化以毫秒计数的超时等待
    pub fn wait_timeout_ms&lt;'a, T&gt;(
        &amp;self,
        guard: MutexGuard&lt;'a, T&gt;,
        ms: u32,
    ) -&gt; LockResult&lt;(MutexGuard&lt;'a, T&gt;, bool)&gt; {
        let res = self.wait_timeout(guard, Duration::from_millis(ms as u64));
        poison::map_result(res, |(a, b)| (a, !b.timed_out()))
    }

    // 超时等待
    pub fn wait_timeout&lt;'a, T&gt;(
        &amp;self,
        guard: MutexGuard&lt;'a, T&gt;,
        dur: Duration,
    ) -&gt; LockResult&lt;(MutexGuard&lt;'a, T&gt;, WaitTimeoutResult)&gt; {
        let (poisoned, result) = unsafe {
            let lock = mutex::guard_lock(&amp;guard);
            let success = self.inner.wait_timeout(lock, dur);
            (mutex::guard_poison(&amp;guard).get(), WaitTimeoutResult(!success))
        };
        if poisoned { Err(PoisonError::new((guard, result))) } else { Ok((guard, result)) }
    }

    //wait_while的超时版本
    pub fn wait_timeout_while&lt;'a, T, F&gt;(
        &amp;self,
        mut guard: MutexGuard&lt;'a, T&gt;,
        dur: Duration,
        mut condition: F,
    ) -&gt; LockResult&lt;(MutexGuard&lt;'a, T&gt;, WaitTimeoutResult)&gt;
    where
        F: FnMut(&amp;mut T) -&gt; bool,
    {
        let start = Instant::now();
        loop {
            if !condition(&amp;mut *guard) {
                return Ok((guard, WaitTimeoutResult(false)));
            }
            let timeout = match dur.checked_sub(start.elapsed()) {
                Some(timeout) =&gt; timeout,
                None =&gt; return Ok((guard, WaitTimeoutResult(true))),
            };
            guard = self.wait_timeout(guard, timeout)?.0;
        }
    }

    //信号通知，唤醒一个线程
    pub fn notify_one(&amp;self) {
        self.inner.notify_one()
    }

    //信号通知，唤醒所有线程
    pub fn notify_all(&amp;self) {
        self.inner.notify_all()
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="rwlockt分析"><a class="header" href="#rwlockt分析"><code>RWLock&lt;T&gt;</code>分析</a></h3>
<p>与<code>Mutex&lt;T&gt;</code>的设计采用了一致的设计思路：</p>
<p>代码分析如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//与Mutex&lt;T&gt;几乎同样的成员
pub struct RwLock&lt;T: ?Sized&gt; {
    inner: sys::MovableRwLock,
    poison: poison::Flag,
    data: UnsafeCell&lt;T&gt;,
}

unsafe impl&lt;T: ?Sized + Send&gt; Send for RwLock&lt;T&gt; {}
unsafe impl&lt;T: ?Sized + Send + Sync&gt; Sync for RwLock&lt;T&gt; {}

//用read锁后的借用封装类型结构
pub struct RwLockReadGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a RwLock&lt;T&gt;,
}

impl&lt;T: ?Sized&gt; !Send for RwLockReadGuard&lt;'_, T&gt; {}

unsafe impl&lt;T: ?Sized + Sync&gt; Sync for RwLockReadGuard&lt;'_, T&gt; {}

//用write锁后的借用封装类型结构
pub struct RwLockWriteGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a RwLock&lt;T&gt;,
    poison: poison::Guard,
}

impl&lt;T: ?Sized&gt; !Send for RwLockWriteGuard&lt;'_, T&gt; {}

unsafe impl&lt;T: ?Sized + Sync&gt; Sync for RwLockWriteGuard&lt;'_, T&gt; {}

impl&lt;T&gt; RwLock&lt;T&gt; {
    pub fn new(t: T) -&gt; RwLock&lt;T&gt; {
        RwLock {
            inner: sys::MovableRwLock::new(),
            poison: poison::Flag::new(),
            data: UnsafeCell::new(t),
        }
    }
}

impl&lt;T: ?Sized&gt; RwLock&lt;T&gt; {
    //读上锁，返回读锁的临界区借用封装
    pub fn read(&amp;self) -&gt; LockResult&lt;RwLockReadGuard&lt;'_, T&gt;&gt; {
        unsafe {
            self.inner.read();
            RwLockReadGuard::new(self)
        }
    }

    //不希望阻塞时做调用
    pub fn try_read(&amp;self) -&gt; TryLockResult&lt;RwLockReadGuard&lt;'_, T&gt;&gt; {
        unsafe {
            if self.inner.try_read() {
                Ok(RwLockReadGuard::new(self)?)
            } else {
                Err(TryLockError::WouldBlock)
            }
        }
    }

    //写锁，返回一个写锁的借用封装
    pub fn write(&amp;self) -&gt; LockResult&lt;RwLockWriteGuard&lt;'_, T&gt;&gt; {
        unsafe {
            self.inner.write();
            RwLockWriteGuard::new(self)
        }
    }

    //不希望阻塞时的写锁调用
    pub fn try_write(&amp;self) -&gt; TryLockResult&lt;RwLockWriteGuard&lt;'_, T&gt;&gt; {
        unsafe {
            if self.inner.try_write() {
                Ok(RwLockWriteGuard::new(self)?)
            } else {
                Err(TryLockError::WouldBlock)
            }
        }
    }

    //是否中毒
    pub fn is_poisoned(&amp;self) -&gt; bool {
        self.poison.get()
    }

    //消费掉锁，此时如果有读锁或写锁，编译器会告警
    pub fn into_inner(self) -&gt; LockResult&lt;T&gt;
    where
        T: Sized,
    {
        let data = self.data.into_inner();
        poison::map_result(self.poison.borrow(), |_| data)
    }

    //此时如果有读锁或写锁，编译器会告警,针对self
    pub fn get_mut(&amp;mut self) -&gt; LockResult&lt;&amp;mut T&gt; {
        let data = self.data.get_mut();
        poison::map_result(self.poison.borrow(), |_| data)
    }
}

// 读锁的借用封装结构
impl&lt;'rwlock, T: ?Sized&gt; RwLockReadGuard&lt;'rwlock, T&gt; {
    unsafe fn new(lock: &amp;'rwlock RwLock&lt;T&gt;) -&gt; LockResult&lt;RwLockReadGuard&lt;'rwlock, T&gt;&gt; {
        poison::map_result(lock.poison.borrow(), |_| RwLockReadGuard { lock })
    }
}

// 写锁的借用封装结构
impl&lt;'rwlock, T: ?Sized&gt; RwLockWriteGuard&lt;'rwlock, T&gt; {
    unsafe fn new(lock: &amp;'rwlock RwLock&lt;T&gt;) -&gt; LockResult&lt;RwLockWriteGuard&lt;'rwlock, T&gt;&gt; {
        poison::map_result(lock.poison.borrow(), |guard| RwLockWriteGuard { lock, poison: guard })
    }
}

impl&lt;T: ?Sized&gt; Deref for RwLockReadGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Deref for RwLockWriteGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; DerefMut for RwLockWriteGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Drop for RwLockReadGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.inner.read_unlock();
        }
    }
}

impl&lt;T: ?Sized&gt; Drop for RwLockWriteGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        self.lock.poison.done(&amp;self.poison);
        unsafe {
            self.lock.inner.write_unlock();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>RwLock&lt;T&gt;</code>与<code>Mutex&lt;T&gt;</code>的代码逻辑基本一致，所以分析基本没有做。</p>
<h3 id="barrier-类型临界变量"><a class="header" href="#barrier-类型临界变量">Barrier 类型临界变量</a></h3>
<p>Barrier建立了一个多个线程同步的等待点，当所有的线程都到达这个点后，每个线程才能恢复执行，否则，就在该点等待。<br />
Barrier的实例：初始化的时候每一个线程负责不同的初始化内容，只有所有线程都完成了初始化之后，才能继续执行，否则会出现错误。此时，可以用Barrier建立同步点，每个线程完成初始化后就阻塞等待在这个点上，当所有线程都完成后，所有线程解除阻塞，继续运行。<br />
也可用于多个线程协同工作，需要设置一个协同点，每个线程在完成一部分工作后需要等在协同点等待其他线程也都完成工作，然后才能继续工作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Barrier {
    //BarrierState临界区数据 
    lock: Mutex&lt;BarrierState&gt;,
    //等待及解除等待
    cvar: Condvar,
    //线程计数
    num_threads: usize,
}

struct BarrierState {
    //等待的线程数量
    count: usize,
    //唤醒标志
    generation_id: usize,
}

//表明线程是否是唤醒其他线程的线程
pub struct BarrierWaitResult(bool);


impl Barrier {
    //指定Barrier能够做多少个线程的同步
    pub fn new(n: usize) -&gt; Barrier {
        Barrier {
            lock: Mutex::new(BarrierState { count: 0, generation_id: 0 }),
            cvar: Condvar::new(),
            num_threads: n,
        }
    }

    //等待在Barrier
    pub fn wait(&amp;self) -&gt; BarrierWaitResult {
        //获取临界区变量
        let mut lock = self.lock.lock().unwrap();
        let local_gen = lock.generation_id;
        //等待线程计数加1
        lock.count += 1;
        //判断是否已经有足够的线程
        if lock.count &lt; self.num_threads {
            //有可能被其他情况唤醒，如收到信号
            //此处用循环来完成此种情况下的再次进入等待
            //判断是否满足等待的条件
            while local_gen == lock.generation_id {
                //进入等待
                lock = self.cvar.wait(lock).unwrap();
                //被唤醒,有可能被信号唤醒
            }
            //线程已经到达数目，返回
            BarrierWaitResult(false)
        } else {
            //线程已经到达规定数目
            lock.count = 0;
            //唤醒标志
            lock.generation_id = lock.generation_id.wrapping_add(1);
            //唤醒所有其他阻塞线程
            self.cvar.notify_all();
            BarrierWaitResult(true)
        }
    }
}

impl BarrierWaitResult {
    //唤醒其他线程的线程
    pub fn is_leader(&amp;self) -&gt; bool {
        self.0
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="once-类型分析"><a class="header" href="#once-类型分析">Once 类型分析</a></h3>
<p>Once是对全局变量的初始化必须在多个线程中(例如，库)竞争执行且只需要执行一次时的需求的方案。<br />
C的pthread库实现了pthread_once来实现这个特性。RUST实现了自己的方案。Once的call_once方法使得可以用闭包的形式初始化全局变量，闭包内的代码不必考虑竞争，由Once确保线程安全且只初始化只被执行一次。<br />
代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Masked = ();

pub struct Once {
    //用一个变量即实现状态，又实现了等待队列的头节点
    //最后两位是Once的状态，前面是* const Waiter的裸指针地址
    //Waiter是4字节对齐，因此地址最后两位为0，
    //这个设计技巧不值得倡导,这里是为了效率考虑 
    state_and_queue: AtomicPtr&lt;Masked&gt;,
    //state_and_queue中包含了一个等待的头节点的裸指针
    _marker: marker::PhantomData&lt;*const Waiter&gt;,
}

//不能自动生成这两个trait
unsafe impl Sync for Once {}
unsafe impl Send for Once {}

impl UnwindSafe for Once {}

impl RefUnwindSafe for Once {}

pub struct OnceState {
    //闭包执行期间出现panic的标识
    poisoned: bool,
    //给初始化闭包使用，用来标识是否中毒，或者已经顺利完成
    set_state_on_drop_to: Cell&lt;*mut Masked&gt;,
}

//所有的静态变量可以使用ONCE_INIT进行赋值
pub const ONCE_INIT: Once = Once::new();

//闭包没有执行
const INCOMPLETE: usize = 0x0;
//闭包执行时线程panic
const POISONED: usize = 0x1;
//闭包正在执行
const RUNNING: usize = 0x2;
//初始化完成
const COMPLETE: usize = 0x3;

// 用来取出最后两位，用来做INCOMPLETE/POISONED/RUNNING/COMPLETE
const STATE_MASK: usize = 0x3;

//用来作为等待的线程队列节点，这些线程都对once做了闭包初始化的调用
#[repr(align(4))] //确保指针的地址的后2位无意义，可以用来作为状态，这是一个不值得推倡的技巧 
struct Waiter {
    //标识自身
    thread: Cell&lt;Option&lt;Thread&gt;&gt;,
    signaled: AtomicBool,
    //next的节点
    next: *const Waiter,
}

// 等待的队列.
struct WaiterQueue&lt;'a&gt; {
    //Once的state_and_queue的引用
    state_and_queue: &amp;'a AtomicPtr&lt;Masked&gt;,
    //初始化闭包的返回结果
    set_state_on_drop_to: *mut Masked,
}

impl Once {
    //一般直接使用ONCE_INIT
    pub const fn new() -&gt; Once {
        Once {
            //初始赋值
            state_and_queue: AtomicPtr::new(ptr::invalid_mut(INCOMPLETE)),
            _marker: marker::PhantomData,
        }
    }

    //例如ONCE_INIT.call_once(|| {}), 在函数体内，可以对全局变量执行初始化，不必考虑
    //线程间安全问题。
    pub fn call_once&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce(),
    {
        // 是否已经完成初始化
        if self.is_completed() {
            return;
        }
        
        //以下将FnOnce()转换为了FnMut(state)
        let mut f = Some(f);
        //需要处理panic情况
        self.call_inner(false, &amp;mut |_| f.take().unwrap()());
    }

    //不理会panic的初始化
    pub fn call_once_force&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce(&amp;OnceState),
    {
        if self.is_completed() {
            return;
        }

        let mut f = Some(f);
        self.call_inner(true, &amp;mut |p| f.take().unwrap()(p));
    }

    pub fn is_completed(&amp;self) -&gt; bool {
        self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE
    }

    fn call_inner(&amp;self, ignore_poisoning: bool, init: &amp;mut dyn FnMut(&amp;OnceState)) {
        let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);
        loop {
            //判断当前状态
            match state_and_queue.addr() {
                //没有等待线程且初始化完毕
                COMPLETE =&gt; break,
                //没有等待线程且已经POISONED，且不能忽视panic做初始化
                POISONED if !ignore_poisoning =&gt; {
                    // Panic to propagate the poison.
                    panic!(&quot;Once instance has previously been poisoned&quot;);
                }
                //没有等待线程，没有初始化，或者已经panic但可以初始化
                POISONED | INCOMPLETE =&gt; {
                    // 将状态转为RUNNING 
                    let exchange_result = self.state_and_queue.compare_exchange(
                        state_and_queue,
                        ptr::invalid_mut(RUNNING),
                        Ordering::Acquire,
                        Ordering::Acquire,
                    );
                    //判断是否出现竞争
                    if let Err(old) = exchange_result {
                        //有竞争者，再次做循环
                        state_and_queue = old;
                        continue;
                    }
                    // 本线程获得初始化权利, 后面这段代码不会有竞争出现
                    // 创建其他线程等待的队列
                    let mut waiter_queue = WaiterQueue {
                        //设置Once的state_and_que为队列头部
                        state_and_queue: &amp;self.state_and_queue,
                        //默认是POISONED
                        set_state_on_drop_to: ptr::invalid_mut(POISONED),
                    };
                    // 设置初始化状态
                    let init_state = OnceState {
                        poisoned: state_and_queue.addr() == POISONED,
                        //默认为COMPLETE
                        set_state_on_drop_to: Cell::new(ptr::invalid_mut(COMPLETE)),
                    };
                    //调用初始化函数
                    init(&amp;init_state);
                    //对等待队列中的状态进行更新, 如果初始化闭包不关心init_state(call_once), 则默认为COMPLETE
                    waiter_queue.set_state_on_drop_to = init_state.set_state_on_drop_to.get();
                    //waiter_queue被释放，调用drop
                    break;
                }
                _ =&gt; {
                    // RUNNING，进入阻塞状态 
                    assert!(state_and_queue.addr() &amp; STATE_MASK == RUNNING);
                    wait(&amp;self.state_and_queue, state_and_queue);
                    //阻塞被唤醒，重新获取新的状态并再次做判断循环
                    state_and_queue = self.state_and_queue.load(Ordering::Acquire);
                }
            }
        }
    }
}

//进入等待队列
fn wait(state_and_queue: &amp;AtomicPtr&lt;Masked&gt;, mut current_state: *mut Masked) {

    loop {
        //在不是初次循环的情况下，初始化结束后的竞争赋值
        //可能导致current_state被更新。
        if current_state.addr() &amp; STATE_MASK != RUNNING {
            return;
        }

        // 针对本线程创建一个等待队列的节点 
        let node = Waiter {
            thread: Cell::new(Some(thread::current())),
            signaled: AtomicBool::new(false),
            //将地址清零后两位后，得到Waiter节点的地址
            //如果是头节点，此处的偏移为0，next即是0
            next: current_state.with_addr(current_state.addr() &amp; !STATE_MASK) as *const Waiter,
        };
        //本身作为下一个节点时的地址
        let me = &amp;node as *const Waiter as *const Masked as *mut Masked;

        //更换当前的state_and_queue，将新创建的node作为队列头
        let exchange_result = state_and_queue.compare_exchange(
            current_state,
            //node的地址与状态做或操作，一个变量即是队列头，又是状态
            me.with_addr(me.addr() | RUNNING),
            Ordering::Release,
            Ordering::Relaxed,
        );
        //判断是否成功
        if let Err(old) = exchange_result {
            //不成功，更新current_state，再次循环
            //此时
            current_state = old;
            //此处node会被drop掉
            continue;
        }
        
        //下面的代码面对一个非常复杂的竞争冲突分析
        //作为一个课题留给读者

        while !node.signaled.load(Ordering::Acquire) {
            //如果没有发信号，则阻塞
            thread::park();
            //阻塞结束后，进入循环再次判断是否信号已经被接收
        }
        break;
    }
}

impl Drop for WaiterQueue&lt;'_&gt; {
    fn drop(&amp;mut self) {
        //更新Once的state_and_queue的值,并获取老值,
        //这个做法对规避竞争有很大的意义
        //即我的孩子我领走。
        let state_and_queue =
            self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);

        // 老值应该只可能是RUNNING状态
        assert_eq!(state_and_queue.addr() &amp; STATE_MASK, RUNNING);

        unsafe {
            //获取等待的队列头地址
            let mut queue =
                state_and_queue.with_addr(state_and_queue.addr() &amp; !STATE_MASK) as *const Waiter;
            while !queue.is_null() {
                //保存下一个节点信息
                let next = (*queue).next;
                //发送信号，唤醒等待的线程
                let thread = (*queue).thread.take().unwrap();
                (*queue).signaled.store(true, Ordering::Release);
                queue = next;
                thread.unpark();
            }
        }
    }
}

//留给初始化闭包函数使用。
impl OnceState {
    pub fn is_poisoned(&amp;self) -&gt; bool {
        self.poisoned
    }

    pub(crate) fn poison(&amp;self) {
        self.set_state_on_drop_to.set(ptr::invalid_mut(POISONED));
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="oncelock类型分析"><a class="header" href="#oncelock类型分析">OnceLock类型分析</a></h3>
<p><code>OnceLock&lt;T&gt;</code>是<code>OnceCell&lt;T&gt;</code>在多线程下的版本，也Once的一个具体的实例。
提供了多线程的情况下对变量做一次性初始化的解决方案。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OnceLock&lt;T&gt; {
    //保证多线程情况下仅做一次初始化
    once: Once,
    // 被仅初始化一次的变量 
    value: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,
    //因为value是MaybeUninit&lt;T&gt;，所以需要PhantomData向编译器提示
    //本结构负责T的释放，以便编译器进行drop check
    _marker: PhantomData&lt;T&gt;,
}

impl&lt;T&gt; OnceLock&lt;T&gt; {
    //创建函数
    pub const fn new() -&gt; OnceLock&lt;T&gt; {
        OnceLock {
            once: Once::new(),
            //获得正确的内存
            value: UnsafeCell::new(MaybeUninit::uninit()),
            _marker: PhantomData,
        }
    }

    //直接获取内部变量的引用
    unsafe fn get_unchecked(&amp;self) -&gt; &amp;T {
        debug_assert!(self.is_initialized());
        //请参考UnsafeCell的内容
        (&amp;*self.value.get()).assume_init_ref()
    }

    //直接获取内部变量的可变引用
    unsafe fn get_unchecked_mut(&amp;mut self) -&gt; &amp;mut T {
        debug_assert!(self.is_initialized());
        (&amp;mut *self.value.get()).assume_init_mut()
    }

    //仅在初始化过后才能返回内部引用
    pub fn get(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.is_initialized() {
            // Safe b/c checked is_initialized
            Some(unsafe { self.get_unchecked() })
        } else {
            None
        }
    }

    //仅在初始化过后才能返回内部变量可变引用
    pub fn get_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        if self.is_initialized() {
            // Safe b/c checked is_initialized and we have a unique access
            Some(unsafe { self.get_unchecked_mut() })
        } else {
            None
        }
    }

    //如果已经初始化，返回内部变量引用，
    //否则，调用f进行初始化，然后返回内部变量引用
    pub fn get_or_init&lt;F&gt;(&amp;self, f: F) -&gt; &amp;T
    where
        F: FnOnce() -&gt; T,
    {
        //Ok::&lt;T,!&gt;(f())将FnOnce()-&gt;T转换成了
        //FnOnce()-&gt;Result&lt;T,!&gt;, 
        //并且只可能返回Ok()的值
        match self.get_or_try_init(|| Ok::&lt;T, !&gt;(f())) {
            Ok(val) =&gt; val,
            //编译器分析出不会返回Err，
        }
    }

    //可能不成功
    pub fn get_or_try_init&lt;F, E&gt;(&amp;self, f: F) -&gt; Result&lt;&amp;T, E&gt;
    where
        F: FnOnce() -&gt; Result&lt;T, E&gt;,
    {
        // 如果已经初始化完成，则返回
        if let Some(value) = self.get() {
            return Ok(value);
        }
        //见后继方法的分析
        self.initialize(f)?;

        debug_assert!(self.is_initialized());

        //再次获得内部变量引用并返回
        Ok(unsafe { self.get_unchecked() })
    }

    //上面方法的支持方法
    fn initialize&lt;F, E&gt;(&amp;self, f: F) -&gt; Result&lt;(), E&gt;
    where
        F: FnOnce() -&gt; Result&lt;T, E&gt;,
    {
        let mut res: Result&lt;(), E&gt; = Ok(());
        let slot = &amp;self.value;

        //利用once实现仅初始化一次
        self.once.call_once_force(|p| {
            match f() {
                Ok(value) =&gt; {
                    //实现对value的赋值
                    unsafe { (&amp;mut *slot.get()).write(value) };
                }
                Err(e) =&gt; {
                    res = Err(e);

                    //设置once状态为POSIONED
                    p.poison();
                }
            }
        });
        res
    }

    //修改内部变量的值,这个方法的编码技巧值得学习
    pub fn set(&amp;self, value: T) -&gt; Result&lt;(), T&gt; {
        //用Some来做是否成功的判断
        let mut value = Some(value);
        //此处仅当赋值成功时才会调用value.take().unwrap()
        self.get_or_init(|| value.take().unwrap());
        match value {
            //成功设置了值
            None =&gt; Ok(()),
            //内部变量已经初始化过了
            Some(value) =&gt; Err(value),
        }
    }


    //对一个Pin&lt;&amp;Self&gt;做初始化
    pub(crate) fn get_or_init_pin&lt;F, G&gt;(self: Pin&lt;&amp;Self&gt;, f: F, g: G) -&gt; Pin&lt;&amp;T&gt;
    where
        F: FnOnce() -&gt; T,
        G: FnOnce(Pin&lt;&amp;mut T&gt;),
    {
        //判断是否初始化完毕
        if let Some(value) = self.get_ref().get() {
            //初始化完毕，创建一个Pin返回
            return unsafe { Pin::new_unchecked(value) };
        }

        let slot = &amp;self.value;

        self.once.call_once_force(|_| {
            let value = f();
            let value: &amp;mut T = unsafe { (&amp;mut *slot.get()).write(value) };
            //初始化成功后，调用回调函数g,完成进一步初始化
            g(unsafe { Pin::new_unchecked(value) });
        });

        //创建Pin返回
        unsafe { Pin::new_unchecked(self.get_ref().get_unchecked()) }
    }

    //消费掉self，返回内部变量
    pub fn into_inner(mut self) -&gt; Option&lt;T&gt; {
        //见后继分析
        self.take()
    }

    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.is_initialized() {
            //重新创建一个Once
            self.once = Once::new();
            //将内部变量读出，并将value设置为默认值
            unsafe { Some((&amp;mut *self.value.get()).assume_init_read()) }
        } else {
            None
        }
    }

    fn is_initialized(&amp;self) -&gt; bool {
        self.once.is_completed()
    }

}
<span class="boring">}</span></code></pre></pre>
<h3 id="lazylock类型分析"><a class="header" href="#lazylock类型分析">LazyLock类型分析</a></h3>
<p><code>LazyLock&lt;T&gt;</code>是<code>Lazy&lt;T&gt;</code>的多线程版本</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//惰性，在解引用时进行初始化
pub struct LazyLock&lt;T, F = fn() -&gt; T&gt; {
    //初始化的目的类型
    cell: OnceLock&lt;T&gt;,
    //保存初始化闭包
    init: Cell&lt;Option&lt;F&gt;&gt;,
}

impl&lt;T, F&gt; LazyLock&lt;T, F&gt; {
    pub const fn new(f: F) -&gt; LazyLock&lt;T, F&gt; {
        LazyLock { cell: OnceLock::new(), init: Cell::new(Some(f)) }
    }
}

impl&lt;T, F: FnOnce() -&gt; T&gt; LazyLock&lt;T, F&gt; {
    //执行初始化
    pub fn force(this: &amp;LazyLock&lt;T, F&gt;) -&gt; &amp;T {
        //利用OnceLock及闭包进行初始化
        this.cell.get_or_init(|| match this.init.take() {
            Some(f) =&gt; f(),
            None =&gt; panic!(&quot;Lazy instance has previously been poisoned&quot;),
        })
    }
}

//在此方法进行初始化
impl&lt;T, F: FnOnce() -&gt; T&gt; Deref for LazyLock&lt;T, F&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        LazyLock::force(self)
    }
}

<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="14-std库(三)线程间锁通信.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="16-std库(五)线程管理.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="14-std库(三)线程间锁通信.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="16-std库(五)线程管理.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
