<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>std库(五)线程管理 - rust-inside-std-book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="引言.html">引言</a></li><li class="chapter-item expanded affix "><a href="01-RUST库体系概述.html">RUST库体系概述</a></li><li class="chapter-item expanded affix "><a href="02-内存.html">内存</a></li><li class="chapter-item expanded affix "><a href="03-固有函数库及基础类型.html">固有函数库及基础类型</a></li><li class="chapter-item expanded affix "><a href="04-基础Trait.html">基础Trait</a></li><li class="chapter-item expanded affix "><a href="05-Iterator.html">Iterator</a></li><li class="chapter-item expanded affix "><a href="06-基本类型续.html">基本类型续</a></li><li class="chapter-item expanded affix "><a href="07-内部可变性类型.html">内部可变性类型</a></li><li class="chapter-item expanded affix "><a href="08-智能指针类型(一).html">智能指针类型(一)</a></li><li class="chapter-item expanded affix "><a href="09-智能指针类型(二).html">智能指针类型(二)</a></li><li class="chapter-item expanded affix "><a href="10-智能指针类型(三).html">智能指针类型(三)</a></li><li class="chapter-item expanded affix "><a href="11-智能指针类型(四).html">智能指针类型(四)</a></li><li class="chapter-item expanded affix "><a href="12-std库(一)FFI及内存管理.html">std库(一)FFI及内存管理</a></li><li class="chapter-item expanded affix "><a href="13-std库(二)文件描述符及进程管理.html">std库(二)文件描述符及进程管理</a></li><li class="chapter-item expanded affix "><a href="14-std库(三)线程间锁通信.html">std库(三)线程间锁通信</a></li><li class="chapter-item expanded affix "><a href="15-std库(四)线程临界区类型.html">std库(四)线程临界区类型</a></li><li class="chapter-item expanded affix "><a href="16-std库(五)线程管理.html" class="active">std库(五)线程管理</a></li><li class="chapter-item expanded affix "><a href="17-std库(六)mpsc通信.html">std库(六)mpsc通信</a></li><li class="chapter-item expanded affix "><a href="18-std库(七)RUST的RUNTIME.html">std库(七)RUST的RUNTIME</a></li><li class="chapter-item expanded affix "><a href="19-std库(八)RUST文件系统.html">std库(八)RUST文件系统</a></li><li class="chapter-item expanded affix "><a href="20-std库(九)RUST的IO.html">std库(九)RUST的IO</a></li><li class="chapter-item expanded affix "><a href="21-RUST的异步编程.html">RUST的异步编程</a></li><li class="chapter-item expanded affix "><a href="后记.html">后记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-inside-std-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="线程管理分析"><a class="header" href="#线程管理分析">线程管理分析</a></h2>
<p>RUST的线程主要由以下几部分组成：</p>
<ol>
<li>线程属性设置，线程创建，join，销毁等,是操作系统系统调用的RUST延伸</li>
<li>线程局部存储, 是操作系统系统调用的RUST延伸</li>
<li>线程运行时及panic管理, 是RUST的异常处理方案一部分</li>
<li>RUST运行时</li>
<li>为在线程中借用环境变量的Scope方案，是RUST语言自身的特性</li>
</ol>
<h3 id="基于操作系统调用封装的底层线程结构"><a class="header" href="#基于操作系统调用封装的底层线程结构">基于操作系统调用封装的底层线程结构</a></h3>
<p>均以linux为例，wasi与linux基本相同</p>
<h4 id="线程类型结构"><a class="header" href="#线程类型结构">线程类型结构</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Thread结构，pthread函数需要用此结构作为参数调用pthread的API
// 这里 id没有象fd那样实现RawFd, OwnedFd, BorrowedFd
pub struct Thread {
    id: libc::pthread_t,
}

// Thread当然应该支持Send 及 Sync
unsafe impl Send for Thread {}
unsafe impl Sync for Thread {}

impl Thread {
    // 熟悉C语言的会发现这个函数很容易理解，基本和C的同类型函数
    // 可以一一映射。大量的libc的调用直接导致用unsafe标记这个函数 
    pub unsafe fn new(stack: usize, p: Box&lt;dyn FnOnce()&gt;) -&gt; io::Result&lt;Thread&gt; {
        //申请一个堆内存存放Box&lt;dyn FnOnce()&gt;, 并解封，将p直接置为申请的堆内存地址
        // p就是线程函数指针
        let p = Box::into_raw(box p);
        //等于pthread_t native = 0;
        let mut native: libc::pthread_t = mem::zeroed();
        let mut attr: libc::pthread_attr_t = mem::zeroed();
        //pthread_attr_init出错是有可能的，此处标准库偷了懒
        assert_eq!(libc::pthread_attr_init(&amp;mut attr), 0);

        //对线程栈进行设置，一般不必设置
        {
            //线程栈不能小于允许最小的栈，实际上最大栈也应该有限制
            let stack_size = cmp::max(stack, min_stack_size(&amp;attr));

            //设置线程栈大小
            match libc::pthread_attr_setstacksize(&amp;mut attr, stack_size) {
                0 =&gt; {}
                n =&gt; {
                    assert_eq!(n, libc::EINVAL);
                    // 仅在参数不是内存页整数倍的情况会执行下面代码,重新调整栈空间,并设置，
                    // 此时的设置不应该再出错
                    let page_size = os::page_size();
                    let stack_size =
                        (stack_size + page_size - 1) &amp; (-(page_size as isize - 1) as usize - 1);
                    assert_eq!(libc::pthread_attr_setstacksize(&amp;mut attr, stack_size), 0);
                }
            };
        }

        //创建线程，thread_start是线程主函数，见后面分析
        //输入的闭包p作为thread_start的参数，attr当前只处理栈大小，成功后native会被赋值
        let ret = libc::pthread_create(&amp;mut native, &amp;attr, thread_start, p as *mut _);
        // attr任务完成，释放其申请的资源，C编程的时候这一步经常被忽略，这也是RUST的一个安全体现
        // 此处RUST认为不会失败 
        assert_eq!(libc::pthread_attr_destroy(&amp;mut attr), 0);

        return if ret != 0 {
            // 失败
            // 重新建立Box以便释放申请的堆内存
            drop(Box::from_raw(p));
            //获取操作系统的错误
            Err(io::Error::from_raw_os_error(ret))
        } else {
            //成功，创建Thread返回
            Ok(Thread { id: native })
        };

        //所有RUST线程的主函数
        extern &quot;C&quot; fn thread_start(main: *mut libc::c_void) -&gt; *mut libc::c_void {
            unsafe {
                // 这个是线程栈保护机制，如果线程出现栈溢出，可以用这个机制探测到， 
                // 这个是C语言编写大的服务器应用如数据库等积累下来的经验
                // 对C来说必要性是很大的，具体的代码分析略
                let _handler = stack_overflow::Handler::new();
                // 先将传入的堆内存重组为Box，然后自动解双层引用消费掉两个Box并运行真正的
                //线程函数 
                Box::from_raw(main as *mut Box&lt;dyn FnOnce()&gt;)();
            }
            //C函数的返回值
            ptr::null_mut()
        }
    }

    pub fn yield_now() {
        //让出CPU
        let ret = unsafe { libc::sched_yield() };
        debug_assert_eq!(ret, 0);
    }

    pub fn set_name(name: &amp;CStr) {
        const PR_SET_NAME: libc::c_int = 15;
        // 更改线程名字，具体的系统调用请参考libc库 
        unsafe {
            libc::prctl(
                PR_SET_NAME,
                name.as_ptr(),
                0 as libc::c_ulong,
                0 as libc::c_ulong,
                0 as libc::c_ulong,
            );
        }
    }

    //线程睡眠,可以认为是glibc的sleep函数的RUST版本
    pub fn sleep(dur: Duration) {
        let mut secs = dur.as_secs();
        let mut nsecs = dur.subsec_nanos() as _;

        unsafe {
            //一次睡不到位就多睡几次, 另外也可能被中途打断，那需要再接着睡，
            // 以下这段代码值得注意，nanosleep让以前简单的调用一次usleep的我深感惭愧
            while secs &gt; 0 || nsecs &gt; 0 {
                //准备C语言时间变量
                let mut ts = libc::timespec {
                    tv_sec: cmp::min(libc::time_t::MAX as u64, secs) as libc::time_t,
                    tv_nsec: nsecs,
                };
                secs -= ts.tv_sec as u64;
                let ts_ptr = &amp;mut ts as *mut _;
                if libc::nanosleep(ts_ptr, ts_ptr) == -1 {
                    assert_eq!(os::errno(), libc::EINTR);
                    //中途被打断的话，ts_ptr会放置还剩余的时间
                    //因此要把时间重新加入，下一次循环再睡
                    //真的是容易被忽视的返回值
                    secs += ts.tv_sec as u64;
                    nsecs = ts.tv_nsec;
                } else {
                    //重新置值
                    nsecs = 0;
                }
            }
        }
    }

    //等待目标线程结束
    pub fn join(self) {
        unsafe {
            let ret = libc::pthread_join(self.id, ptr::null_mut());
            //默认是非join，此处的作用是取消drop导致的默认pthread_detach调用
            mem::forget(self);
            assert!(ret == 0, &quot;failed to join thread: {}&quot;, io::Error::from_raw_os_error(ret));
        }
    }

    pub fn id(&amp;self) -&gt; libc::pthread_t {
        //此处所有权没有转移。一般用于做pthread的系统调用临时使用
        //但不能用这个返回的id调用pthread_detach或者pthread_join及类似功能的pthread
        //C函数
        self.id
    }

    pub fn into_id(self) -&gt; libc::pthread_t {
        let id = self.id;
        //pthread_detach应该由调用此函数的代码负责。
        //所有权已经转移
        mem::forget(self);
        id
    }
}

impl Drop for Thread {
    //主要用于父线程不必等待子线程结束的情况，默认为不等待
    fn drop(&amp;mut self) {
        let ret = unsafe { libc::pthread_detach(self.id) };
        debug_assert_eq!(ret, 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="线程堆栈溢出守卫及运行时"><a class="header" href="#线程堆栈溢出守卫及运行时">线程堆栈溢出守卫及运行时</a></h4>
<p>RUST在操作系统线程的基础上，实现了线程栈内存的溢出检查:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//线程栈溢出守卫
pub mod guard {
    // 内存页大小
    static PAGE_SIZE: AtomicUsize = AtomicUsize::new(0);

    pub type Guard = Range&lt;usize&gt;;

    //获取线程栈栈底(栈溢出)内存地址，
    unsafe fn get_stack_start() -&gt; Option&lt;*mut libc::c_void&gt; {
        //以下实际上可以认为是一个使用了RUST语法的C函数,
        //具体的pthread函数请参观相关手册 
        let mut ret = None;
        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();
        let e = libc::pthread_getattr_np(libc::pthread_self(), &amp;mut attr);
        if e == 0 {
            let mut stackaddr = crate::ptr::null_mut();
            let mut stacksize = 0;
            assert_eq!(libc::pthread_attr_getstack(&amp;attr, &amp;mut stackaddr, &amp;mut stacksize), 0);
            ret = Some(stackaddr);
        }
        if e == 0 {
            assert_eq!(libc::pthread_attr_destroy(&amp;mut attr), 0);
        }
        ret
    }

    // 获取从线程栈栈底(地址小的一侧)找到的第一个内存页对齐的地址
    unsafe fn get_stack_start_aligned() -&gt; Option&lt;*mut libc::c_void&gt; {
        let page_size = PAGE_SIZE.load(Ordering::Relaxed);
        assert!(page_size != 0);
        let stackptr = get_stack_start()?;
        let stackaddr = stackptr.addr();

        // 以下计算从栈底向栈顶方向找到第一个对齐地址
        let remainder = stackaddr % page_size;
        Some(if remainder == 0 {
            stackptr
        } else {
            stackptr.with_addr(stackaddr + page_size - remainder)
        })
    }

    pub unsafe fn init() -&gt; Option&lt;Guard&gt; {
        //获得内存页大小
        let page_size = os::page_size();
        PAGE_SIZE.store(page_size, Ordering::Relaxed);

        {
            // Linux 内核已经做了栈守护，所以使用内核的机制
            let stackptr = get_stack_start_aligned()?;
            let stackaddr = stackptr.addr();
            Some(stackaddr - page_size..stackaddr)
        } 
    }
    //获取当前栈守护地址
    pub unsafe fn current() -&gt; Option&lt;Guard&gt; {
        let mut ret = None;
        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();
        let e = libc::pthread_getattr_np(libc::pthread_self(), &amp;mut attr);
        if e == 0 {
            let mut guardsize = 0;
            assert_eq!(libc::pthread_attr_getguardsize(&amp;attr, &amp;mut guardsize), 0);
            if guardsize == 0 {
                    panic!(&quot;there is no guard page&quot;);
            }
            let mut stackptr = crate::ptr::null_mut::&lt;libc::c_void&gt;();
            let mut size = 0;
            assert_eq!(libc::pthread_attr_getstack(&amp;attr, &amp;mut stackptr, &amp;mut size), 0);

            let stackaddr = stackptr.addr();
            let ret = {
                Some(stackaddr - guardsize..stackaddr + guardsize)
            }
        }
        ret
    }
}

fn min_stack_size(attr: *const libc::pthread_attr_t) -&gt; usize {
    //用动态链接获取库函数
    dlsym!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -&gt; libc::size_t);

    match __pthread_get_minstack.get() {
        None =&gt; libc::PTHREAD_STACK_MIN,
        Some(f) =&gt; unsafe { f(attr) },
    }
}
//以上的代码对于C程序员，是比较容易理解的，因为涉及到大量的pthread的库函数

// 专用于处理栈溢出的结构及实现
pub struct Handler {
    data: *mut libc::c_void,
}

impl Handler {
    pub unsafe fn new() -&gt; Handler {
        //主要用于完成溢出处理函数的栈处置
        make_handler()
    }

    fn null() -&gt; Handler {
        Handler { data: crate::ptr::null_mut() }
    }
}

impl Drop for Handler {
    fn drop(&amp;mut self) {
        unsafe {
            drop_handler(self.data);
        }
    }
}

//stack_overflow模块
mod imp {
    // 对SIGSEGV及SIGBUS的信号处理函数。这两个函数会在线程出现栈溢出时被触发
    unsafe extern &quot;C&quot; fn signal_handler(
        signum: libc::c_int,
        info: *mut libc::siginfo_t,
        _data: *mut libc::c_void,
    ) {
        let guard = thread_info::stack_guard().unwrap_or(0..0);
        let addr = (*info).si_addr() as usize;

        // 判断是否访问了栈保护端的地址，如果是，则输出告警信息
        if guard.start &lt;= addr &amp;&amp; addr &lt; guard.end {
            rtprintpanic!(
                &quot;\nthread '{}' has overflowed its stack\n&quot;,
                thread::current().name().unwrap_or(&quot;&lt;unknown&gt;&quot;)
            );
            rtabort!(&quot;stack overflow&quot;);
        } else {
            // 否则执行默认操作.
            let mut action: sigaction = mem::zeroed();
            action.sa_sigaction = SIG_DFL;
            sigaction(signum, &amp;action, ptr::null_mut());
        }
    }

    static MAIN_ALTSTACK: AtomicPtr&lt;libc::c_void&gt; = AtomicPtr::new(ptr::null_mut());
    static NEED_ALTSTACK: AtomicBool = AtomicBool::new(false);

    //初始化信号函数注册，此函数似乎,在sys::init中被调用
    pub unsafe fn init() {
        let mut action: sigaction = mem::zeroed();
        for &amp;signal in &amp;[SIGSEGV, SIGBUS] {
            sigaction(signal, ptr::null_mut(), &amp;mut action);
            // 配置保护内存访问的信号处理函数.
            if action.sa_sigaction == SIG_DFL {
                action.sa_flags = SA_SIGINFO | SA_ONSTACK;
                action.sa_sigaction = signal_handler as sighandler_t;
                sigaction(signal, &amp;action, ptr::null_mut());
                NEED_ALTSTACK.store(true, Ordering::Relaxed);
            }
        }

        let handler = make_handler();
        MAIN_ALTSTACK.store(handler.data, Ordering::Relaxed);
        mem::forget(handler);
    }

    pub unsafe fn cleanup() {
        drop_handler(MAIN_ALTSTACK.load(Ordering::Relaxed));
    }

    //下面这段函数是将段保护的内存设置成用户态写入会触发缺页中断，从而触发信号
    unsafe fn get_stackp() -&gt; *mut libc::c_void {
        let flags = MAP_PRIVATE | MAP_ANON | libc::MAP_STACK;
        //mmap一段内存作为信号处理函数的栈，额外一个page用作保护
        let stackp =
            mmap(ptr::null_mut(), SIGSTKSZ + page_size(), PROT_READ | PROT_WRITE, flags, -1, 0);
        if stackp == MAP_FAILED {
            panic!(&quot;failed to allocate an alternative stack: {}&quot;, io::Error::last_os_error());
        }
        // 最低的一个page用来作为保护
        let guard_result = libc::mprotect(stackp, page_size(), PROT_NONE);
        if guard_result != 0 {
            panic!(&quot;failed to set up alternative stack guard page: {}&quot;, io::Error::last_os_error());
        }
        // 真正的栈从底部向上一个page开始
        stackp.add(page_size())
    }

    unsafe fn get_stack() -&gt; libc::stack_t {
        libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }
    }

    //用于对每个线程设置线程信号处理的栈
    pub unsafe fn make_handler() -&gt; Handler {
        if !NEED_ALTSTACK.load(Ordering::Relaxed) {
            return Handler::null();
        }
        let mut stack = mem::zeroed();
        sigaltstack(ptr::null(), &amp;mut stack);
        // 设置信号处理函数的栈 
        if stack.ss_flags &amp; SS_DISABLE != 0 {
            //设置用于信号处理的栈
            stack = get_stack();
            // 设置栈，长度为SIGSTKSZ
            sigaltstack(&amp;stack, ptr::null_mut());
            Handler { data: stack.ss_sp as *mut libc::c_void }
        } else {
            Handler::null()
        }
    }

    pub unsafe fn drop_handler(data: *mut libc::c_void) {
        if !data.is_null() {
            let stack = libc::stack_t {
                ss_sp: ptr::null_mut(),
                ss_flags: SS_DISABLE,
                ss_size: SIGSTKSZ,
            };
            //删除信号处理函数专用栈
            sigaltstack(&amp;stack, ptr::null_mut());
            // unmap用于信号处理的内存.
            munmap(data.sub(page_size()), SIGSTKSZ + page_size());
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<h4 id="线程局部变量类型"><a class="header" href="#线程局部变量类型">线程局部变量类型</a></h4>
<p>线程的本地全局变量Thread Local Key的实现。线程的本地存储解决一类问题如下：
在线程代码中，有时希望多个线程共享同一个变量名的全局变量，以简化编码。但希望这个变量在不同的线程有各自的拷贝，彼此不影响。典型的例子就是前文的线程栈guard空间。如果每个线程都共享同一个变量名，那代码会少很多啰嗦。
具体的代码分析如下:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//pthread_key_t请参考libc的pthread编程手册
pub type Key = libc::pthread_key_t;

//dtor用于对创建的key做释放操作, 返回的Key可以被进程中的线程共享使用
pub unsafe fn create(dtor: Option&lt;unsafe extern &quot;C&quot; fn(*mut u8)&gt;) -&gt; Key {
    let mut key = 0;
    assert_eq!(libc::pthread_key_create(&amp;mut key, mem::transmute(dtor)), 0);
    key
}

// 各线程可以将key设置成自己需要的内存块，这个内存块的所有权属于Key，
// 这是个代码规定，编译器不知道，所以安全上需要程序员负责
pub unsafe fn set(key: Key, value: *mut u8) {
    let r = libc::pthread_setspecific(key, value as *mut _);
    debug_assert_eq!(r, 0);
}

// 用key将内存块获得，实际上是获得一个引用
pub unsafe fn get(key: Key) -&gt; *mut u8 {
    libc::pthread_getspecific(key) as *mut u8
}

// 删除掉key，需要所有线程都删除，调用此函数会导致调用内存块的dtor函数，也即drop
pub unsafe fn destroy(key: Key) {
    let r = libc::pthread_key_delete(key);
    debug_assert_eq!(r, 0);
}

<span class="boring">}</span></code></pre></pre>
<h3 id="标准库线程支持层代码分析"><a class="header" href="#标准库线程支持层代码分析">标准库线程支持层代码分析</a></h3>
<p>代码路径：library/std/src/sys_common/thread.rs<br />
library/std/src/sys_common/thread_local.rs
library/std/src/sys_common/thread_info.rs</p>
<p>在操作系统的线程概念与RUST作为API提供的线程之间的一层代码。主要处理一些RUST的语法导致的一些需要额外在操作系统的线程结构做一些包装的基础层。</p>
<p>对Thread Local Key做类型封装，以屏蔽不同操作系统除API外的差异。<br />
代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//适用与作为静态变量的Thread Local Key结构
pub struct StaticKey {
    /// 仅仅是一个数值，为0的时候代表此时无意义
    key: AtomicUsize,
    ///对key的析构函数 
    dtor: Option&lt;unsafe extern &quot;C&quot; fn(*mut u8)&gt;,
}

//一般作为StaticKey的初始化赋值
pub const INIT: StaticKey = StaticKey::new(None);

impl StaticKey {
    pub const fn new(dtor: Option&lt;unsafe extern &quot;C&quot; fn(*mut u8)&gt;) -&gt; StaticKey {
        //key为0，代表此时没有创建thread local key
        StaticKey { key: atomic::AtomicUsize::new(0), dtor }
    }

    //如果没有创建thread local key, 此方法会创建一个
    pub unsafe fn get(&amp;self) -&gt; *mut u8 {
        //获取key的指针
        //调用self.key会在无thread local key时创建一个
        imp::get(self.key())
    }

    //如果没有创建thread local key, 此方法会创建一个
    pub unsafe fn set(&amp;self, val: *mut u8) {
        imp::set(self.key(), val)
    }

    //获得thread local key的key值
    unsafe fn key(&amp;self) -&gt; imp::Key {
        match self.key.load(Ordering::Relaxed) {
            //如果为0，表示thread local key没有创建，需要创建一个
            0 =&gt; self.lazy_init() as imp::Key,
            //不为0，则返回key
            n =&gt; n as imp::Key,
        }
    }

    //创建一个thread local key
    unsafe fn lazy_init(&amp;self) -&gt; usize {
        // 为特殊的操作系统准备
        if imp::requires_synchronized_create() {
            // 需要加锁保护，因为保护静态变量，所以要使用StaticMutex
            // INIT_LOCK所有线程共享
            static INIT_LOCK: StaticMutex = StaticMutex::new();
            let _guard = INIT_LOCK.lock();
            let mut key = self.key.load(Ordering::SeqCst);
            if key == 0 {
                //创建Key
                key = imp::create(self.dtor) as usize;
                self.key.store(key, Ordering::SeqCst);
            }
            rtassert!(key != 0);
            return key;
            //_guard生命周期结束会释放INIT_LOCK
        }

        //unix系统有可能分配为0的thread local key
        let key1 = imp::create(self.dtor);
        let key = if key1 != 0 {
            key1
        } else {
            //如果是0，需要重新再申请一个新的key
            let key2 = imp::create(self.dtor);
            imp::destroy(key1);
            key2
        };
        rtassert!(key != 0);
        match self.key.compare_exchange(0, key as usize, Ordering::SeqCst, Ordering::SeqCst) {
            //这里也作为方法的返回
            Ok(_) =&gt; key as usize,
            // 如果有其他的值，那就用那个值， 
            Err(n) =&gt; {
                imp::destroy(key);
                n
            }
        }
    }
}

//非静态变量的Thread Local Key
pub struct Key {
    key: imp::Key,
}

impl Key {
    // 创建一个thread local key
    pub fn new(dtor: Option&lt;unsafe extern &quot;C&quot; fn(*mut u8)&gt;) -&gt; Key {
        Key { key: unsafe { imp::create(dtor) } }
    }

    // 获取key相关的内存，可能为空，
    pub fn get(&amp;self) -&gt; *mut u8 {
        unsafe { imp::get(self.key) }
    }

    //设置key相关的内存
    pub fn set(&amp;self, val: *mut u8) {
        unsafe { imp::set(self.key, val) }
    }
}

impl Drop for Key {
    fn drop(&amp;mut self) {
        // Right now Windows doesn't support TLS key destruction, but this also
        // isn't used anywhere other than tests, so just leak the TLS key.
        // unsafe { imp::destroy(self.key) }
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="标准库线程局部变量外部接口thread-local"><a class="header" href="#标准库线程局部变量外部接口thread-local">标准库线程局部变量外部接口(Thread Local)</a></h3>
<p>操作系统的Thread Local Key使用起来明显非常繁琐，且很容易出错。RUST标准库对其进行了符合<code>rust</code>的类型封装。这一类型需要完成的工作如下：</p>
<ol>
<li>对所有的Thread Local Key存放的真正的数据类型需要声明key时做定义。</li>
<li>向使用者屏蔽key的创建及销毁过程，key与真实数据的捆绑与获取过程，使得key的使用类似于通用类型结构的使用。</li>
</ol>
<p>RUST采用了宏及数据类型相结合的方案，下面的代码说明了RUST的local key的使用。</p>
<pre><pre class="playground"><code class="language-rust"> use std::cell::RefCell;
 thread_local! {
     pub static FOO: RefCell&lt;u32&gt; = RefCell::new(1);

     static BAR: RefCell&lt;f32&gt; = RefCell::new(1.0);
 }
 fn main() {FOO.with(|f|{*f.borrow_mut() = 2})}</code></pre></pre>
<p>以上的<code>thread_local</code>将一个普通的变量定义转换为Thread Local Key的变量. 并且可以在随后的with方法内可以正常的的使用该普通变量。用这种方法，RUST使得Thread Local Key的变量使用与普通变量基本上做到了相一致。 (其他语言多用set(),get()方法完成Thread local的操作，RUST采用了更近一步的设计)<br />
具体的代码实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//LocalKey只能用于静态变量
pub struct LocalKey&lt;T: 'static&gt; {
    //只能用于静态变量
    //inner是一个支持泛型的函数类型
    inner: unsafe fn(Option&lt;&amp;mut Option&lt;T&gt;&gt;) -&gt; Option&lt;&amp;'static T&gt;,
}

pub struct AccessError;

impl Error for AccessError {}

impl&lt;T: 'static&gt; LocalKey&lt;T&gt; {
    // 这里仅仅做一个内存占位
    pub const unsafe fn new(
        inner: unsafe fn(Option&lt;&amp;mut Option&lt;T&gt;&gt;) -&gt; Option&lt;&amp;'static T&gt;,
    ) -&gt; LocalKey&lt;T&gt; {
        LocalKey { inner }
    }

    //所有的Thread Local的操作都在witch参数的闭包中，
    // with会将Thread Local的可变引用输入闭包的参数
    pub fn with&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R
    where
        F: FnOnce(&amp;T) -&gt; R,
    {
        self.try_with(f).expect(
            &quot;cannot access a Thread Local Storage value \
             during or after destruction&quot;,
        )
    }

    pub fn try_with&lt;F, R&gt;(&amp;'static self, f: F) -&gt; Result&lt;R, AccessError&gt;
    where
        F: FnOnce(&amp;T) -&gt; R,
    {
        unsafe {
            //获取Thread Local内存指针后，调用闭包
            let thread_local = (self.inner)(None).ok_or(AccessError)?;
            Ok(f(thread_local))
        }
    }

    //对Thread Local做初始化，然后再执行操作
    fn initialize_with&lt;F, R&gt;(&amp;'static self, init: T, f: F) -&gt; R
    where
        F: FnOnce(Option&lt;T&gt;, &amp;T) -&gt; R,
    {
        unsafe {
            let mut init = Some(init);
            let reference = (self.inner)(Some(&amp;mut init)).expect(
                &quot;cannot access a Thread Local Storage value \
                 during or after destruction&quot;,
            );
            f(init, reference)
        }
    }
}

//LocalKey通常会与内部可变性变量配合,设计方法来简化使用者的代码
impl&lt;T: 'static&gt; LocalKey&lt;Cell&lt;T&gt;&gt; {
    //对内部可变性变量赋值
    pub fn set(&amp;'static self, value: T) {
        self.initialize_with(Cell::new(value), |value, cell| {
            if let Some(value) = value {
                // value输入的Cell变量参数，cell是Thread Local的引用
                // 对cell做出更新,并消费掉value.
                cell.set(value.into_inner());
            }
        });
    }

    //只能在T实现Copy trait的情况下支持，否则会出现
    //双份所有权
    pub fn get(&amp;'static self) -&gt; T
    where
        T: Copy,
    {
        self.with(|cell| cell.get())
    }

    //获取Thread Local的变量所有权，并将Thread Local置为默认
    pub fn take(&amp;'static self) -&gt; T
    where
        T: Default,
    {
        self.with(|cell| cell.take())
    }

    //替换
    pub fn replace(&amp;'static self, value: T) -&gt; T {
        self.with(|cell| cell.replace(value))
    }
}

//提供Thread Local是内部可变性的基础
impl&lt;T: 'static&gt; LocalKey&lt;RefCell&lt;T&gt;&gt; {
    //borrow的对应简化
    pub fn with_borrow&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R
    where
        F: FnOnce(&amp;T) -&gt; R,
    {
        self.with(|cell| f(&amp;cell.borrow()))
    }

    //borrow_mut的对应简化
    pub fn with_borrow_mut&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R
    where
        F: FnOnce(&amp;mut T) -&gt; R,
    {
        self.with(|cell| f(&amp;mut cell.borrow_mut()))
    }

    //修改值
    pub fn set(&amp;'static self, value: T) {
        self.initialize_with(RefCell::new(value), |value, cell| {
            if let Some(value) = value {
                *cell.borrow_mut() = value.into_inner();
            }
        });
    }

    //获取所有权
    pub fn take(&amp;'static self) -&gt; T
    where
        T: Default,
    {
        self.with(|cell| cell.take())
    }

    //替换
    pub fn replace(&amp;'static self, value: T) -&gt; T {
        self.with(|cell| cell.replace(value))
    }
}

/// 惰性初始化.
mod lazy {
    use crate::cell::UnsafeCell;
    use crate::hint;
    use crate::mem;

    pub struct LazyKeyInner&lt;T&gt; {
        //None作为未初始化的标志
        inner: UnsafeCell&lt;Option&lt;T&gt;&gt;,
    }

    impl&lt;T&gt; LazyKeyInner&lt;T&gt; {
        //new一个未初始化变量
        pub const fn new() -&gt; LazyKeyInner&lt;T&gt; {
            LazyKeyInner { inner: UnsafeCell::new(None) }
        }

        pub unsafe fn get(&amp;self) -&gt; Option&lt;&amp;'static T&gt; {
            // 返回内部变量的引用
            unsafe { (*self.inner.get()).as_ref() }
        }

        // 真正的初始化
        pub unsafe fn initialize&lt;F: FnOnce() -&gt; T&gt;(&amp;self, init: F) -&gt; &amp;'static T {
            let value = init();
            let ptr = self.inner.get();

            // 如果用*ptr = Some(value)，会导致编译器对上一个变量做drop处理,对Thread Local
            // 的drop实际上有些复杂，所以此处用一个replace
            unsafe {
                let _ = mem::replace(&amp;mut *ptr, Some(value));
            }

            unsafe {
                // 返回Some内变量的引用.
                match *ptr {
                    Some(ref x) =&gt; x,
                    None =&gt; hint::unreachable_unchecked(),
                }
            }
        }

        //take语义
        pub unsafe fn take(&amp;mut self) -&gt; Option&lt;T&gt; {
            unsafe { (*self.inner.get()).take() }
        }
    }
}

//利用llvm的Thread Local方案，不直接使用操作系统系统调用的thread local key
pub mod fast {
    use super::lazy::LazyKeyInner;
    use crate::cell::Cell;
    use crate::fmt;
    use crate::mem;
    use crate::sys::thread_local_dtor::register_dtor;

    #[derive(Copy, Clone)]
    enum DtorState {
        //没有初始化
        Unregistered,
        //已经初始化完成
        Registered,
        //Local Key已经被destroy
        RunningOrHasRun,
    }

    pub struct Key&lt;T&gt; {
        //  放置key存储的变量, None表示变量没有初始化。与dtor_state配合完成对
        //  Key的状态判断
        inner: LazyKeyInner&lt;T&gt;,

        // Local Key的destroy函数状态 
        dtor_state: Cell&lt;DtorState&gt;,
    }


    impl&lt;T&gt; Key&lt;T&gt; {
        pub const fn new() -&gt; Key&lt;T&gt; {
            //实际做内存占位
            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }
        }

        // 证明仍然使用操作系统的thread local key的destory机制 
        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern &quot;C&quot; fn(*mut u8)) {
            unsafe {
                register_dtor(a, dtor);
            }
        }

        pub unsafe fn get&lt;F: FnOnce() -&gt; T&gt;(&amp;self, init: F) -&gt; Option&lt;&amp;'static T&gt; {
            // 如果已经初始化，则取用值
            // 如果没有初始化，则进行初始化
            unsafe {
                match self.inner.get() {
                    Some(val) =&gt; Some(val),
                    None =&gt; self.try_initialize(init),
                }
            }
        }

        #[inline(never)]
        unsafe fn try_initialize&lt;F: FnOnce() -&gt; T&gt;(&amp;self, init: F) -&gt; Option&lt;&amp;'static T&gt; {
            if !mem::needs_drop::&lt;T&gt;() || unsafe { self.try_register_dtor() } {
                // 只用变量不需要drop，或者注册destroy函数成功的情况下才做初始化.
                Some(unsafe { self.inner.initialize(init) })
            } else {
                None
            }
        }

        unsafe fn try_register_dtor(&amp;self) -&gt; bool {
            match self.dtor_state.get() {
                DtorState::Unregistered =&gt; {
                    // 注册destroy函数
                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::&lt;T&gt;) };
                    self.dtor_state.set(DtorState::Registered);
                    true
                }
                DtorState::Registered =&gt; {
                    // 被递归初始化
                    true
                }
                DtorState::RunningOrHasRun =&gt; false,
            }
        }
    }

    unsafe extern &quot;C&quot; fn destroy_value&lt;T&gt;(ptr: *mut u8) {
        let ptr = ptr as *mut Key&lt;T&gt;;

        unsafe {
            //将变量所有权获得
            let value = (*ptr).inner.take();
            //设置destroy状态
            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);
            //对变量做drop
            drop(value);
        }
    }
}

//利用操作系统的StaticKey
pub mod os {
    use super::lazy::LazyKeyInner;
    use crate::cell::Cell;
    use crate::fmt;
    use crate::marker;
    use crate::ptr;
    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;

    pub struct Key&lt;T&gt; {
        // 操作系统的静态Key.
        os: OsStaticKey,
        //指示本结构有一个Cell&lt;T&gt;的所有权
        marker: marker::PhantomData&lt;Cell&lt;T&gt;&gt;,
    }

    unsafe impl&lt;T&gt; Sync for Key&lt;T&gt; {}

    struct Value&lt;T: 'static&gt; {
        inner: LazyKeyInner&lt;T&gt;,
        key: &amp;'static Key&lt;T&gt;,
    }

    impl&lt;T: 'static&gt; Key&lt;T&gt; {
        pub const fn new() -&gt; Key&lt;T&gt; {
            //创建一个StaticKey
            Key { os: OsStaticKey::new(Some(destroy_value::&lt;T&gt;)), marker: marker::PhantomData }
        }

        pub unsafe fn get(&amp;'static self, init: impl FnOnce() -&gt; T) -&gt; Option&lt;&amp;'static T&gt; {
            // thread local key的get操作.
            let ptr = unsafe { self.os.get() as *mut Value&lt;T&gt; };
            if ptr.addr() &gt; 1 {
                //有值
                if let Some(ref value) = unsafe { (*ptr).inner.get() } {
                    return Some(value);
                }
            }
            // 进行初始化.
            unsafe { self.try_initialize(init) }
        }

        unsafe fn try_initialize(&amp;'static self, init: impl FnOnce() -&gt; T) -&gt; Option&lt;&amp;'static T&gt; {
            let ptr = unsafe { self.os.get() as *mut Value&lt;T&gt; };
            if ptr.addr() == 1 {
                // 被destroy了
                return None;
            }

            let ptr = if ptr.is_null() {
                // 从堆上申请内存.
                let ptr: Box&lt;Value&lt;T&gt;&gt; = box Value { inner: LazyKeyInner::new(), key: self };
                //获取申请的堆内存地址
                let ptr = Box::into_raw(ptr);
                // 将地址与操作系统的key相关联
                unsafe {
                    self.os.set(ptr as *mut u8);
                }
                ptr
            } else {
                // 递归初始化，返回已有的ptr 
                ptr
            };

            // 初始化变量.
            unsafe { Some((*ptr).inner.initialize(init)) }
        }
    }

    unsafe extern &quot;C&quot; fn destroy_value&lt;T: 'static&gt;(ptr: *mut u8) {
        unsafe {
            //恢复Box以便释放堆内存
            let ptr = Box::from_raw(ptr as *mut Value&lt;T&gt;);
            let key = ptr.key;
            //将thread local key设置为1
            key.os.set(ptr::invalid_mut(1));
            //释放Box
            drop(ptr);
            // key可以重新用于与新的内存相关
            key.os.set(ptr::null_mut());
        }
    }
}
pub use self::local::fast::Key as __FastLocalKeyInner;
pub use self::local::os::Key as __OsLocalKeyInner;

// Thread Local声明宏
macro_rules! thread_local {
    // empty (base case for the recursion)
    () =&gt; {};

    // init 是一个const 修饰的block
    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }; $($rest:tt)*) =&gt; (
        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);
        $crate::thread_local!($($rest)*);
    );

    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }) =&gt; (
        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);
    );

    //  init不是block
    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) =&gt; (
        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);
        $crate::thread_local!($($rest)*);
    );

    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) =&gt; (
        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);
    );
}

macro_rules! __thread_local_inner {
    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) =&gt; {
        //定义了一个LocalKey的变量
        $(#[$attr])* $vis const $name: $crate::thread::LocalKey&lt;$t&gt; =
            $crate::__thread_local_inner!(@key $t, $($init)*);
    }
    //对const init的处理
    (@key $t:ty, const $init:expr) =&gt; {{
        //LocalKey的创建函数
        unsafe fn __getit(
            _init: $crate::option::Option&lt;&amp;mut $crate::option::Option&lt;$t&gt;&gt;,
        ) -&gt; $crate::option::Option&lt;&amp;'static $t&gt; {
            //不可变变量定义
            const INIT_EXPR: $t = $init;

            {
                #[thread_local]
                //静态全局变量, 应用llvm的Thread Local Storage, 需要操作系统支持
                static mut VAL: $t = INIT_EXPR;

                // 判断是否需要有drop函数
                if !$crate::mem::needs_drop::&lt;$t&gt;() {
                    //如果不需要drop，返回VAL的引用即可
                    unsafe {
                        return $crate::option::Option::Some(&amp;VAL)
                    }
                }

                // 0 == dtor not registered
                // 1 == dtor registered, dtor not run
                // 2 == dtor registered and is running or has run
                #[thread_local]
                //释放函数注册状态
                static mut STATE: $crate::primitive::u8 = 0;

                //释放函数
                unsafe extern &quot;C&quot; fn destroy(ptr: *mut $crate::primitive::u8) {
                    let ptr = ptr as *mut $t;

                    unsafe {
                        $crate::debug_assert_eq!(STATE, 1);
                        STATE = 2;
                        $crate::ptr::drop_in_place(ptr);
                    }
                }

                unsafe {
                    match STATE {
                        // 0 == 需要注册释放函数.
                        0 =&gt; {
                            //fast::Key::register_dtor，见下文分析
                            $crate::thread::__FastLocalKeyInner::&lt;$t&gt;::register_dtor(
                                $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,
                                destroy,
                            );
                            STATE = 1;
                            $crate::option::Option::Some(&amp;VAL)
                        }
                        // 1 == 释放函数已经注册，直接返回Key
                        1 =&gt; $crate::option::Option::Some(&amp;VAL),
                        // 释放函数已经运行，返回.
                        _ =&gt; $crate::option::Option::None,
                    }
                }
            }
        }

        unsafe {
            //生成LocalKey
            $crate::thread::LocalKey::new(__getit)
        }
    }};

    // 非const的init的处理
    (@key $t:ty, $init:expr) =&gt; {
        {
            fn __init() -&gt; $t { $init }

            //LocalKey的创建函数
            unsafe fn __getit(
                init: $crate::option::Option&lt;&amp;mut $crate::option::Option&lt;$t&gt;&gt;,
            ) -&gt; $crate::option::Option&lt;&amp;'static $t&gt; {
                //利用llvm编译器属性定义变量为thread local变量
                #[thread_local]
                static __KEY: $crate::thread::__FastLocalKeyInner&lt;$t&gt; =
                    $crate::thread::__FastLocalKeyInner::new();


                //初始化 
                unsafe {
                    __KEY.get(move || {
                        if let $crate::option::Option::Some(init) = init {
                            if let $crate::option::Option::Some(value) = init.take() {
                                return value;
                            } else if $crate::cfg!(debug_assertions) {
                                $crate::unreachable!(&quot;missing default value&quot;);
                            }
                        }
                        __init()
                    })
                }
            }

            unsafe {
                $crate::thread::LocalKey::new(__getit)
            }
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Thread Local的RUST标准库内容颇为复杂，但提供了非常方便的对外使用。</p>
<h3 id="thread-info-分析"><a class="header" href="#thread-info-分析">Thread Info 分析</a></h3>
<p>Thead Info利用Thread Local存储一些Thread的信息。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ThreadInfo {
    stack_guard: Option&lt;Guard&gt;,
    thread: Thread,
}

thread_local! { static THREAD_INFO: RefCell&lt;Option&lt;ThreadInfo&gt;&gt; = const { RefCell::new(None) } }

impl ThreadInfo {
    fn with&lt;R, F&gt;(f: F) -&gt; Option&lt;R&gt;
    where
        F: FnOnce(&amp;mut ThreadInfo) -&gt; R,
    {
        THREAD_INFO
            .try_with(move |thread_info| {
                let mut thread_info = thread_info.borrow_mut();
                let thread_info = thread_info.get_or_insert_with(|| ThreadInfo {
                    stack_guard: None,
                    thread: Thread::new(None),
                });
                f(thread_info)
            })
            .ok()
    }
}

pub fn current_thread() -&gt; Option&lt;Thread&gt; {
    ThreadInfo::with(|info| info.thread.clone())
}

pub fn stack_guard() -&gt; Option&lt;Guard&gt; {
    ThreadInfo::with(|info| info.stack_guard.clone()).and_then(|o| o)
}

pub fn set(stack_guard: Option&lt;Guard&gt;, thread: Thread) {
    THREAD_INFO.with(move |thread_info| {
        let mut thread_info = thread_info.borrow_mut();
        rtassert!(thread_info.is_none());
        *thread_info = Some(ThreadInfo { stack_guard, thread });
    });
}

<span class="boring">}</span></code></pre></pre>
<h3 id="标准库线程外部接口分析"><a class="header" href="#标准库线程外部接口分析">标准库线程外部接口分析</a></h3>
<p>RUST在操作系统的线程支持之上，实现了语言自身的线程概念，首要的，就是为每一个线程分配一个ID做标识。
即ThreadId, 代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//用一个非零的64位整数
pub struct ThreadId(NonZeroU64);

impl ThreadId {
    // 分配一个新的线程ID 
    fn new() -&gt; ThreadId {
        // 线程ID是一个全局静态变量，且是一个临界区访问，此处只能用StaticMutex锁
        static GUARD: mutex::StaticMutex = mutex::StaticMutex::new();
        //声明静态变量,是全局的静态变量，但声明在这里限制对其的访问, 初始值为1
        static mut COUNTER: u64 = 1;

        unsafe {
            //防止竞争
            let guard = GUARD.lock();

            // 加入到达最大值，panic处理。这里默认一个进程不可能创建超过u64::MAX的线程.
            // 这个稍微有些不严谨，因为即使线程终止，ID也不能重用。可以认为，一个进程不可能运行到这个时间
            if COUNTER == u64::MAX {
                drop(guard); //panic之前显式drop，以避免影响其他线程 
                //错误处理
                panic!(&quot;failed to generate unique thread ID: bitspace exhausted&quot;);
            }

            //分配新线程ID
            let id = COUNTER;
            COUNTER += 1;

            ThreadId(NonZeroU64::new(id).unwrap())
            //guard生命周期结束，会调用drop()
        }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Thread park的实现，Thread park是一种将线程自身陷入阻塞，等待别的线程做唤醒的机制。是一种比较简单的多个线程间的同步机制，通常用于线程指令执行过程中有顺序要求但不必临界区的情况</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PARKED: i32 = -1;
const EMPTY: i32 = 0;
const NOTIFIED: i32 = 1;

pub struct Parker {
    state: AtomicI32,
}

// Parker 利用原子变量操作中的内存顺序规则完成.
impl Parker {
    #[inline]
    pub const fn new() -&gt; Self {
        Parker { state: AtomicI32::new(EMPTY) }
    }

    //只被本线程调用
    pub unsafe fn park(&amp;self) {
        // 利用Acquire顺序获取当前状态 
        if self.state.fetch_sub(1, Acquire) == NOTIFIED {
            return;
        }
        loop {
            // 如果state是PARKED，阻塞等待 
            futex_wait(&amp;self.state, PARKED, None);
            // 被唤醒，将状态重新置为EMPTY,并检测是否为NOTIFIED.
            if self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Acquire).is_ok() {
                return;
            } else {
                // 应该是语法要求，逻辑上不应该进入此分支，因为不应该有其他线程调用park.
            }
        }
    }

    // 超时.
    pub unsafe fn park_timeout(&amp;self, timeout: Duration) {
        if self.state.fetch_sub(1, Acquire) == NOTIFIED {
            return;
        }
        // 直接等待，设置超时，此时不再循环，因为循环会导致超时不准.
        futex_wait(&amp;self.state, PARKED, Some(timeout));
        if self.state.swap(EMPTY, Acquire) == NOTIFIED {
            // 被unpark()唤醒
        } else {
            // 超时或者其他唤醒.
        }
    }

    pub fn unpark(&amp;self) {
        // 将state更换到NOTIFIED
        if self.state.swap(NOTIFIED, Release) == PARKED {
            //唤醒阻塞的线程
            futex_wake(&amp;self.state);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST标准库的Thread的对外结构:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 事实上的Thread结构
struct Inner {
    name: Option&lt;CString&gt;, //需要与外部语言库交互 
    id: ThreadId,
    // 用于park
    parker: Parker,
}

//Thread的管理类型
#[derive(Clone)]
pub struct Thread {
    //需要被多个线程共享
    inner: Arc&lt;Inner&gt;,
}

impl Thread {
    // 仅创建一个结构用于管理，此时尚没有与线程相关联.
    pub(crate) fn new(name: Option&lt;CString&gt;) -&gt; Thread {
        Thread { inner: Arc::new(Inner { name, id: ThreadId::new(), parker: Parker::new() }) }
    }

    //对thread做unpark操作，使得park的thread结束阻塞。
    pub fn unpark(&amp;self) {
        self.inner.parker.unpark();
    }

    pub fn id(&amp;self) -&gt; ThreadId {
        self.inner.id
    }

    pub fn name(&amp;self) -&gt; Option&lt;&amp;str&gt; {
        self.cname().map(|s| unsafe { str::from_utf8_unchecked(s.to_bytes()) })
    }

    fn cname(&amp;self) -&gt; Option&lt;&amp;CStr&gt; {
        self.inner.name.as_deref()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST的进程创建返回类型 JoinHandle：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct JoinInner&lt;'scope, T&gt; {
    native: imp::Thread,
    thread: Thread,
    packet: Arc&lt;Packet&lt;'scope, T&gt;&gt;,
}

impl&lt;'scope, T&gt; JoinInner&lt;'scope, T&gt; {
    fn join(mut self) -&gt; Result&lt;T&gt; {
        //等待线程退出
        self.native.join();
        //获取线程退出的结果或者异常信息
        Arc::get_mut(&amp;mut self.packet).unwrap().result.get_mut().take().unwrap()
    }
}

//调用spawn后返回JoinHandle，JoinHandle作为线程外部对该线程操作的标识类型结构,如park，join等
pub struct JoinHandle&lt;T&gt;(JoinInner&lt;'static, T&gt;);

unsafe impl&lt;T&gt; Send for JoinHandle&lt;T&gt; {}
unsafe impl&lt;T&gt; Sync for JoinHandle&lt;T&gt; {}


impl&lt;T&gt; JoinHandle&lt;T&gt; {
    //获取线程的Thread结构引用
    pub fn thread(&amp;self) -&gt; &amp;Thread {
        &amp;self.0.thread
    }

    //等待线程结束
    pub fn join(self) -&gt; Result&lt;T&gt; {
        self.0.join()
    }

    //判断线程是否已经终止
    pub fn is_finished(&amp;self) -&gt; bool {
        Arc::strong_count(&amp;self.0.packet) == 1
    }
}

<span class="boring">}</span></code></pre></pre>
<p>RUST线程创建工厂类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//用于非默认属性的线程创建
pub struct Builder {
    // 名字，线程默认没有名字
    name: Option&lt;String&gt;,
    // 线程堆栈大小，默认堆栈为2M bytes
    stack_size: Option&lt;usize&gt;,
}

// 线程创建方法实现
impl Builder {
    //创建一个默认的builder，一般的，用于需要对name及stack_size做修改
    pub fn new() -&gt; Builder {
        Builder { name: None, stack_size: None }
    }

    //给线程设置名称，目前仅用于线程panic时的信息输出
    pub fn name(mut self, name: String) -&gt; Builder {
        self.name = Some(name);
        self
    }

    //设置线程的堆栈空间
    pub fn stack_size(mut self, size: usize) -&gt; Builder {
        self.stack_size = Some(size);
        self
    }

    // 利用Builder属性参数创建一个新线程。如果不是在主线程执行这个函数，
    // 新线程的生命周期可能长于创建它的线程，此时创建线程可以用JoinHandle来等待
    // 新线程结束。
    pub fn spawn&lt;F, T&gt;(self, f: F) -&gt; io::Result&lt;JoinHandle&lt;T&gt;&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
    {
        unsafe { self.spawn_unchecked(f) }
    }

    //不安全的spawn
    pub unsafe fn spawn_unchecked&lt;'a, F, T&gt;(self, f: F) -&gt; io::Result&lt;JoinHandle&lt;T&gt;&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'a,
        T: Send + 'a,
    {
        Ok(JoinHandle(unsafe { self.spawn_unchecked_(f, None) }?))
    }

    //真正的spawn执行函数，此处与进程的spawn函数有些类似
    unsafe fn spawn_unchecked_&lt;'a, 'scope, F, T&gt;(
        self,
        f: F,
        scope_data: Option&lt;&amp;'scope scoped::ScopeData&gt;,
    ) -&gt; io::Result&lt;JoinInner&lt;'scope, T&gt;&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'a,
        T: Send + 'a,
        'scope: 'a,
    {
        let Builder { name, stack_size } = self;

        //不能小于规定的最小堆栈
        let stack_size = stack_size.unwrap_or_else(thread::min_stack);

        //创建一个Thread的变量
        let my_thread = Thread::new(name.map(|name| {
            CString::new(name).expect(&quot;thread name may not contain interior null bytes&quot;)
        }));
        //增加Arc计数，用于转移到创建的线程代码
        let their_thread = my_thread.clone();

        let my_packet: Arc&lt;Packet&lt;'scope, T&gt;&gt; =
            Arc::new(Packet { scope: scope_data, result: UnsafeCell::new(None) });
        //Arc计数增加，子线程写，父线程读
        let their_packet = my_packet.clone();

        //捕获panic输出的缓存空间设置,是Thread Local变量
        let output_capture = crate::io::set_output_capture(None);
        crate::io::set_output_capture(output_capture.clone());

        //所有线程的主函数, 可以认为是线程的runtime
        let main = move || {
            //their_thread已经转移到创建线程
            if let Some(name) = their_thread.cname() {
                //设置线程名字
                imp::Thread::set_name(name);
            }

            //设置本线程的panic捕获空间
            crate::io::set_output_capture(output_capture);

            // 完成thread_info的线程本地初始化.
            thread_info::set(unsafe { imp::guard::current() }, their_thread);
            // 执行f，如果f内部发生panic，调用栈会输出
            let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {
                crate::sys_common::backtrace::__rust_begin_short_backtrace(f)
            }));
            //  将线程退出信息设置到their_packet中
            unsafe { *their_packet.result.get() = Some(try_result) };
        };

        if let Some(scope_data) = scope_data {
            scope_data.increment_num_running_threads();
        }

        //真正的创建线程
        Ok(JoinInner {
            //创建线程
            native: unsafe {
                imp::Thread::new(
                    stack_size,
                    mem::transmute::&lt;Box&lt;dyn FnOnce() + 'a&gt;, Box&lt;dyn FnOnce() + 'static&gt;&gt;(
                        Box::new(main),
                    ),
                )?
            },
            thread: my_thread,
            packet: my_packet,
        })
    }
}

//无须指定参数的简易线程启动函数
pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new().spawn(f).expect(&quot;failed to spawn thread&quot;)
}

//线程自身的结构变量获取
pub fn current() -&gt; Thread {
    thread_info::current_thread().expect(
        &quot;use of std::thread::current() is not possible \
         after the thread's local data has been destroyed&quot;,
    )
}

//出让CPU
pub fn yield_now() {
    imp::Thread::yield_now()
}

//本线程是否已经panic
pub fn panicking() -&gt; bool {
    panicking::panicking()
}

//阻塞，等待其他线程唤醒
pub fn park() {
    unsafe {
        current().inner.parker.park();
    }
}

pub fn park_timeout(dur: Duration) {
    unsafe {
        current().inner.parker.park_timeout(dur);
    }
}

pub type Result&lt;T&gt; = crate::result::Result&lt;T, Box&lt;dyn Any + Send + 'static&gt;&gt;;

// 用来获取线程的退出值
// 需要在线程间共享
struct Packet&lt;'scope, T&gt; {
    scope: Option&lt;&amp;'scope scoped::ScopeData&gt;,
    result: UnsafeCell&lt;Option&lt;Result&lt;T&gt;&gt;&gt;,
}

// 使用了UnsafeCell， 需要声明实现Sync
unsafe impl&lt;'scope, T: Sync&gt; Sync for Packet&lt;'scope, T&gt; {}

impl&lt;'scope, T&gt; Drop for Packet&lt;'scope, T&gt; {
    fn drop(&amp;mut self) {
        // If this packet was for a thread that ran in a scope, the thread
        // panicked, and nobody consumed the panic payload, we make sure
        // the scope function will panic.
        let unhandled_panic = matches!(self.result.get_mut(), Some(Err(_)));
        // Drop the result without causing unwinding.
        // This is only relevant for threads that aren't join()ed, as
        // join() will take the `result` and set it to None, such that
        // there is nothing left to drop here.
        // If this panics, we should handle that, because we're outside the
        // outermost `catch_unwind` of our thread.
        // We just abort in that case, since there's nothing else we can do.
        // (And even if we tried to handle it somehow, we'd also need to handle
        // the case where the panic payload we get out of it also panics on
        // drop, and so on. See issue #86027.)
        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| {
            *self.result.get_mut() = None;
        })) {
            rtabort!(&quot;thread result panicked on drop&quot;);
        }
        // Book-keeping so the scope knows when it's done.
        if let Some(scope) = self.scope {
            // 在scope spawn线程时，在此处保证唤醒park的主线程
            scope.decrement_num_running_threads(unhandled_panic);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST线程 scope 结构,因为线程的主函数是闭包函数，对所有环境变量都是以借用引入，这会导致
因为线程不知道何时结束而出现环境变量的生命周期问题，利用scope使得线程闭包可以正常借用环境变量</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Scope&lt;'scope, 'env: 'scope&gt; {
    //主要用来做生命周期的保证
    data: ScopeData,
    //指示线程的生命周期
    scope: PhantomData&lt;&amp;'scope mut &amp;'scope ()&gt;,
    //指示环境变量的生命周期
    env: PhantomData&lt;&amp;'env mut &amp;'env ()&gt;,
}

/// JoinHandle的scoped 版本
pub struct ScopedJoinHandle&lt;'scope, T&gt;(JoinInner&lt;'scope, T&gt;);

pub(super) struct ScopeData {
    num_running_threads: AtomicUsize,
    a_thread_panicked: AtomicBool,
    main_thread: Thread,
}

impl ScopeData {
    pub(super) fn increment_num_running_threads(&amp;self) {
        //spawn线程时增加计数
        if self.num_running_threads.fetch_add(1, Ordering::Relaxed) &gt; usize::MAX / 2 {
            self.decrement_num_running_threads(false);
            panic!(&quot;too many running threads in thread scope&quot;);
        }
    }
    pub(super) fn decrement_num_running_threads(&amp;self, panic: bool) {
        if panic {
            self.a_thread_panicked.store(true, Ordering::Relaxed);
        }
        //减少线程计数
        if self.num_running_threads.fetch_sub(1, Ordering::Release) == 1 {
            //唤醒主线程
            self.main_thread.unpark();
        }
    }
}

// socpe内部创建的线程可以借用非静态变量
// 其中，'env是环境变量的生命周期，'scope是线程的生命周期
pub fn scope&lt;'env, F, T&gt;(f: F) -&gt; T
where
    F: for&lt;'scope&gt; FnOnce(&amp;'scope Scope&lt;'scope, 'env&gt;) -&gt; T,
{
    let scope = Scope {
        data: ScopeData {
            num_running_threads: AtomicUsize::new(0),
            main_thread: current(),
            a_thread_panicked: AtomicBool::new(false),
        },
        env: PhantomData,
        scope: PhantomData,
    };

    // Run `f`, but catch panics so we can make sure to wait for all the threads to join.
    let result = catch_unwind(AssertUnwindSafe(|| f(&amp;scope)));

    // 等待所有的线程都退出，保证线程的生命周期小于本函数的生命周期.
    while scope.data.num_running_threads.load(Ordering::Acquire) != 0 {
        park();
    }

    // Throw any panic from `f`, or the return value of `f` if no thread panicked.
    match result {
        Err(e) =&gt; resume_unwind(e),
        Ok(_) if scope.data.a_thread_panicked.load(Ordering::Relaxed) =&gt; {
            panic!(&quot;a scoped thread panicked&quot;)
        }
        Ok(result) =&gt; result,
    }
}

impl&lt;'scope, 'env&gt; Scope&lt;'scope, 'env&gt; {
    //用于在scope中创建新线程
    pub fn spawn&lt;F, T&gt;(&amp;'scope self, f: F) -&gt; ScopedJoinHandle&lt;'scope, T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'scope,
        T: Send + 'scope,
    {
        Builder::new()
            .spawn_scoped(self, f)
            .expect(&quot;failed to spawn thread&quot;)
    }
}

impl Builder {
    // 在scope情况下创建线程
    pub fn spawn_scoped&lt;'scope, 'env, F, T&gt;(
        self,
        scope: &amp;'scope Scope&lt;'scope, 'env&gt;,
        f: F,
    ) -&gt; io::Result&lt;ScopedJoinHandle&lt;'scope, T&gt;&gt;
    where
        //设置了生命周期，使得f可以使用环境变量引用
        F: FnOnce() -&gt; T + Send + 'scope,
        T: Send + 'scope,
    {
        Ok(ScopedJoinHandle(unsafe {
            self.spawn_unchecked_(f, Some(&amp;scope.data))
        }?))
    }
}

//利用生命周期的标注来使用环境变量引用
impl&lt;'scope, T&gt; ScopedJoinHandle&lt;'scope, T&gt; {
    
    pub fn thread(&amp;self) -&gt; &amp;Thread {
        &amp;self.0.thread
    }

    pub fn join(self) -&gt; Result&lt;T&gt; {
        self.0.join()
    }

    pub fn is_finished(&amp;self) -&gt; bool {
        Arc::strong_count(&amp;self.0.packet) == 1
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="15-std库(四)线程临界区类型.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="17-std库(六)mpsc通信.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="15-std库(四)线程临界区类型.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="17-std库(六)mpsc通信.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
