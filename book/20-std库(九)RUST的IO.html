<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>std库(九)RUST的IO - rust-inside-std-book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="引言.html">引言</a></li><li class="chapter-item expanded affix "><a href="01-RUST库体系概述.html">RUST库体系概述</a></li><li class="chapter-item expanded affix "><a href="02-内存.html">内存</a></li><li class="chapter-item expanded affix "><a href="03-固有函数库及基础类型.html">固有函数库及基础类型</a></li><li class="chapter-item expanded affix "><a href="04-基础Trait.html">基础Trait</a></li><li class="chapter-item expanded affix "><a href="05-Iterator.html">Iterator</a></li><li class="chapter-item expanded affix "><a href="06-基本类型续.html">基本类型续</a></li><li class="chapter-item expanded affix "><a href="07-内部可变性类型.html">内部可变性类型</a></li><li class="chapter-item expanded affix "><a href="08-智能指针类型(一).html">智能指针类型(一)</a></li><li class="chapter-item expanded affix "><a href="09-智能指针类型(二).html">智能指针类型(二)</a></li><li class="chapter-item expanded affix "><a href="10-智能指针类型(三).html">智能指针类型(三)</a></li><li class="chapter-item expanded affix "><a href="11-智能指针类型(四).html">智能指针类型(四)</a></li><li class="chapter-item expanded affix "><a href="12-std库(一)FFI及内存管理.html">std库(一)FFI及内存管理</a></li><li class="chapter-item expanded affix "><a href="13-std库(二)文件描述符及进程管理.html">std库(二)文件描述符及进程管理</a></li><li class="chapter-item expanded affix "><a href="14-std库(三)线程间锁通信.html">std库(三)线程间锁通信</a></li><li class="chapter-item expanded affix "><a href="15-std库(四)线程临界区类型.html">std库(四)线程临界区类型</a></li><li class="chapter-item expanded affix "><a href="16-std库(五)线程管理.html">std库(五)线程管理</a></li><li class="chapter-item expanded affix "><a href="17-std库(六)mpsc通信.html">std库(六)mpsc通信</a></li><li class="chapter-item expanded affix "><a href="18-std库(七)RUST的RUNTIME.html">std库(七)RUST的RUNTIME</a></li><li class="chapter-item expanded affix "><a href="19-std库(八)RUST文件系统.html">std库(八)RUST文件系统</a></li><li class="chapter-item expanded affix "><a href="20-std库(九)RUST的IO.html" class="active">std库(九)RUST的IO</a></li><li class="chapter-item expanded affix "><a href="21-RUST的异步编程.html">RUST的异步编程</a></li><li class="chapter-item expanded affix "><a href="后记.html">后记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-inside-std-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust的io操作"><a class="header" href="#rust的io操作">RUST的IO操作</a></h1>
<p>IO是一门语言中内容最多，最繁杂的一个课题，其关心的主要内容:</p>
<ol>
<li>操作系统文件同步IO操作</li>
<li>操作系统网络/设备同步IO操作</li>
<li>操作系统多路异步IO操作，包括文件/设备/网络</li>
<li>采用一套编程模型抽象与IO相关的缓存操作</li>
<li>程序不同模块间通信采取与4相同的抽象接口</li>
<li>...</li>
</ol>
<p>值得注意，在服务器后端的应用中，实际上采用多路异步IO是标准的实现方式，异步IO内容稍微复杂，将在后继的异步IO章节里单独说明。
RUST的标准库中的IO内容实际上仅仅提供同步IO的实现。要注意的是，虽然标准库仅提供了同步IO，但异步IO实际上仍然可以将这些同步IO的实现作为基本组件来简化工作。</p>
<p>在同步IO设计中，符合自然视角的IO对象设计，线程安全设计，缓存设计是难点。</p>
<p>IO对象设计：<br />
最自然的IO对象设计是针对每一个不同的IO分类设计不同的IO对象类型，不同的IO对象实现相同的操作 trait，仅在独特之处进行方法扩充。</p>
<p>线程安全设计：<br />
每一个IO对象实际上都存在多线程操作的可能，IO对象的类型结构应该是一个RUST线程安全类型结构。</p>
<p>缓存设计：
不是所有的IO对象类型都需要缓存，设计缓存的作用主要是：</p>
<ol>
<li>可以将一些底层的IO操作封装在缓存实现中，简化上层模块IO实现。</li>
<li>提升IO效率，对某些非实时IO操作，可以达到一定数目后批量性写入，或批量性读出</li>
<li>更好的模块性，可以将缓存作为不同模块的IO管道，重用已有模块，例如重用压缩/解压缩模块</li>
<li>用作数据序列化格式转换的执行类型，以及数据序列化的内存存储，方便各种操作</li>
</ol>
<p>缓存设计的一些需求：</p>
<ol>
<li>缓存自身应该作为一种IO对象，</li>
<li>缓存封装原始IO对象，使用adapter模式完成对原始IO对象的IO操作</li>
<li>针对不同的IO对象的缓存基础设施结构，支持不同的IO对象的缓存设计</li>
<li>迭代器设计以应用函数式编程。</li>
</ol>
<p>先以标准输入的IO对象来阐明RUST的同步IO实现的代码:</p>
<h2 id="rust标准库stdin的代码分析"><a class="header" href="#rust标准库stdin的代码分析">RUST标准库Stdin的代码分析</a></h2>
<p>RUST语言库实现了线程安全的标准输入。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/io/stdio.rs
pub struct Stdin {
    //标准输入可认为是静态的
    inner: &amp;'static Mutex&lt;BufReader&lt;StdinRaw&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Mutex&lt;T&gt;</code>请参考前文的分析。
原始的标准输入源IO对象类型StdinRaw定义相关代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//linux系统的标准输入的类型结构
//因为标准输入的文件描述符不必关闭，
//所以此处用了单元类型
//路径: library/std/src/sys/unix/stdio.rs
pub struct Stdin(());

impl Stdin {
    //创建函数
    pub const fn new() -&gt; Stdin {
        Stdin(())
    }
}

//RUST对操作系统的扩展
//路径: library/std/src/io/stdio.rs
//此处stdio是sys::stdio
struct StdinRaw(stdio::Stdin); 

//StdinRaw的工厂函数
const fn stdin_raw() -&gt; StdinRaw {
    StdinRaw(stdio::Stdin::new())
}
<span class="boring">}</span></code></pre></pre>
<p>RUST专门为读入设计的缓存类型结构<code>BufReader&lt;R&gt;</code>定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径: library/std/src/io/buffer/bufreader.rs
//在实现了Read trait的输入源IO对象类型基础上创建读缓存结构
pub struct BufReader&lt;R&gt; {
    //输入源IO对象类型，
    //BufReader拥有其所有权
    inner: R,
    //缓存，在self创建的时候一般没有初始化
    //位于堆内存
    buf: Box&lt;[MaybeUninit&lt;u8&gt;]&gt;,
    //缓存中未被读取的数据起始位置
    pos: usize,
    //从输入源已经读入缓存的数据终止位置
    cap: usize,
    //buf中已经初始化过的数据的终止位置
    init: usize,
}

impl&lt;R: Read&gt; BufReader&lt;R&gt; {
    //创建一个默认空间的缓存
    pub fn new(inner: R) -&gt; BufReader&lt;R&gt; {
        //DEFAULT_BUF_SIZE RUST当前定义为8*1024
        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)
    }

    pub fn with_capacity(capacity: usize, inner: R) -&gt; BufReader&lt;R&gt; {
        //从堆中申请相应空间的内存
        let buf = Box::new_uninit_slice(capacity);
        //创建BufReader类型变量
        BufReader { inner, buf, pos: 0, cap: 0, init: 0 }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对于所有的输入IO对象类型，必须实现Read trait:
定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径: library/std/src/io/mod.rs
//在异步IO时，此Read可以用于最底层的支持
pub trait Read {
    //从输入IO对象类型中读出数据到buf中，成功则返回读到的长度
    //否则返回IO错误，IO错误的情况下，buf中一定没有数据
    //此函数可能被阻塞，如果需要阻塞又没办法时，会返回Err
    //返回0一般表示已经读到文件尾部或fd已经关闭，或者buf空间为0
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;

    //利用向量读的方式读，除此之外，与read相同, IoSliceMut见后继说明
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt; {
        //默认不支持iovec的方式，使用read来模拟实现
        default_read_vectored(|b| self.read(b), bufs)
    }

    //是否实现向量读的方式,一般应优选向量读
    fn is_read_vectored(&amp;self) -&gt; bool {
        false
    }

    //此方法会循环调用read直至读到文件尾(EOF)
    //一直读到文件尾部，此方法内部可以自由扩充Vec，Vec中的有效内容代表已经读到
    //的数据。
    //遇到错误会立刻返回，读到的数据仍然在Vec中
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; {
        default_read_to_end(self, buf)
    }

    //类似与read_to_end，但这里确定读到的是字符串,且符合utf-8的编码
    //其他与read_to_end相同
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; {
        default_read_to_string(self, buf)
    }

    //精确读与buf长度相同的字节，否则返回错误
    //如果长度不够且到达尾部，会返回错误
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt; {
        default_read_exact(self, buf)
    }

    //在有缓存的情况下，用以下函数将数据读到缓存里
    //一般ReadBuf由缓存类型结构创建
    fn read_buf(&amp;mut self, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        default_read_buf(|b| self.read(b), buf)
    }

    //精确的将要求容量字节到缓存里面
    fn read_buf_exact(&amp;mut self, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        while buf.remaining() &gt; 0 {
            let prev_filled = buf.filled().len();
            match self.read_buf(buf) {
                Ok(()) =&gt; {}
                Err(e) if e.kind() == ErrorKind::Interrupted =&gt; continue,
                Err(e) =&gt; return Err(e),
            }

            if buf.filled().len() == prev_filled {
                return Err(Error::new(ErrorKind::UnexpectedEof, &quot;failed to fill buffer&quot;));
            }
        }

        Ok(())
    }

    //借用的一种实现方式，专为Read使用
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized,
    {
        self
    }

    //将本身转换为一个字节流的迭代器
    //后继用迭代器的方法完成读
    fn bytes(self) -&gt; Bytes&lt;Self&gt;
    where
        Self: Sized,
    {
        Bytes { inner: self }
    }

    //将两个读的源串接
    fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;
    where
        Self: Sized,
    {
        Chain { first: self, second: next, done_first: false }
    }

    //以self为基础生成一个字节数有限制的输入源
    fn take(self, limit: u64) -&gt; Take&lt;Self&gt;
    where
        Self: Sized,
    {
        Take { inner: self, limit }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对于文件类及缓存类IO对象类型，一般也都实现了在IO流中定位特定位置的 Seek trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SeekFrom {
    /// 从头部开始向尾部偏移字节数.
    Start(u64),
 
    //从尾部开始向头部偏移字节数
    End(i64),

    //从当前位置开始向尾部偏移字节数
    Current(i64),
}
pub trait Seek {
    //定位到IO流的指定偏移位置，如果需要从当前位置向头部偏移
    //则返回错误
    //成功则返回从头部计算的的偏移字节数
    fn seek(&amp;mut self, pos: SeekFrom) -&gt; Result&lt;u64&gt;;

    //重新定位到头部
    fn rewind(&amp;mut self) -&gt; Result&lt;()&gt; {
        self.seek(SeekFrom::Start(0))?;
        Ok(())
    }

    //返回IO流的总长度
    fn stream_len(&amp;mut self) -&gt; Result&lt;u64&gt; {
        //保存当前位置
        let old_pos = self.stream_position()?;
        //重定位到尾
        let len = self.seek(SeekFrom::End(0))?;

        if old_pos != len {
            //返回到当前位置
            self.seek(SeekFrom::Start(old_pos))?;
        }

        Ok(len)
    }

    //返回当前位置
    fn stream_position(&amp;mut self) -&gt; Result&lt;u64&gt; {
        self.seek(SeekFrom::Current(0))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>针对std::sys::Stdio的Read trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/sys/unix/stdio.rs
//实现Read trait
impl io::Read for Stdin {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //标准输入不必关闭，因此这里生成的OwnedFd不能调用drop
        //所以用ManuallyDrop来实现这一点
        //自动解引用调用FileDesc::read方法
        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read(buf) }
    }

    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read_vectored(bufs) }
    }

    fn is_read_vectored(&amp;self) -&gt; bool {
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<p>针对StdioRaw的Read trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/io/stdio.rs
//支持函数,处理输入输出的错误
fn handle_ebadf&lt;T&gt;(r: io::Result&lt;T&gt;, default: T) -&gt; io::Result&lt;T&gt; {
    match r {
        //如果错误是fd无效，则返回默认值
        Err(ref e) if stdio::is_ebadf(e) =&gt; Ok(default),
        r =&gt; r,
    }
}

//RUST的IO对象类型通常是一个逐级封装的结构
//StdinRaw采用了adapter的模式实现Read trait
impl Read for StdinRaw {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //直接调用内部封装的stdin同名方法
        handle_ebadf(self.0.read(buf), 0)
    }

    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        handle_ebadf(self.0.read_vectored(bufs), 0)
    }

    fn is_read_vectored(&amp;self) -&gt; bool {
        self.0.is_read_vectored()
    }

    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; {
        handle_ebadf(self.0.read_to_end(buf), 0)
    }

    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; {
        handle_ebadf(self.0.read_to_string(buf), 0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST语言的Stdin实质是<code>BufReader&lt;StdinRaw&gt;</code>的线程安全版本。<br />
BufReader需要实现基于缓存的 BufRead trait, 以充分利用缓存：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径: library/std/src/io/mod.rs 
pub trait BufRead: Read {
    //从输入源IO对象读入并填充缓存，并将内部的缓存
    //以字节切片引用方式返回
    fn fill_buf(&amp;mut self) -&gt; Result&lt;&amp;[u8]&gt;;

    //有amt的字节被从缓存读出，对self的参数做针对性改变
    fn consume(&amp;mut self, amt: usize);

    //缓存是否还存在未被读出的数据
    fn has_data_left(&amp;mut self) -&gt; Result&lt;bool&gt; {
        self.fill_buf().map(|b| !b.is_empty())
    }

    //将buf读到buf中，直到有数据为输入的参数
    fn read_until(&amp;mut self, byte: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; {
        read_until(self, byte, buf)
    }

    //从缓存中读出一行
    fn read_line(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; {
        //借助read_until简单实现
        unsafe { append_to_string(buf, |b| read_until(self, b'\n', b)) }
    }

    //返回一个迭代器，将buf按输入的参数做分离
    fn split(self, byte: u8) -&gt; Split&lt;Self&gt;
    where
        Self: Sized,
    {
        Split { buf: self, delim: byte }
    }

    //返回一个迭代器，将buf按行进行迭代
    fn lines(self) -&gt; Lines&lt;Self&gt;
    where
        Self: Sized,
    {
        Lines { buf: self }
    }
}

//上面trait的支持函数
fn read_until&lt;R: BufRead + ?Sized&gt;(r: &amp;mut R, delim: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; {
    let mut read = 0;
    loop {
        let (done, used) = {
            //先将数据读入r的缓存中，available是新读入的内容
            let available = match r.fill_buf() {
                Ok(n) =&gt; n,
                Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; continue,
                Err(e) =&gt; return Err(e),
            };
            //在buf中定位第一个分隔符
            match memchr::memchr(delim, available) {
                //找到
                Some(i) =&gt; {
                    //将分隔符之前的内容置入buf中
                    buf.extend_from_slice(&amp;available[..=i]);
                    (true, i + 1)
                }
                //没找到
                None =&gt; {
                    //将所有内容置入buf中
                    buf.extend_from_slice(available);
                    (false, available.len())
                }
            }
        };
        //更新r以反应已经读出的内容
        r.consume(used);
        //得到读到的字节总数
        read += used;
        //看是否已经读到分隔符，或者内容已经读空
        if done || used == 0 {
            //返回读到的字节总数目
            return Ok(read);
        }
    }
}

//BufRead::read_lines的Iterator类型支持结构
pub struct Lines&lt;B&gt; {
    buf: B,
}

impl&lt;B: BufRead&gt; Iterator for Lines&lt;B&gt; {
    type Item = Result&lt;String&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;String&gt;&gt; {
        let mut buf = String::new();
        //调用read_line
        match self.buf.read_line(&amp;mut buf) {
            Ok(0) =&gt; None,
            Ok(_n) =&gt; {
                if buf.ends_with('\n') {
                    //将'\n'删除
                    buf.pop();
                    if buf.ends_with('\r') {
                        //将'\r'删除
                        buf.pop();
                    }
                }
                Some(Ok(buf))
            }
            Err(e) =&gt; Some(Err(e)),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>利用缓存从IO输入源读取数据时，RUST专门设计了ReadBuf的类型结构：
对于不同的数据，可能设计不同的缓存结构，BufReader仅仅是其中的一种。<br />
但从输入源读入到缓存涉及的数据基本是固定不变的，即要读入的字节切片，字节切片已经读入的字节数，及RUST语法带来的字节切片中已经初始化的字节数，因此设计了ReadBuf以完成缓存读入的抽象类型结构体。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/readbuf.rs
pub struct ReadBuf&lt;'a&gt; {
    //用作缓存的内存块切片引用，由
    //外部的缓存类型提供，此块内存
    //第一次总是MaybeUninit
    buf: &amp;'a mut [MaybeUninit&lt;u8&gt;],
    //已经读入的数据，buf[0..filled]是读入的数据
    filled: usize,
    //已经assume_init的数据,buf[0..initialized]
    //是初始化过的数据
    //代码中需要保证filled应该小于initialized
    initialized: usize,
}

impl&lt;'a&gt; ReadBuf&lt;'a&gt; {
    //用一个已经初始化的内存块创建一个ReadBuf，
    //此内存块应该已经初始化完毕
    pub fn new(buf: &amp;'a mut [u8]) -&gt; ReadBuf&lt;'a&gt; {
        let len = buf.len();

        ReadBuf {
            //强制转换为[MaybeUninit&lt;u8&gt;]类型
            buf: unsafe { (buf as *mut [u8]).as_uninit_slice_mut().unwrap() },
            //没有读入数据
            filled: 0,
            //此buf实际上已经初始化
            initialized: len,
        }
    }

    //用未初始化的内存块创建ReadBuf
    pub fn uninit(buf: &amp;'a mut [MaybeUninit&lt;u8&gt;]) -&gt; ReadBuf&lt;'a&gt; {
        ReadBuf { buf, filled: 0, initialized: 0 }
    }

    pub fn capacity(&amp;self) -&gt; usize {
        self.buf.len()
    }

    //返回已经读到的字节切片引用
    pub fn filled(&amp;self) -&gt; &amp;[u8] {
        unsafe { MaybeUninit::slice_assume_init_ref(&amp;self.buf[0..self.filled]) }
    }

    //返回已经读到的字节切片可变引用
    pub fn filled_mut(&amp;mut self) -&gt; &amp;mut [u8] {
        unsafe { MaybeUninit::slice_assume_init_mut(&amp;mut self.buf[0..self.filled]) }
    }

    //返回已经初始化的字节切片引用
    pub fn initialized(&amp;self) -&gt; &amp;[u8] {
        unsafe { MaybeUninit::slice_assume_init_ref(&amp;self.buf[0..self.initialized]) }
    }

    //返回已经初始化的字节切片可变引用
    pub fn initialized_mut(&amp;mut self) -&gt; &amp;mut [u8] {
        unsafe { MaybeUninit::slice_assume_init_mut(&amp;mut self.buf[0..self.initialized]) }
    }

    //返回没有读入字节的缓存部分的可变引用切片
    pub unsafe fn unfilled_mut(&amp;mut self) -&gt; &amp;mut [MaybeUninit&lt;u8&gt;] {
        &amp;mut self.buf[self.filled..]
    }

    //返回没有做assume_init的缓存部分的可变引用切片
    pub fn uninitialized_mut(&amp;mut self) -&gt; &amp;mut [MaybeUninit&lt;u8&gt;] {
        &amp;mut self.buf[self.initialized..]
    }

    //对所有的未读入字节的缓存做assume_init
    pub fn initialize_unfilled(&amp;mut self) -&gt; &amp;mut [u8] {
        self.initialize_unfilled_to(self.remaining())
    }

    //从未读到字节的起始字节开始设置若干个字节assume_init
    pub fn initialize_unfilled_to(&amp;mut self, n: usize) -&gt; &amp;mut [u8] {
        assert!(self.remaining() &gt;= n);

        //获取没有读入内容却已经初始化的字节数
        let extra_init = self.initialized - self.filled;
        //判断是否需要额外做初始化
        if n &gt; extra_init {
            //获取需要初始化的字节数
            let uninit = n - extra_init;
            //获取需要初始化的字节切片
            let unfilled = &amp;mut self.uninitialized_mut()[0..uninit];

            //完成初始化为0
            for byte in unfilled.iter_mut() {
                byte.write(0);
            }

            unsafe {
                //设置为已经初始化
                self.assume_init(n);
            }
        }

        let filled = self.filled;

        //返回初始化但没有读到内容的字节切片
        &amp;mut self.initialized_mut()[filled..filled + n]
    }

    //空闲的字节数目
    pub fn remaining(&amp;self) -&gt; usize {
        self.capacity() - self.filled
    }

    //清除已读的内容，仅需要设置filled数值即可
    pub fn clear(&amp;mut self) {
        self.set_filled(0); // The assertion in `set_filled` is optimized out
    }

    //增加已读内容字节数
    pub fn add_filled(&amp;mut self, n: usize) {
        self.set_filled(self.filled + n);
    }

    //设置已经读入内容的字节数
    pub fn set_filled(&amp;mut self, n: usize) {
        assert!(n &lt;= self.initialized);

        self.filled = n;
    }

    //设置已经初始化的字节数目
    pub unsafe fn assume_init(&amp;mut self, n: usize) {
        self.initialized = cmp::max(self.initialized, self.filled + n);
    }

    //将内容拷贝入已读内容之后作为新读入的内容
    pub fn append(&amp;mut self, buf: &amp;[u8]) {
        assert!(self.remaining() &gt;= buf.len());

        unsafe {
            //需要用MaybeUninit的方法来完成内容更新
            MaybeUninit::write_slice(&amp;mut self.unfilled_mut()[..buf.len()], buf);
        }

        //更新初始化的字节数及读入内容的字节数
        unsafe { self.assume_init(buf.len()) }
        self.add_filled(buf.len());
    }

    //获取filled参数
    pub fn filled_len(&amp;self) -&gt; usize {
        self.filled
    }

    //获取初始化的参数
    pub fn initialized_len(&amp;self) -&gt; usize {
        self.initialized
    }
}
<span class="boring">}</span></code></pre></pre>
<p>BufRead的基础方法，BufRead trait, Read trait实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/buffer/bufreader.rs
impl&lt;R&gt; BufReader&lt;R&gt; {
    //获取内部的输入源引用
    pub fn get_ref(&amp;self) -&gt; &amp;R {
        &amp;self.inner
    }

    //获取内部输入源的可变引用
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut R {
        &amp;mut self.inner
    }

    pub fn buffer(&amp;self) -&gt; &amp;[u8] {
        //将已经读入缓存，但未从缓存读出的内容以切片返回，且完成初始化操作
        unsafe { MaybeUninit::slice_assume_init_ref(&amp;self.buf[self.pos..self.cap]) }
    }

    //缓存内存空间大小
    pub fn capacity(&amp;self) -&gt; usize {
        self.buf.len()
    }

    //消费self并取出内部输入源
    pub fn into_inner(self) -&gt; R {
        self.inner
    }

    //丢弃已经读入缓存的内容,此处似乎用drop更符合rust
    //用discar实际上是类似C的方式了
    fn discard_buffer(&amp;mut self) {
        self.pos = 0;
        self.cap = 0;
    }
}

//为数据读入缓存设计的trait
impl&lt;R: Read&gt; BufRead for BufReader&lt;R&gt; {
    fn fill_buf(&amp;mut self) -&gt; io::Result&lt;&amp;[u8]&gt; {
        //判断缓存中是否还有未读的内容
        if self.pos &gt;= self.cap {
            //没有，则清理缓存，并从输入源读入新的内容
            debug_assert!(self.pos == self.cap);

            //利用self.buf创建ReadBuf类型结构体变量完成读
            let mut readbuf = ReadBuf::uninit(&amp;mut self.buf);

            unsafe {
                //传递buf中已经assmue_init过的字节数
                readbuf.assume_init(self.init);
            }

            //调用输入源IO对象的read_buf完成缓存读
            self.inner.read_buf(&amp;mut readbuf)?;

            //根据readbuf的参数修改self参数
            self.cap = readbuf.filled_len();
            self.init = readbuf.initialized_len();

            //更新初始位置
            self.pos = 0;
        }
        //返回缓存内的有效内容
        Ok(self.buffer())
    }

    //对已经从缓存读出的数据完成参数调整
    fn consume(&amp;mut self, amt: usize) {
        self.pos = cmp::min(self.pos + amt, self.cap);
    }
}

impl&lt;R: Read&gt; Read for BufReader&lt;R&gt; {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //判断缓存是否为空且要读出的数据长度大于缓存容量
        if self.pos == self.cap &amp;&amp; buf.len() &gt;= self.buf.len() {
            //是，将缓存参数复位
            self.discard_buffer();
            //旁路缓存，直接将数据读入参数中的buf
            return self.inner.read(buf);
        }
        //缓存内有数据，或者要读出的数据长度小于缓存容量
        let nread = {
            //先填充缓存
            let mut rem = self.fill_buf()?;
            //实质是&amp;[u8] as Read::read(buf)，
            rem.read(buf)?
        };
        //调整参数反应已经从缓存读出的字节数
        self.consume(nread);
        Ok(nread)
    }

    fn read_buf(&amp;mut self, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; io::Result&lt;()&gt; {
        //见read的逻辑
        if self.pos == self.cap &amp;&amp; buf.remaining() &gt;= self.buf.len() {
            self.discard_buffer();
            return self.inner.read_buf(buf);
        }

        //获取原有的已读字节
        let prev = buf.filled_len();

        //填充缓存
        let mut rem = self.fill_buf()?;
        //&amp;[u8] as Read::read_buf()
        rem.read_buf(buf)?;

        //获得本次读的字节数，更新参数
        self.consume(buf.filled_len() - prev); //slice impl of read_buf known to never unfill buf

        Ok(())
    }

    //精确读取给定长度的内容
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;()&gt; {
        //判断缓存中是否已经有足够的已读字节
        if self.buffer().len() &gt;= buf.len() {
            //有，从缓存拷贝到buf
            buf.copy_from_slice(&amp;self.buffer()[..buf.len()]);
            //调整本身参数
            self.consume(buf.len());
            return Ok(());
        }

        //没有，用默认精确读
        crate::io::default_read_exact(self, buf)
    }

    //向量读方法
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        //获取总体要读的字节数
        let total_len = bufs.iter().map(|b| b.len()).sum::&lt;usize&gt;();
        //判断缓存是否为空,且读取总字节数大于缓存长度
        if self.pos == self.cap &amp;&amp; total_len &gt;= self.buf.len() {
            //清空缓存
            self.discard_buffer();
            //直接读入参数给出的buf
            return self.inner.read_vectored(bufs);
        }
        //缓存不为空或读取总长度小于缓存长度
        let nread = {
            //填充缓存
            let mut rem = self.fill_buf()?;
            //&amp;[u8]::read_vectored
            rem.read_vectored(bufs)?
        };
        //更新缓存参数
        self.consume(nread);
        Ok(nread)
    }

    fn is_read_vectored(&amp;self) -&gt; bool {
        self.inner.is_read_vectored()
    }

    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; {
        //先将缓存内容读到buf中
        let nread = self.cap - self.pos;
        buf.extend_from_slice(&amp;self.buffer());
        //清空缓存
        self.discard_buffer();
        //再将内部输入源的内容全部读出到输入的buf中，
        //返回本次操作的总长度
        Ok(nread + self.inner.read_to_end(buf)?)
    }

    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; {
        //判断是否为空字符串
        if buf.is_empty() {
            //空字符串，则直接用append_to_string完成即可
            unsafe { crate::io::append_to_string(buf, |b| self.read_to_end(b)) }
        } else {
            //不是空字符串
            //先将内容读入创建的缓存中
            let mut bytes = Vec::new();
            self.read_to_end(&amp;mut bytes)?;
            //从缓存生成字符串,并连接到输入字符串尾部
            let string = crate::str::from_utf8(&amp;bytes).map_err(|_| {
                io::const_io_error!(
                    io::ErrorKind::InvalidData,
                    &quot;stream did not contain valid UTF-8&quot;,
                )
            })?;
            *buf += string;
            Ok(string.len())
        }
    }
}

//Seek trait的实现
impl&lt;R: Seek&gt; Seek for BufReader&lt;R&gt; {
    fn seek(&amp;mut self, pos: SeekFrom) -&gt; io::Result&lt;u64&gt; {
        let result: u64;
        if let SeekFrom::Current(n) = pos {
            //从当前位置偏移
            //获取剩余未读的字节数
            let remainder = (self.cap - self.pos) as i64;
            
            //如果偏移字节大于缓存内未读的字节 
            if let Some(offset) = n.checked_sub(remainder) {
                //需要对输入源进行偏移
                result = self.inner.seek(SeekFrom::Current(offset))?;
            } else {
                //偏移字节小于缓存内未读的字节
                //此时需要将缓存内已读的字节清空，
                self.inner.seek(SeekFrom::Current(-remainder))?;
                self.discard_buffer();
                //将输入源偏移到新的位置
                result = self.inner.seek(SeekFrom::Current(n))?;
            }
        } else {
            //不是从当前位置偏移，则直接在输入源做偏移
            result = self.inner.seek(pos)?;
        }
        //偏移后需要清空缓存
        self.discard_buffer();
        Ok(result)
    }

    fn stream_position(&amp;mut self) -&gt; io::Result&lt;u64&gt; {
        //获得未被读出的字节数
        let remainder = (self.cap - self.pos) as u64;
        //从底层IO对象获得当前位置，再减掉未被读出的字节
        self.inner.stream_position().map(|pos| {
            pos.checked_sub(remainder).expect(
                &quot;overflow when subtracting remaining buffer size from inner stream position&quot;,
            )
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上涉及的一些支持函数代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/mod.rs
//Read trait精确读若干字节的默认实现。精确读的例子是处理有总长度字段的协议包头。只有读出包头才能知道整个数据包的长度
//因此一般先读一个固定长度的数据包报文头
pub(crate) fn default_read_exact&lt;R: Read + ?Sized&gt;(this: &amp;mut R, mut buf: &amp;mut [u8]) -&gt; Result&lt;()&gt; {
    //循环直到读到要求的字节数目
    while !buf.is_empty() {
        match this.read(buf) {
            //输入源已经没有内容
            Ok(0) =&gt; break,
            //根据读到的内容更新buf
            Ok(n) =&gt; {
                //这个交换是比较经典的编码技巧
                let tmp = buf;
                buf = &amp;mut tmp[n..];
            }
            //如果是操作系统的原因造成中断，则继续循环
            Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
            //其他错误返回
            Err(e) =&gt; return Err(e),
        }
    }
    //判断是否读到字节数目
    if !buf.is_empty() {
        //否，仅因为输入源已经没有内容的错误
        Err(error::const_io_error!(ErrorKind::UnexpectedEof, &quot;failed to fill whole buffer&quot;))
    } else {
        Ok(())
    }
}

//Read trait中read_buf的默认函数
pub(crate) fn default_read_buf&lt;F&gt;(read: F, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; Result&lt;()&gt;
where
    F: FnOnce(&amp;mut [u8]) -&gt; Result&lt;usize&gt;,
{
    //对buf中没读入的空间先全部初始化，然后做读操作
    let n = read(buf.initialize_unfilled())?;
    //根据读入字节更新ReadBuf参数
    buf.add_filled(n);
    Ok(())
}

//Read trait中默认的read_to_end的方法实现
pub(crate) fn default_read_to_end&lt;R: Read + ?Sized&gt;(r: &amp;mut R, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; {
    let start_len = buf.len();
    let start_cap = buf.capacity();

    //初始化但没有读入内容的字节数为0
    let mut initialized = 0; // Extra initialized bytes from previous loop iteration
    loop {
        if buf.len() == buf.capacity() {
            //buf已经没有空间，
            //对buf进行扩充
            buf.reserve(32); // buf is full, need more space
        }

        //将buf中没有填充内容的部分生成切片，并创建ReadBuf
        let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());

        // 将read_buf的参数设置正确
        unsafe {
            //设置ReadBuf的初始化字节数
            read_buf.assume_init(initialized);
        }

        //调用输入源的read_buf读入内容
        match r.read_buf(&amp;mut read_buf) {
            Ok(()) =&gt; {}
            //操作系统的原因中断，继续循环
            Err(e) if e.kind() == ErrorKind::Interrupted =&gt; continue,
            //出错则返回
            Err(e) =&gt; return Err(e),
        }

        //判断输入源是否已经全部被读入
        if read_buf.filled_len() == 0 {
            //已经全部读入，则返回
            return Ok(buf.len() - start_len);
        }

        //输入源仍然可能有数据没有被读入
        //根据ReadBuf更新已经初始化但没有读入内容的字节数
        initialized = read_buf.initialized_len() - read_buf.filled_len();
        //根据读入字节的数目修改Vec的参数
        let new_len = read_buf.filled_len() + buf.len();

        unsafe {
            //设置Vec的参数反应已经读入的内容
            buf.set_len(new_len);
        }

        //前面最多只能读到buf.capacity()
        //判断初始传入的buf是否已经读满
        if buf.len() == buf.capacity() &amp;&amp; buf.capacity() == start_cap {
            let mut probe = [0u8; 32];

            loop {
                //每次循环最多读取32个字节的额外内容
                match r.read(&amp;mut probe) {
                    //输入源已经没有内容
                    Ok(0) =&gt; return Ok(buf.len() - start_len),
                    //输入源还有内容
                    Ok(n) =&gt; {
                        //对buf做扩展并放置新的内容
                        buf.extend_from_slice(&amp;probe[..n]);
                        //重新进入上级循环
                        break;
                    }
                    Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; continue,
                    Err(e) =&gt; return Err(e),
                }
            }
        }
    }
}

//Read trait的默认read_to_string的函数
pub(crate) fn default_read_to_string&lt;R: Read + ?Sized&gt;(
    r: &amp;mut R,
    buf: &amp;mut String,
) -&gt; Result&lt;usize&gt; {
    //对读入做是否为字符的判断，并且在判断非字符的时候将String恢复为初始值
    unsafe { append_to_string(buf, |b| default_read_to_end(r, b)) }
}

//上个函数的支持函数
pub(crate) unsafe fn append_to_string&lt;F&gt;(buf: &amp;mut String, f: F) -&gt; Result&lt;usize&gt;
where
    F: FnOnce(&amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;,
{
    //利用Guard保证错误处理
    let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };
    //对g.buf做更新
    let ret = f(g.buf);
    //对g.buf新增的内容判断是否为字符串
    if str::from_utf8(&amp;g.buf[g.len..]).is_err() {
        //不是字符串,返回错误
        ret.and_then(|_| {
            Err(error::const_io_error!(
                ErrorKind::InvalidData,
                &quot;stream did not contain valid UTF-8&quot;
            ))
        })
        //此处用Guard的结构保证了g.buf会被恢复成输入时的状态 
    } else {
        //是字符串，对g做更新，返回读到的字节数
        g.len = g.buf.len();
        ret
    }
    //Guard保证了buf里面内容的正确，但有些不够直接
}
//上面函数的Guard相关内容
//这个结构是为了使用drop
struct Guard&lt;'a&gt; {
    buf: &amp;'a mut Vec&lt;u8&gt;,
    len: usize,
}

impl Drop for Guard&lt;'_&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            //对buf的len做修改
            self.buf.set_len(self.len);
        }
    }
}

//直接从输入源内容创建String，
pub fn read_to_string&lt;R: Read&gt;(mut reader: R) -&gt; Result&lt;String&gt; {
    let mut buf = String::new();
    reader.read_to_string(&amp;mut buf)?;
    Ok(buf)
}
//操作系统不支持向量读写的方式时的默认实现
//用输入源提供的read来实现
pub(crate) fn default_read_vectored&lt;F&gt;(read: F, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt;
where
    F: FnOnce(&amp;mut [u8]) -&gt; Result&lt;usize&gt;,
{
    //[]实际上是[u8;0]
    let buf = bufs.iter_mut().find(|b| !b.is_empty()).map_or(&amp;mut [][..], |b| &amp;mut **b);
    read(buf)
}
<span class="boring">}</span></code></pre></pre>
<p>以上完成了所有RUST的对外类型结构Stdin的相关类型的代码分析。现在回到Stdin本身：
再次看一下Stdin的类型结构的相关实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/stdio.rs
//RUST的对外的标准输入结构
pub struct Stdin {
    inner: &amp;'static Mutex&lt;BufReader&lt;StdinRaw&gt;&gt;,
}

//Stdin的Mutex.lock返回的借用类型结构
pub struct StdinLock&lt;'a&gt; {
    inner: MutexGuard&lt;'a, BufReader&lt;StdinRaw&gt;&gt;,
}

//获取标准输入
pub fn stdin() -&gt; Stdin {
    //在本文写作的时候SyncOnceCell已经改为OnceLock
    //但内容基本没有变化，SyncOnceCell是适配在多线程的情况下只完成
    //一次初始化的类型结构，是OnceCell的线程安全版本
    //INSTANCE保证一个进程内只有一个Stdin变量被初始化
    static INSTANCE: SyncOnceCell&lt;Mutex&lt;BufReader&lt;StdinRaw&gt;&gt;&gt; = SyncOnceCell::new();
    Stdin {
        //如果未初始化，则进行初始化，如果已经初始化，则获取Mutex的引用
        //并返回基于此引用创建的Stdin变量
        inner: INSTANCE.get_or_init(|| {
            Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin_raw()))
        }),
    }
}

impl Stdin {
    pub fn lock(&amp;self) -&gt; StdinLock&lt;'static&gt; {
        //对标准输入上锁，并获取临界变量
        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }
    }

    pub fn read_line(&amp;self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; {
        //StdinLock的适配器实现,见下面分析
        self.lock().read_line(buf)
    }

    //返回一个每次读入一行的迭代器
    pub fn lines(self) -&gt; Lines&lt;StdinLock&lt;'static&gt;&gt; {
        //StdinLock的适配器实现
        self.lock().lines()
    }
}

//实现Read trait,即StdinLock的适配器实现
impl Read for Stdin {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //直接是BufReader.read
        self.lock().read(buf)
    }
    
    //以下与read的实现类似，函数体略
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt;;
    fn is_read_vectored(&amp;self) -&gt; bool;
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt;; 
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; ;
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;()&gt; ;
}

//Mutex加锁后的返回
impl StdinLock&lt;'_&gt; {
    pub(crate) fn as_mut_buf(&amp;mut self) -&gt; &amp;mut BufReader&lt;impl Read&gt; {
        &amp;mut self.inner
    }
}

//以下是BufReader的Read trait的适配实现
impl Read for StdinLock&lt;'_&gt; {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //BufReader::read
        self.inner.read(buf)
    }

    //以下实现与read的实现形式基本类似，函数体略

    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt;;
    fn is_read_vectored(&amp;self) -&gt; bool;
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; ;
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; ;
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;()&gt; ;
}

//以下是BufReader的BufRead trait的适配实现
impl BufRead for StdinLock&lt;'_&gt; {
    //以下函数体略
    fn fill_buf(&amp;mut self) -&gt; io::Result&lt;&amp;[u8]&gt; ;
    fn consume(&amp;mut self, n: usize) ;
    fn read_until(&amp;mut self, byte: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; ;
    fn read_line(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; ;
}
<span class="boring">}</span></code></pre></pre>
<p>常用函数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//直接将输入源读入一个string
pub fn read_to_string&lt;R: Read&gt;(mut reader: R) -&gt; Result&lt;String&gt; {
    let mut buf = String::new();
    reader.read_to_string(&amp;mut buf)?;
    Ok(buf)
}
<span class="boring">}</span></code></pre></pre>
<p>一些其他的支持实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//标准输入/输出/错误不能形成OwnedFd, 但可以通过借用
//生成BorrowedFd
impl AsFd for io::Stdin {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        unsafe { BorrowedFd::borrow_raw(libc::STDIN_FILENO) }
    }
}

impl&lt;'a&gt; AsFd for io::StdinLock&lt;'a&gt; {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        unsafe { BorrowedFd::borrow_raw(libc::STDIN_FILENO) }
    }
}

//针对字节切片的Read trait实现
impl Read for &amp;[u8] {
    //本质上是完成两个字节数组的拷贝，
    //完成了字节数组的长度处理
    //函数执行后，self会更新反应内容已经读出
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //长度小的作为拷贝长度
        let amt = cmp::min(buf.len(), self.len());
        //将本身依据拷贝长度分成两个部分
        let (a, b) = self.split_at(amt);

        if amt == 1 {
            //提高效率
            buf[0] = a[0];
        } else {
            //将self拷贝到buf
            buf[..amt].copy_from_slice(a);
        }

        //更新self，此处易忽略
        *self = b;
        Ok(amt)
    }

    ...
    ...
}

<span class="boring">}</span></code></pre></pre>
<p>标准输入使用的代码例如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stdin = stdio::stdin();
let mut first_string = read_to_string(stdin);
let line = stdin.read_line(first_string);
<span class="boring">}</span></code></pre></pre>
<p>linux的向量读写相关类型结构:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/sys/unix/io.rs
//libc中的iovec的RUST封装,
//iovec用于多个缓存在一次读操作或写操作完成,
//减少将多个缓存移动到一个缓存造成的性能下降
//IoSlice通常用于写
//内存中IoSlice等同于iovec
#[repr(transparent)]
pub struct IoSlice&lt;'a&gt; {
    //libc中用于io读写的结构
    vec: iovec,
    //拥有读写的buf的所有权
    _p: PhantomData&lt;&amp;'a [u8]&gt;,
}

impl&lt;'a&gt; IoSlice&lt;'a&gt; {
    //简化libc中的iovec的结构生成代码
    pub fn new(buf: &amp;'a [u8]) -&gt; IoSlice&lt;'a&gt; {
        IoSlice {
            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },
            _p: PhantomData,
        }
    }

    //向前至还未使用的buf的第一个字节
    pub fn advance(&amp;mut self, n: usize) {
        if self.vec.iov_len &lt; n {
            panic!(&quot;advancing IoSlice beyond its length&quot;);
        }

        unsafe {
            //调整iovec参数
            self.vec.iov_len -= n;
            self.vec.iov_base = self.vec.iov_base.add(n);
        }
    }

    //生成读写的缓存buf
    pub fn as_slice(&amp;self) -&gt; &amp;[u8] {
        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }
    }
}

//通常应用于读入
pub struct IoSliceMut&lt;'a&gt; {
    vec: iovec,
    _p: PhantomData&lt;&amp;'a mut [u8]&gt;,
}

//见IoSlice的相关结构的分析
impl&lt;'a&gt; IoSliceMut&lt;'a&gt; {
    pub fn new(buf: &amp;'a mut [u8]) -&gt; IoSliceMut&lt;'a&gt; {
        IoSliceMut {
            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },
            _p: PhantomData,
        }
    }

    pub fn advance(&amp;mut self, n: usize) {
        if self.vec.iov_len &lt; n {
            panic!(&quot;advancing IoSliceMut beyond its length&quot;);
        }

        unsafe {
            self.vec.iov_len -= n;
            self.vec.iov_base = self.vec.iov_base.add(n);
        }
    }

    pub fn as_slice(&amp;self) -&gt; &amp;[u8] {
        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }
    }

    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [u8] {
        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }
    }
}

//IoSlice/IoSliceMut的使用如下
impl FileDesc {
    ...

    //一次读入多个buf
    pub fn read_vectored(&amp;self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        let ret = cvt(unsafe {
            libc::readv(
                self.as_raw_fd(),
                bufs.as_ptr() as *const libc::iovec,
                cmp::min(bufs.len(), max_iov()) as c_int,
            )
        })?;
        Ok(ret as usize)
    }

    //一次写入多个buf
    pub fn write_vectored(&amp;self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        let ret = cvt(unsafe {
            libc::writev(
                self.as_raw_fd(),
                bufs.as_ptr() as *const libc::iovec,
                cmp::min(bufs.len(), max_iov()) as c_int,
            )
        })?;
        Ok(ret as usize)
    }
    ...
}

//RUST对linux向量读写的扩展
//直接对操作系统的基础类型结构封装
pub struct IoSliceMut&lt;'a&gt;(sys::io::IoSliceMut&lt;'a&gt;);

unsafe impl&lt;'a&gt; Send for IoSliceMut&lt;'a&gt; {}
unsafe impl&lt;'a&gt; Sync for IoSliceMut&lt;'a&gt; {}


impl&lt;'a&gt; IoSliceMut&lt;'a&gt; {
    //见上面的linux的IoSliceMut的分析
    pub fn new(buf: &amp;'a mut [u8]) -&gt; IoSliceMut&lt;'a&gt; {
        IoSliceMut(sys::io::IoSliceMut::new(buf))
    }

    //见上面的linux的IoSliceMut的分析
    pub fn advance(&amp;mut self, n: usize) {
        self.0.advance(n)
    }

    pub fn advance_slices(bufs: &amp;mut &amp;mut [IoSliceMut&lt;'a&gt;], n: usize) {
        // 需要前移的IoSliceMut成员数目
        let mut remove = 0;
        // 计算前移的总体字节数
        let mut accumulated_len = 0;
        for buf in bufs.iter() {
            //是否应该前移到此成员
            if accumulated_len + buf.len() &gt; n {
                //找到
                break;
            } else {
                //否，找下一个
                accumulated_len += buf.len();
                remove += 1;
            }
        }

        //此处的逻辑是：
        //必须获得&amp;mut [IoSliceMut]的所有权，但不能用 = *bufs的方式实现
        //此时只能用replace来完成
        //要获得*bufs的所有权，只能用replace的方法，
        *bufs = &amp;mut replace(bufs, &amp;mut [])[remove..];
        if !bufs.is_empty() {
            bufs[0].advance(n - accumulated_len)
        }
    }
}

impl&lt;'a&gt; Deref for IoSliceMut&lt;'a&gt; {
    type Target = [u8];

    fn deref(&amp;self) -&gt; &amp;[u8] {
        self.0.as_slice()
    }
}

impl&lt;'a&gt; DerefMut for IoSliceMut&lt;'a&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [u8] {
        self.0.as_mut_slice()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上是Stdin相关的IO类型结构及其函数，方法</p>
<h2 id="rust标准库stdout代码分析"><a class="header" href="#rust标准库stdout代码分析">RUST标准库Stdout代码分析</a></h2>
<p>RUST实现了线程安全的标准输入类型结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Stdout {
    //可重入的内部可变性类型
    //LineWriter是缓存类型结构
    inner: Pin&lt;&amp;'static ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>ReentrantMutex&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>请参考前文
原始的标准输出目的IO对象类型StdoutRaw定义相关代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//linux系统的标准输出的类型结构
//因为标准输出的文件描述符不必关闭，
//所以此处用了单元类型
//路径: library/std/src/sys/unix/stdio.rs
pub struct Stdout(());

impl Stdout {
    //创建函数
    pub const fn new() -&gt; Stdout {
        Stdout(())
    }
}

//RUST对操作系统的扩展
//路径: library/std/src/io/stdio.rs
//此处stdio是sys::stdio
struct StdoutRaw(stdio::Stdout); 

//StdoutRaw的工厂函数
const fn stdout_raw() -&gt; StdoutRaw {
    StdoutRaw(stdio::Stdout::new())
}
<span class="boring">}</span></code></pre></pre>
<p>RUST专门为行输出设计的缓存类型IO类型结构<code>LineWriter&lt;W&gt;</code>定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//LineWriter是BufWriter的一个adapter
//针对行输出做出优化
pub struct LineWriter&lt;W: Write&gt; {
    inner: BufWriter&lt;W&gt;,
}

//输出缓存类型结构
pub struct BufWriter&lt;W: Write&gt; {
    //输出目的IO对象类型结构变量
    //本结构体拥有其所有权
    inner: W,
    //缓存
    buf: Vec&lt;u8&gt;,
    //是否在输出的过程中出现线程panic
    panicked: bool,
}
//BufWriter创建函数
impl&lt;W: Write&gt; BufWriter&lt;W&gt; {
    //基于输出目的IO对象变量创建缓存
    pub fn new(inner: W) -&gt; BufWriter&lt;W&gt; {
        //DEFAULT_BUF_SIZE是8*1024
        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)
    }

    //创建指定容量的BufWriter
    pub fn with_capacity(capacity: usize, inner: W) -&gt; BufWriter&lt;W&gt; {
        BufWriter { inner, buf: Vec::with_capacity(capacity), panicked: false }
    }
    ...
}
//LineWriter的创建函数
impl&lt;W: Write&gt; LineWriter&lt;W&gt; {
    pub fn new(inner: W) -&gt; LineWriter&lt;W&gt; {
        //创建一个缓存为1024的LineWriter
        LineWriter::with_capacity(1024, inner)
    }

    //创建指定容量的LineWriter
    pub fn with_capacity(capacity: usize, inner: W) -&gt; LineWriter&lt;W&gt; {
        //指定内部的BufWriter的容量
        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>所有的输出IO对象类型都必须实现Write trait,定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Write {
    //将buf写入输出目的，返回写入的字节数
    //此写操作可能阻塞，或返回错误，
    //此函数完成后，输出可能保存在操作系统的缓存中
    //需要调用flush才能确保真正的完成输出
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;

    //以向量的形式写
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt; {
        //默认不支持向量，使用write方法来进行模拟
        default_write_vectored(|b| self.write(b), bufs)
    }

    //是否支持向量写
    fn is_write_vectored(&amp;self) -&gt; bool {
        false
    }

    //确保缓存内的输出已经输出到输出目的
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    //确保缓存内的所有内容都已经写入输出目的
    fn write_all(&amp;mut self, mut buf: &amp;[u8]) -&gt; Result&lt;()&gt; {
        //主要因为单次write可能会在没有写完时返回
        //所以循环以确保写完后再返回
        while !buf.is_empty() {
            match self.write(buf) {
                //写入0字节代表未知错误
                Ok(0) =&gt; {
                    return Err(error::const_io_error!(
                        ErrorKind::WriteZero,
                        &quot;failed to write whole buffer&quot;,
                    ));
                }
                //写入n字节，则调整未写入的缓存
                Ok(n) =&gt; buf = &amp;buf[n..],
                //被中断打断的错误继续做循环
                Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
                //其他错误返回
                Err(e) =&gt; return Err(e),
            }
        }
        //已经写入了缓存的所有内容
        Ok(())
    }

    //vetor的write_all版本
    fn write_all_vectored(&amp;mut self, mut bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt; {
        //确保vector中有内容
        IoSlice::advance_slices(&amp;mut bufs, 0);
        //循环防止单次写入被中断
        while !bufs.is_empty() {
            match self.write_vectored(bufs) {
                Ok(0) =&gt; {
                    return Err(error::const_io_error!(
                        ErrorKind::WriteZero,
                        &quot;failed to write whole buffer&quot;,
                    ));
                }
                //写入则调整未写入的vetor
                Ok(n) =&gt; IoSlice::advance_slices(&amp;mut bufs, n),
                Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
                Err(e) =&gt; return Err(e),
            }
        }
        //已经完全写入
        Ok(())
    }

    //写入格式化内容
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        struct Adapter&lt;'a, T: ?Sized + 'a&gt; {
            inner: &amp;'a mut T,
            error: Result&lt;()&gt;,
        }

        impl&lt;T: Write + ?Sized&gt; fmt::Write for Adapter&lt;'_, T&gt; {
            fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
                match self.inner.write_all(s.as_bytes()) {
                    Ok(()) =&gt; Ok(()),
                    Err(e) =&gt; {
                        self.error = Err(e);
                        Err(fmt::Error)
                    }
                }
            }
        }

        let mut output = Adapter { inner: self, error: Ok(()) };
        //见“智能指针(四)”中关于fmt的章节
        match fmt::write(&amp;mut output, fmt) {
            Ok(()) =&gt; Ok(()),
            Err(..) =&gt; {
                // check if the error came from the underlying `Write` or not
                if output.error.is_err() {
                    output.error
                } else {
                    Err(error::const_io_error!(ErrorKind::Uncategorized, &quot;formatter error&quot;))
                }
            }
        }
    }

    //获取输入目的类型变量的引用
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized,
    {
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>io::sys::unix::Stdout的Write的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/sys/unix/stdio.rs
impl io::Write for Stdout {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        //标准输出文件不必关闭，因此不能调用FileDesc的drop
        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDOUT_FILENO)).write(buf) }
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        unsafe {
            ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDOUT_FILENO)).write_vectored(bufs)
        }
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        true
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>针对StdoutRaw的Read trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//即sys::Stdout的Write trait的adapter
impl Write for StdoutRaw {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        handle_ebadf(self.0.write(buf), buf.len())
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        let total = bufs.iter().map(|b| b.len()).sum();
        handle_ebadf(self.0.write_vectored(bufs), total)
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        self.0.is_write_vectored()
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        handle_ebadf(self.0.flush(), ())
    }

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        handle_ebadf(self.0.write_all(buf), ())
    }

    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;()&gt; {
        handle_ebadf(self.0.write_all_vectored(bufs), ())
    }

    fn write_fmt(&amp;mut self, fmt: fmt::Arguments&lt;'_&gt;) -&gt; io::Result&lt;()&gt; {
        handle_ebadf(self.0.write_fmt(fmt), ())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>BufWriter的相关实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;W: Write&gt; BufWriter&lt;W&gt; {
    //将缓存中的内容输出到内部的输入目的IO对象变量中,即使在调用此方法前，
    //缓存中的内容对调用者都被认为已经成功输出
    pub(in crate::io) fn flush_buf(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        struct BufGuard&lt;'a&gt; {
            //BufWriter中的buf
            buffer: &amp;'a mut Vec&lt;u8&gt;,
            //写入内部输出目的IO对象的字节数
            written: usize,
        }

        impl&lt;'a&gt; BufGuard&lt;'a&gt; {
            fn new(buffer: &amp;'a mut Vec&lt;u8&gt;) -&gt; Self {
                Self { buffer, written: 0 }
            }

            /// The unwritten part of the buffer
            fn remaining(&amp;self) -&gt; &amp;[u8] {
                &amp;self.buffer[self.written..]
            }

            /// 记录已经输出的字节数
            fn consume(&amp;mut self, amt: usize) {
                self.written += amt;
            }

            /// 是否所有的缓存数据都已经输出
            fn done(&amp;self) -&gt; bool {
                self.written &gt;= self.buffer.len()
            }
        }

        impl Drop for BufGuard&lt;'_&gt; {
            fn drop(&amp;mut self) {
                if self.written &gt; 0 {
                    //确保缓存删除已经输出的数据
                    self.buffer.drain(..self.written);
                }
            }
        }

        //利用BufGuard来更新self.buf
        let mut guard = BufGuard::new(&amp;mut self.buf);
        //缓存如果还有数据则一直循环
        while !guard.done() {
            //如果写的过程遇到线程panic，
            //此处提取做标记
            self.panicked = true;
            //调用内部输出目的对象完成写
            let r = self.inner.write(guard.remaining());
            //清除panic标记
            self.panicked = false;

            match r {
                //没有输出内容
                Ok(0) =&gt; {
                    //必须返回IO出错，因为缓存的内容已经被
                    //认为写成功
                    return Err(io::const_io_error!(
                        ErrorKind::WriteZero,
                        &quot;failed to write the buffered data&quot;,
                    ));
                }
                //buffer中需要反映已经写出的内容
                Ok(n) =&gt; guard.consume(n),
                Err(ref e) if e.kind() == io::ErrorKind::Interrupted =&gt; {}
                Err(e) =&gt; return Err(e),
            }
        }
        Ok(())
    }

    //将字节切片写入缓存
    pub(super) fn write_to_buf(&amp;mut self, buf: &amp;[u8]) -&gt; usize {
        //得到缓存空闲空间,并取空闲空间与切片长度小者
        let available = self.spare_capacity();
        let amt_to_buffer = available.min(buf.len());

        unsafe {
            //将字节切片写入缓存
            self.write_to_buffer_unchecked(&amp;buf[..amt_to_buffer]);
        }

        //返回写入字节
        amt_to_buffer
    }

    //获得内部输出目的对象的引用
    pub fn get_ref(&amp;self) -&gt; &amp;W {
        &amp;self.inner
    }

    //获得内部输出目的对象的可变引用
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut W {
        &amp;mut self.inner
    }

    //获得内部缓存的字节切片引用
    pub fn buffer(&amp;self) -&gt; &amp;[u8] {
        &amp;self.buf
    }

    //获得内部缓存的字节切片的可变引用
    pub(in crate::io) fn buffer_mut(&amp;mut self) -&gt; &amp;mut Vec&lt;u8&gt; {
        &amp;mut self.buf
    }

    //缓存总容量
    pub fn capacity(&amp;self) -&gt; usize {
        self.buf.capacity()
    }

    //消费self，获取内部输出目的IO对象
    pub fn into_inner(mut self) -&gt; Result&lt;W, IntoInnerError&lt;BufWriter&lt;W&gt;&gt;&gt; {
        //需要先将缓存内容全部输出
        match self.flush_buf() {
            Err(e) =&gt; Err(IntoInnerError::new(self, e)),
            //此处获得self.buf的所有权，然后生命周期终结
            Ok(()) =&gt; Ok(self.into_parts().0),
        }
    }

    //into_inner的支持方法，处理panic
    pub fn into_parts(mut self) -&gt; (W, Result&lt;Vec&lt;u8&gt;, WriterPanicked&gt;) {
        //获取self.buf的所有权
        let buf = mem::take(&amp;mut self.buf);
        //将buf所有权返回，由调用者处理
        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };

        //获取self.inner的所有权
        let inner = unsafe { ptr::read(&amp;mut self.inner) };
        //不调用self的drop，防止对self.inner的drop调用
        mem::forget(self);

        (inner, buf)
    }

    #[cold]
    #[inline(never)]
    fn write_cold(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        //判断输出是否大于缓存可用空间
        if buf.len() &gt; self.spare_capacity() {
            //大于，则先将缓存输出
            self.flush_buf()?;
        }

        //再次判断是否大于缓存空间
        if buf.len() &gt;= self.buf.capacity() {
            //大于,则直接输出到内部IO对象
            self.panicked = true;
            let r = self.get_mut().write(buf);
            self.panicked = false;
            r
        } else {
            //不大于，则输入到内部的缓存中
            unsafe {
                self.write_to_buffer_unchecked(buf);
            }

            Ok(buf.len())
        }
    }

    #[cold]
    #[inline(never)]
    fn write_all_cold(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        if buf.len() &gt; self.spare_capacity() {
            self.flush_buf()?;
        }

        if buf.len() &gt;= self.buf.capacity() {
            self.panicked = true;
            //直接调用的情况下必须用write_all
            let r = self.get_mut().write_all(buf);
            self.panicked = false;
            r
        } else {
            unsafe {
                self.write_to_buffer_unchecked(buf);
            }

            Ok(())
        }
    }

    unsafe fn write_to_buffer_unchecked(&amp;mut self, buf: &amp;[u8]) {
        debug_assert!(buf.len() &lt;= self.spare_capacity());
        //就是直接做拷贝
        let old_len = self.buf.len();
        let buf_len = buf.len();
        let src = buf.as_ptr();
        let dst = self.buf.as_mut_ptr().add(old_len);
        ptr::copy_nonoverlapping(src, dst, buf_len);
        //拷贝完毕后设置内部的buf参数
        self.buf.set_len(old_len + buf_len);
    }

    fn spare_capacity(&amp;self) -&gt; usize {
        //获取内部可用空间
        self.buf.capacity() - self.buf.len()
    }
}


//实现Write trait
impl&lt;W: Write&gt; Write for BufWriter&lt;W&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        //判断输出的字符切片长度是否小于缓存空间
        if buf.len() &lt; self.spare_capacity() {
            //小于，直接写入缓存
            unsafe {
                self.write_to_buffer_unchecked(buf);
            }

            Ok(buf.len())
        } else {
            //否则，调用write_cold
            self.write_cold(buf)
        }
    }

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        if buf.len() &lt; self.spare_capacity() {
            unsafe {
                self.write_to_buffer_unchecked(buf);
            }

            Ok(())
        } else {
            //调用write_all_code
            self.write_all_cold(buf)
        }
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        //判断内部IO对象是否支持向量写
        if self.get_ref().is_write_vectored() {
            //支持,
            // We have to handle the possibility that the total length of the buffers overflows
            // `usize` (even though this can only happen if multiple `IoSlice`s reference the
            // same underlying buffer, as otherwise the buffers wouldn't fit in memory). If the
            // computation overflows, then surely the input cannot fit in our buffer, so we forward
            // to the inner writer's `write_vectored` method to let it handle it appropriately.
            //获取总的字节长度
            let saturated_total_len =
                bufs.iter().fold(0usize, |acc, b| acc.saturating_add(b.len()));

            //总字节长度是否大于可用空间
            if saturated_total_len &gt; self.spare_capacity() {
                self.flush_buf()?;
            }

            //再次判断是否能用缓存
            if saturated_total_len &gt;= self.buf.capacity() {
                //不能，则直接用write_vectored输出
                self.panicked = true;
                let r = self.get_mut().write_vectored(bufs);
                self.panicked = false;
                r
            } else {
                //否则，将内容写入缓存
                unsafe {
                    bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));
                };

                Ok(saturated_total_len)
            }
        } else {
            //不支持向量写
            let mut iter = bufs.iter();
            //找到第一个不为空的IoSlice
            let mut total_written = if let Some(buf) = iter.by_ref().find(|&amp;buf| !buf.is_empty()) {
                if buf.len() &gt; self.spare_capacity() {
                    self.flush_buf()?;
                }
                if buf.len() &gt;= self.buf.capacity() {
                    // so it's better to write it directly, bypassing the buffer.
                    self.panicked = true;
                    let r = self.get_mut().write(buf);
                    self.panicked = false;
                    //return的情况下，不必保证两个分支
                    //类型一致
                    return r;
                } else {
                    unsafe {
                        //写入buf
                        self.write_to_buffer_unchecked(buf);
                    }

                    buf.len()
                }
            } else {
                return Ok(0);
            };
            debug_assert!(total_written != 0);
            //iter位置已经移动
            for buf in iter {
                //判断buf是否有足够空间
                if buf.len() &lt;= self.spare_capacity() {
                    unsafe {
                        self.write_to_buffer_unchecked(buf);
                    }

                    total_written += buf.len();
                } else {
                    //没有，则结束
                    break;
                }
            }
            //返回已经写入的总长度
            Ok(total_written)
        }
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        true
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        //先完成buf写入内部IO对象，再调用内部Io对象的flush方法。
        self.flush_buf().and_then(|()| self.get_mut().flush())
    }
}

//Seek trait实现
impl&lt;W: Write + Seek&gt; Seek for BufWriter&lt;W&gt; {
    fn seek(&amp;mut self, pos: SeekFrom) -&gt; io::Result&lt;u64&gt; {
        //先将缓存内容写入
        self.flush_buf()?;
        //再调用底层IO对象的seek
        self.get_mut().seek(pos)
    }
}

impl&lt;W: Write&gt; Drop for BufWriter&lt;W&gt; {
    fn drop(&amp;mut self) {
        if !self.panicked {
            //生命周期终止时将buf写入内部输出IO对象
            let _r = self.flush_buf();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>LineWrite的所有实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;W: Write&gt; LineWriter&lt;W&gt; {
    //获取内部IO对象的引用
    pub fn get_ref(&amp;self) -&gt; &amp;W {
        self.inner.get_ref()
    }

    //获取内部IO对象的可变引用
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut W {
        self.inner.get_mut()
    }

    //消费掉self，获得内部IO对象的引用
    pub fn into_inner(self) -&gt; Result&lt;W, IntoInnerError&lt;LineWriter&lt;W&gt;&gt;&gt; {
        self.inner.into_inner().map_err(|err| err.new_wrapped(|inner| LineWriter { inner }))
    }
}

//Write trait实现， 对BufReader的Adapter
impl&lt;W: Write&gt; Write for LineWriter&lt;W&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        LineWriterShim::new(&amp;mut self.inner).write(buf)
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        self.inner.flush()
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        LineWriterShim::new(&amp;mut self.inner).write_vectored(bufs)
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        self.inner.is_write_vectored()
    }

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        LineWriterShim::new(&amp;mut self.inner).write_all(buf)
    }

    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;()&gt; {
        LineWriterShim::new(&amp;mut self.inner).write_all_vectored(bufs)
    }

    fn write_fmt(&amp;mut self, fmt: fmt::Arguments&lt;'_&gt;) -&gt; io::Result&lt;()&gt; {
        LineWriterShim::new(&amp;mut self.inner).write_fmt(fmt)
    }
}

//支持类型LineWriterShim
pub struct LineWriterShim&lt;'a, W: Write&gt; {
    buffer: &amp;'a mut BufWriter&lt;W&gt;,
}

impl&lt;'a, W: Write&gt; LineWriterShim&lt;'a, W&gt; {
    pub fn new(buffer: &amp;'a mut BufWriter&lt;W&gt;) -&gt; Self {
        Self { buffer }
    }

    fn inner(&amp;self) -&gt; &amp;W {
        self.buffer.get_ref()
    }

    fn inner_mut(&amp;mut self) -&gt; &amp;mut W {
        self.buffer.get_mut()
    }

    fn buffered(&amp;self) -&gt; &amp;[u8] {
        self.buffer.buffer()
    }

    fn flush_if_completed_line(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        //判断buf的尾部字符
        match self.buffered().last().copied() {
            //如果是行结束符，将缓存输出
            Some(b'\n') =&gt; self.buffer.flush_buf(),
            _ =&gt; Ok(()),
        }
    }
}

impl&lt;'a, W: Write&gt; Write for LineWriterShim&lt;'a, W&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        //查找buf中的分行符
        let newline_idx = match memchr::memrchr(b'\n', buf) {
            //没找到
            None =&gt; {
                //将buf中可能的行输出
                self.flush_if_completed_line()?;
                //将内容写入缓存
                return self.buffer.write(buf);
            }
            //找到，设置新行的启动位置
            Some(newline_idx) =&gt; newline_idx + 1,
        };

        //输出缓存内容
        self.buffer.flush_buf()?;

        //获取本行的内容
        let lines = &amp;buf[..newline_idx];

        //本行内容直接写入底层的IO对象
        let flushed = self.inner_mut().write(lines)?;

        //判断是否写入了内容
        if flushed == 0 {
            //没有写入，返回0
            return Ok(0);
        }

        //判断本行是否完全输出，tail为需要写入缓存的字节切片
        let tail = if flushed &gt;= newline_idx {
            //完全输出,tail为没有输出的字节切片
            &amp;buf[flushed..]
        } else if newline_idx - flushed &lt;= self.buffer.capacity() {
            //没有完全输出，且未输出的内容小于缓存容量
            //tail为本行没有输出的内容
            &amp;buf[flushed..newline_idx]
        } else {
            //没有完全输出，且未输出内容大于缓存容量
            //tail为本行缓存容量的字节切片
            let scan_area = &amp;buf[flushed..];
            let scan_area = &amp;scan_area[..self.buffer.capacity()];
            match memchr::memrchr(b'\n', scan_area) {
                Some(newline_idx) =&gt; &amp;scan_area[..newline_idx + 1],
                None =&gt; scan_area,
            }
        };

        //将tail写入缓存
        let buffered = self.buffer.write_to_buf(tail);
        Ok(flushed + buffered)
    }

    //adapter
    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        self.buffer.flush()
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        //判断是否支持向量读写
        if !self.is_write_vectored() {
            //不支持，将第一个向量写入self并返回
            return match bufs.iter().find(|buf| !buf.is_empty()) {
                Some(buf) =&gt; self.write(buf),
                None =&gt; Ok(0),
            };
        }

        //找到buf中最后一个换行符
        //最后一个换行符前的数据都可以输出，
        //符合行输出的规则
        let last_newline_buf_idx = bufs
            .iter()
            .enumerate()
            .rev()
            .find_map(|(i, buf)| memchr::memchr(b'\n', buf).map(|_| i));

        
        let last_newline_buf_idx = match last_newline_buf_idx {
            //没有换行符 
            None =&gt; {
                //先输出可能的行
                self.flush_if_completed_line()?;
                //将bufs写入内部缓存
                return self.buffer.write_vectored(bufs);
            }
            //有，获得切片下标
            Some(i) =&gt; i,
        };

        //先将缓存已有内容输出
        self.buffer.flush_buf()?;

        //将切片分为带输出及存入缓存的两个部分
        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);

        //直接调用底层IO对象将内容输出,此处认为换行应该是IoSlice的尾部？
        let flushed = self.inner_mut().write_vectored(lines)?;

        //如果无法输出
        if flushed == 0 {
            //通知调用者
            return Ok(0);
        }

        //判断是否全部的slice都已经输出
        let lines_len = lines.iter().map(|buf| buf.len()).sum();
        if flushed &lt; lines_len {
            //没有，则返回输出长度
            return Ok(flushed);
        }

        //将剩余的内容写入缓存中
        let buffered: usize = tail
            .iter()
            .filter(|buf| !buf.is_empty())
            .map(|buf| self.buffer.write_to_buf(buf))
            .take_while(|&amp;n| n &gt; 0)
            .sum();

        Ok(flushed + buffered)
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        self.inner().is_write_vectored()
    }

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        match memchr::memrchr(b'\n', buf) {
            //没有换行符
            None =&gt; {
                //将buffer的行输出，然后将内容写入缓存
                self.flush_if_completed_line()?;
                self.buffer.write_all(buf)
            }
            //有换行符
            Some(newline_idx) =&gt; {
                //将换行符前的内容都输出，换行符后的内容写入缓存
                let (lines, tail) = buf.split_at(newline_idx + 1);

                if self.buffered().is_empty() {
                    self.inner_mut().write_all(lines)?;
                } else {
                    self.buffer.write_all(lines)?;
                    self.buffer.flush_buf()?;
                }

                self.buffer.write_all(tail)
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上完成了所有RUST的对外类型结构Stdout的相关类型的代码分析。现在回到Stdout本身：
再次看一下Stdout的类型结构的相关实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/stdio.rs
pub struct Stdout {
    //可重入的内部可变性类型
    //LineWriter是缓存类型结构
    inner: Pin&lt;&amp;'static ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;&gt;,
}
//Mutex返回的借用结构
pub struct StdoutLock&lt;'a&gt; {
    inner: ReentrantMutexGuard&lt;'a, RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;,
}

//保证Stdout在一个进程中只初始化一次
static STDOUT: SyncOnceCell&lt;ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;&gt; = SyncOnceCell::new();

pub fn stdout() -&gt; Stdout {
    Stdout {
        //如果没有初始化，则进行初始化，如果已经初始化，则加锁，获得引用
        //并构建Stdout
        inner: Pin::static_ref(&amp;STDOUT).get_or_init_pin(
            || unsafe { ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))) },
            |mutex| unsafe { mutex.init() },
        ),
    }
}

pub fn cleanup() {
    if let Some(instance) = STDOUT.get() {
        if let Some(lock) = Pin::static_ref(instance).try_lock() {
            //将前个LineWriter做drop操作
            //生成一个缓存空间为0的LineWriter
            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());
        }
    }
}

impl Stdout {
    //获得一个借用
    pub fn lock(&amp;self) -&gt; StdoutLock&lt;'static&gt; {
        //创建StdoutLock
        StdoutLock { inner: self.inner.lock() }
    }
}

//Write trait实现，
//是StdoutLock的adapter
//但是有一个线程安全操作
impl Write for &amp;Stdout {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        self.lock().write(buf)
    }
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; ;
    fn is_write_vectored(&amp;self) -&gt; bool ;
    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; ;
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; ;
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;()&gt; ;
    fn write_fmt(&amp;mut self, args: fmt::Arguments&lt;'_&gt;) -&gt; io::Result&lt;()&gt; ;
}

//LineWriter的adapter
impl Write for StdoutLock&lt;'_&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        self.inner.borrow_mut().write(buf)
    }
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; ;
    fn is_write_vectored(&amp;self) -&gt; bool ;
    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; ;
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; ;
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;()&gt; ;
}
<span class="boring">}</span></code></pre></pre>
<p>Stderr与Stdout类似，请自行分析。</p>
<p>以下可以作为stdout的使用例。是测试时使用的线程局部信息输出流的实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//线程局部流
type LocalStream = Arc&lt;Mutex&lt;Vec&lt;u8&gt;&gt;&gt;;

//线程局部流定义
thread_local! {
    static OUTPUT_CAPTURE: Cell&lt;Option&lt;LocalStream&gt;&gt; = {
        Cell::new(None)
    }
}

//已经使用了OUTPUT_CAPTURE机制
static OUTPUT_CAPTURE_USED: AtomicBool = AtomicBool::new(false);

//设置输出的缓存
pub fn set_output_capture(sink: Option&lt;LocalStream&gt;) -&gt; Option&lt;LocalStream&gt; {
    if sink.is_none() &amp;&amp; !OUTPUT_CAPTURE_USED.load(Ordering::Relaxed) {
        // OUTPUT_CAPTURE is definitely None since OUTPUT_CAPTURE_USED is false.
        return None;
    }
    OUTPUT_CAPTURE_USED.store(true, Ordering::Relaxed);
    OUTPUT_CAPTURE.with(move |slot| slot.replace(sink))
}

//测试信息打印函数
fn print_to&lt;T&gt;(args: fmt::Arguments&lt;'_&gt;, global_s: fn() -&gt; T, label: &amp;str)
where
    T: Write,
{
    if OUTPUT_CAPTURE_USED.load(Ordering::Relaxed)
        &amp;&amp; OUTPUT_CAPTURE.try_with(|s| {
            s.take().map(|w| {
                let _ = w.lock().unwrap_or_else(|e| e.into_inner()).write_fmt(args);
                s.set(Some(w));
            })
        }) == Ok(Some(()))
    {
        // Successfully wrote to capture buffer.
        return;
    }

    if let Err(e) = global_s().write_fmt(args) {
        panic!(&quot;failed printing to {label}: {e}&quot;);
    }
}

//向标准输出打印
pub fn _print(args: fmt::Arguments&lt;'_&gt;) {
    print_to(args, stdout, &quot;stdout&quot;);
}
//向标准错误打印
pub fn _eprint(args: fmt::Arguments&lt;'_&gt;) {
    print_to(args, stderr, &quot;stderr&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="网络io"><a class="header" href="#网络io">网络IO</a></h2>
<p>因为异步编程成为网络IO的共识，而异步框架如tokio等对网络IO库做了重写，标准库中的网络IO显得不再那么重要，本书将省略网络IO的分析。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="19-std库(八)RUST文件系统.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="21-RUST的异步编程.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="19-std库(八)RUST文件系统.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="21-RUST的异步编程.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
