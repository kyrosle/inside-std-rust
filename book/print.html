<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-inside-std-book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="引言.html">引言</a></li><li class="chapter-item expanded affix "><a href="01-RUST库体系概述.html">RUST库体系概述</a></li><li class="chapter-item expanded affix "><a href="02-内存.html">内存</a></li><li class="chapter-item expanded affix "><a href="03-固有函数库及基础类型.html">固有函数库及基础类型</a></li><li class="chapter-item expanded affix "><a href="04-基础Trait.html">基础Trait</a></li><li class="chapter-item expanded affix "><a href="05-Iterator.html">Iterator</a></li><li class="chapter-item expanded affix "><a href="06-基本类型续.html">基本类型续</a></li><li class="chapter-item expanded affix "><a href="07-内部可变性类型.html">内部可变性类型</a></li><li class="chapter-item expanded affix "><a href="08-智能指针类型(一).html">智能指针类型(一)</a></li><li class="chapter-item expanded affix "><a href="09-智能指针类型(二).html">智能指针类型(二)</a></li><li class="chapter-item expanded affix "><a href="10-智能指针类型(三).html">智能指针类型(三)</a></li><li class="chapter-item expanded affix "><a href="11-智能指针类型(四).html">智能指针类型(四)</a></li><li class="chapter-item expanded affix "><a href="12-std库(一)FFI及内存管理.html">std库(一)FFI及内存管理</a></li><li class="chapter-item expanded affix "><a href="13-std库(二)文件描述符及进程管理.html">std库(二)文件描述符及进程管理</a></li><li class="chapter-item expanded affix "><a href="14-std库(三)线程间锁通信.html">std库(三)线程间锁通信</a></li><li class="chapter-item expanded affix "><a href="15-std库(四)线程临界区类型.html">std库(四)线程临界区类型</a></li><li class="chapter-item expanded affix "><a href="16-std库(五)线程管理.html">std库(五)线程管理</a></li><li class="chapter-item expanded affix "><a href="17-std库(六)mpsc通信.html">std库(六)mpsc通信</a></li><li class="chapter-item expanded affix "><a href="18-std库(七)RUST的RUNTIME.html">std库(七)RUST的RUNTIME</a></li><li class="chapter-item expanded affix "><a href="19-std库(八)RUST文件系统.html">std库(八)RUST文件系统</a></li><li class="chapter-item expanded affix "><a href="20-std库(九)RUST的IO.html">std库(九)RUST的IO</a></li><li class="chapter-item expanded affix "><a href="21-RUST的异步编程.html">RUST的异步编程</a></li><li class="chapter-item expanded affix "><a href="后记.html">后记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-inside-std-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="inside-rust-std-library"><a class="header" href="#inside-rust-std-library">inside-rust-std-library</a></h1>
<p>本书主要对RUST的标准库代码进行分析。<br />
本书尽可能给读者找出一条标准库代码的阅读脉络。同时，分析不仅仅针对代码的功能，也针对代码背后的需求及若干代码设计的思路。<br />
C语言精通的标志是对指针的精通。RUST的裸指针也是RUST的最基础及最核心的难点之一。 
所以，将裸指针及相关的内存模块作为代码分析的起始点，熟悉了裸指针及内存，自然也就对所有权，借用，生命周期的本质有了深刻的理解，RUST语言的最难关便过了。<br />
泛型是RUST不可分割的语法之一，而对于其他语言，没有泛型不影响语言的使用。泛型及基于trait的泛型约束是RUST的另一个代码基础。<br />
针对基本类型的分析，可以看到RUST利用trait语法使之具备了无限的扩展性，这是RUST更有表现力的语法能力的展现。<br />
Option<T>/Result&lt;T,E&gt;等类型实际完全是由标准库定义的，并不是RUST语言最底层的基本内容，可以从代码分析中发现这一点。<br />
所有的运算符都可以重载，且可以跨越类型重载，RUST的运算符重载揭示了RUST很多的编码奥秘及技巧。<br />
Iterator加闭包是函数式编程的基础构架，Iterator的适配器构成了函数式编程的基础设施，RUST完整的实现了这些内容，并且几乎为每个类型都实现了迭代器，并尽可能的为函数式编程做好了准备。<br />
Cell<T>/RefCell<T>/Pin<T>/Lazy<T>代码证明了在RUST的基础语法下，如何创造性的解决问题。<br />
Box<T>/RawVec<T>是两个堆内存申请的基本结构，善用这两个结构，除非写内存管理，基本上就不必再接触底层的堆内存申请及释放。<br />
每一个智能指针实际上也是RUST对经典的数据结构实现的精妙例程。<br />
RUST对不同操作系统的适配让程序员不必象C那样再重复的耗费精力并且还沾沾自喜于此份工作。<br />
仅支持异步编程的async/await，Future也体现了RUST的作最基础的工作的态度。<br />
...<br />
...</p>
<p>(This book focuses on the analysis of RUST's standard library code.<br />
This book is as far as possible to find a reading context for the standard library code. At the same time, the analysis is not only for the function of the code, but also for the requirements behind the code and some ideas of code design.<br />
The hallmark of C proficiency is mastery of pointer. The raw pointer in RUST is also one of the most basic and core difficulties of RUST. Therefor, the raw pointer and  associated memory modules are used as the starting point for code analysis, and the familiarity with raw pointer and memory naturally leads to a profound understanding of the nature of ownership, borrowing, and the life cycle. The hardest part of RUST is over.<br />
Generics are an integral part of RUST's syntax, and for other languages, the absence of generics does not affect language use. Generics and their trait - based generic constraints are another code base of RUST.<br />
Based on the analysis of primitive types, it can be seen that RUST makes use of trait syntax to make primitive types infinitely extensible, which is a demonstration of RUST's more expressive syntax ability.<br />
Types such as Option<T>/Result&lt;T, E&gt; are actually defined entirely by the standard library and are not the basic content of the lowest level of the RUST language, as you can see from code analysis.<br />
All operators can be overloaded and can cross type overloading. Operator overloading in RUST reveals many of RUST's coding secrets and tricks.<br />
Iterator plus closures are the foundation of functional programming. The adapters of Iterator make up the infrastructure of functional programming. RUST implements them completely, implementing iterators for almost every type and preparing them as well as possible for functional programming.<br />
The Cell/RefCell/Pin/Lazy source code demonstrates how creative problem solving can be done within RUST's basic syntax.<br />
Box/RawVec are the two basic structures of heap memory allocation and freeing.<br />
Each smart pointer is actually an elegant routine of RUST's implementation of classical data structures.<br />
RUST's adaptation of different operating systems saves programmers from the repetitive effort and complacency of C.<br />
Supporting only async/await for asynchronous programming, Future also embodies RUST's attitude of doing the most basic work.<br />
... 
...
)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引言"><a class="header" href="#引言">引言</a></h1>
<p>RUST无疑是编程语言史对资深程序员最不友好的高级语言(对初学者是友好的)，在仅依靠静态编译的前提下实现一门安全的编程语言，这是必须付出的代价。无论如何，成为一门编程语言的老手的最佳办法就是深入分析，学习，理解优秀的代码，那RUST标准库的代码必然是不可绕过的最佳教材。另外，掌握RUST也必然意味对标准库的熟练掌握，深入了解标准库接口后面的秘密无疑能帮助我们更好的掌握如何使用标准库。</p>
<h2 id="本书目的"><a class="header" href="#本书目的">本书目的</a></h2>
<p>本书主要是对RUST标准库代码进行分析，希望通过对标准库的学习，分析，能让读者对RUST代码的编写技巧，规则有更好的理解，为读者成为RUST老手奠定基础。</p>
<h2 id="目标读者"><a class="header" href="#目标读者">目标读者</a></h2>
<p>本书不适合初级程序员，本书针对的最佳对象是资深的C/C++程序员, 转学RUST。本书也适合已经采用RUST编写了一段时间程序，但希望对RUST有更深的了解，尤其是希望进行操作系统内核编程或通用编程框架编程的程序员。对于Java/python/go等语言的资深程序员，本书可以作为RUST与其他语言相比较的一个参考。阅读本书之前，读者最好已经学习过官方教程，中文翻译版链接如下<a href="https://rustwiki.org/zh-CN/book/">RUST程序设计语言</a>。本书不是标准库参考手册，如需要参考手册，中文翻译版链接如下<a href="https://rustwiki.org/zh-CN/std/">RUST标准库参考手册</a>。本书难度应该属于死灵书级别，中文翻译版死灵书链接如下<a href="https://nomicon.purewhite.io/">RUST秘典</a></p>
<h2 id="本书约定"><a class="header" href="#本书约定">本书约定</a></h2>
<p>对于代码的解析，以代码中文注释的方式放在本书的代码中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust标准库体系概述"><a class="header" href="#rust标准库体系概述">RUST标准库体系概述</a></h1>
<p>RUST语言的设计目标是能编写操作系统内核的系统编程语言。使用静态编译，不采用GC机制，保证开发出的应用极高性能；具备现代编程语言的高效率语法, 并在编译阶段就保证内存安全，并发安全，分支安全等安全性。
现代高级语言的标准库是语言的一个紧密的组成部分，标准库负责语言众多关键特性实现。RUST的库也是如此，但与其他采用GC方案的语言不同，其他语言编程目标是在操作系统之上运行的用户态程序，只需要考虑一种模型。RUST则需要考虑操作系统内核与用户态两种模型。C语言在解决这个问题的方法是只提供用户态的标准库，操作系统内核的库由各操作系统自行实现。
RUST的现代语言特性决定了标准库无法象C语言那样把操作系统内核及用户态程序区分成完全独立的两个部分，所以只能更细致的设计，做模块化的处理。RUST标准库体系分为三个模块：语言核心库--core; alloc库；用户态 std库。</p>
<h2 id="core库"><a class="header" href="#core库">core库</a></h2>
<p>RUST语言核心库，适用于操作系统内核及用户态，包括RUST的基础类型，基本Trait, 类型行为函数，其他函数等内容。core库是硬件架构和操作系统无关的可移植库。主要内容：</p>
<h3 id="编译器内置intrinsics函数"><a class="header" href="#编译器内置intrinsics函数">编译器内置intrinsics函数</a></h3>
<p>包括内存操作函数，算数函数，位操作函数，原子变量操作函数等， 这些函数通常与CPU硬件架构紧密相关，且一般需要汇编来提供最佳性能。 intrinsic函数实际上也是对CPU指令的屏蔽层。</p>
<h3 id="基本trait"><a class="header" href="#基本trait">基本Trait</a></h3>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/rusts-standard-library-traits.html">推荐这个链接</a>
本节给出core库中的Trait一览</p>
<h4 id="运算符opstrait"><a class="header" href="#运算符opstrait">运算符（ops）Trait</a></h4>
<p>主要是各种用于表达式的RUST符号重载，包括算数计算符号，逻辑运算符号，位操作符号，解引用(*)符号, [index]数组下标符号， <code>../start..end/start../start..=end/..end/..=end</code> Range符号， ?号，||{..}闭包符号等，RUST原则是所有的运算符号都要能重载, 所以所有运算操作都定义了重载Trait。</p>
<h4 id="编译器内部实现的派生宏-trait"><a class="header" href="#编译器内部实现的派生宏-trait">编译器内部实现的派生宏 Trait</a></h4>
<p>如果类型结构中的每一个变量都实现了该Trait, 则此结构的该Trait可通过派生宏实现.<br />
Clone, Copy: Copy浅复制，Clone提供深复制.<br />
Debug: 类型的格式化输出.<br />
Default: 类型的default值<br />
Eq, Ord，PartialEQ, PartialOrd: 实现后可以对类型的变量做大,小,相等比较.<br />
Sync, Send: 实现此Trait的类型变量的引用可以安全在线程间共享.<br />
Hash: 实现结构的整体Hash值，这个Trait Hash是因为复杂才被加入，意义没有前面的大</p>
<h4 id="iterator"><a class="header" href="#iterator">Iterator</a></h4>
<p>迭代器，RUST基础构架之一，也是RUST所有学习资料的重点。不赘述，本书后面章节将关注其代码实现。</p>
<h4 id="类型转换trait"><a class="header" href="#类型转换trait">类型转换Trait</a></h4>
<p>AsRef， AsMut, From，Into，TryFrom，TryInto, FloatToInt, FromStr</p>
<h4 id="字符串trait"><a class="header" href="#字符串trait">字符串Trait</a></h4>
<p>此处略，后面章节单独做分析</p>
<h4 id="异步编程trait"><a class="header" href="#异步编程trait">异步编程Trait</a></h4>
<p>此处略，后面章节单独分析</p>
<h4 id="内存相关trait"><a class="header" href="#内存相关trait">内存相关Trait</a></h4>
<p>此处略，后面章节单独分析</p>
<h3 id="基本数据类型"><a class="header" href="#基本数据类型">基本数据类型</a></h3>
<p>包括整数类型，浮点类型，布尔类型，字符类型，单元类型，内容主要是实现运算符Trait, 类型转换Trait, 派生宏Trait等，字符类型包括对unicode，ascii的不同编码的处理。整数类型有大小端变换的处理。</p>
<h3 id="数组切片及range"><a class="header" href="#数组切片及range">数组、切片及Range</a></h3>
<p>主要为类型结构对Iterator Trait, 运算符Trait, 类型转换Trait, 派生宏Trait的实现。</p>
<h3 id="optionresultmarker等关键的语言级别enum类型"><a class="header" href="#optionresultmarker等关键的语言级别enum类型">Option/Result/Marker等关键的语言级别Enum类型</a></h3>
<p>RUST安全特性的重点，也是各种学习资料的重点，不赘述，后面章节将关注其一些代码实现</p>
<h3 id="rust内存相关类型及内容"><a class="header" href="#rust内存相关类型及内容">RUST内存相关类型及内容</a></h3>
<p>alloc, mem, ptr等模块，RUST的内存操作，后继章节重点详述。</p>
<h3 id="rust字符串相关库"><a class="header" href="#rust字符串相关库">RUST字符串相关库</a></h3>
<p>字符串str，string，fmt, panic, debug, log等</p>
<h3 id="rust时间库"><a class="header" href="#rust时间库">RUST时间库</a></h3>
<p>Duration等</p>
<h2 id="alloc库"><a class="header" href="#alloc库">alloc库</a></h2>
<p>alloc库主要实现需要进行动态堆内存申请的智能指针类型，集合类型及他们的行为，函数，Trait等内容，仅建立在core库模块之上。std会对alloc模块库的内容做重新的封装。alloc库适用于操作系统内核及用户态程序。
包括：
1.基本内存申请；Allocator Trait; Allocator的实现结构Global
2.基础智能指针：Box<T>, Rc<T>, 
3.动态数组内存类型: RawVec<T>, Vec<T>
4.字符串类型：&amp;str, String
5.并发编程指针类型: Arc<T>
6.指针内访问类型: Cell<T>, RefCell<T>
还有些其他类型，一般仅在标准库内部使用，后文在需要的时候再介绍及分析。</p>
<h2 id="std库"><a class="header" href="#std库">std库</a></h2>
<p>std是在操作系统支撑下运行的只适用于用户态程序的库，core库实现的内容基本在std库也有对应的实现。其他内容主要是将操作系统系统调用封装为适合rust特征的结构和Trait,包括：
1.进程，线程库
2.网络库
3.文件操作库
4.环境变量及参数
5.互斥与同步库，读写锁
6.定时器
7.输入输出的数据结构，
8.系统事件，对epoll,kevent等的封装
可以将std库看做基本常用的容器类型及操作系统封装库。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>RUST的目标和现代编程语言的特点决定了它的库需要仔细的模块化设计。RUST的alloc库及std库都是基于core库。RUST的库设计非常巧妙和仔细，使得RUST完美的实现了对各种硬件架构平台的兼容，对各种操作系统平台的兼容。</p>
<h1 id="rust泛型小议"><a class="header" href="#rust泛型小议">RUST泛型小议</a></h1>
<p>RUST是一门生存在泛型的基础之上的语言。其他语言不使用泛型也不影响编程，泛型只是一个语法中的强大工具。与之相对，RUST离开泛型就无法编写程序，泛型与语法共生。</p>
<h2 id="直接针对泛型的方法和trait实现"><a class="header" href="#直接针对泛型的方法和trait实现">直接针对泛型的方法和trait实现</a></h2>
<p>其他语言的泛型，是作为类型结构体成员，或是函数的输入/返回参数出现在代码中，是配角。RUST的泛型则可以作为主角，可以直接对泛型实现方法和trait。如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//T:?Sized是所有的类型， 不带约束的T实际是 T:Sized
//即类型内存空间固定，所以 T:?Sized才是全部的类型
impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for T {
    fn borrow(&amp;self) -&gt; &amp;T {
        self
    }
}

impl&lt;T: ?Sized&gt; BorrowMut&lt;T&gt; for T {
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut T {
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上代码对所有的类型都实现了Borrow<T>的trait。<br />
直接针对泛型做方法和trait的实现是强大的工具，它的作用：</p>
<ul>
<li>针对泛型的代码会更内聚，方法总比函数具备更明显的模块性</li>
<li>逻辑更清晰及系统化更好</li>
<li>具备更好的可扩展性</li>
<li>更好的支持函数式编程</li>
</ul>
<h2 id="泛型的层次关系"><a class="header" href="#泛型的层次关系">泛型的层次关系</a></h2>
<p>RUST的泛型从一般到特殊会形成一种层次结构，有些类似于面对对象的基类和子类关系：<br />
最基层： <code>T:?Sized</code>  ?Sized的约束表明了所有的类型</p>
<p>一级子层： 默认内存空间固定类型<code>T</code>；裸指针类型<code>* const T/* mut T</code>; 切片类型<code>[T]</code>; 数组类型<code>[T;N]</code>; 引用类型<code>&amp;T/&amp;mut T</code>; trait约束类型<code>T:trait</code>; 泛型元组<code>(T, U...)</code>; 泛型复合类型<code>struct &lt;T&gt;; enum &lt;T&gt;; union&lt;T&gt;</code> 及具体类型 <code>u8/u16/i8/bool/f32/&amp;str/String...</code></p>
<p>二级子层： 对一级子层的T赋以具体类型 如：<code>* const u8; [i32]</code>，或者将一级子层中的T再次做一级子层的具化，例如：<code>* const [T]; [*const T]; &amp;(*const T); * const T where T:trait; struct &lt;T:trait&gt;</code> </p>
<p>可以一直递归下去。
显然，针对基层类型实现的方法和trait可以应用到层级高的泛型类型中。
例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Option&lt;T&gt; {...}
impl&lt;T, U&gt; Option&lt;(T, U)&gt; {...}
impl&lt;T: Copy&gt; Option&lt;&amp;T&gt; {...}
impl&lt;T: Default&gt; Option&lt;T&gt; {...}
<span class="boring">}</span></code></pre></pre>
<p>以上是标准库对Option<T> 的不同泛型的方法实现定义。遵循了从一般到特殊的规则。</p>
<p>类似的实现再试举如下几例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T:?Sized&gt; *const T {...}
impl &lt;T:?Sized&gt; *const [T] {...}
impl &lt;T:?Sized&gt; *mut T{ ...}
impl &lt;T:?Sized&gt; *mut [T] {...}
impl &lt;T&gt; [T] { ...}
impl &lt;T, const N:usize&gt; [T;N]{...}
impl AsRef&lt;[u8]&gt; for str {...}
impl AsRef&lt;str&gt; for str {...}
<span class="boring">}</span></code></pre></pre>
<p>当在代码中需要实现一个新的trait时，都要考虑其是否具备满足所有的类型或某类特殊类型的集体需求，如果是，就可以考虑基于泛型实现。当然，要按照泛型层级从一般到特殊来编写代码。<br />
基于泛型来实现trait或方法，是一种微妙的提升代码良好设计的语言特点，留给读者去体会。</p>
<h1 id="rust内存安全杂述"><a class="header" href="#rust内存安全杂述">RUST内存安全杂述</a></h1>
<p>经过对标准库源代码的学习，很容易能够发现，rust编译器提供的安全特性实际很少：<br />
明确的安全特性：</p>
<ol>
<li>变量必须初始化之后才能使用；</li>
<li>引用必须是内存对齐的，引用指向的变量必须已经初始化；</li>
<li>模块成员默认私有</li>
<li>严格的类型及类型无效值限制</li>
<li>基础类型都满足Copy/Send/Sync auto trait</li>
<li>if及match的分支语法</li>
</ol>
<p>明确的不安全特性：</p>
<ol>
<li>裸指针解引用；</li>
<li>线程间转移变量必须支持Send, 共享变量必须支持Sync</li>
<li>所有的FFI调用,unsafe intrinsic函数调用</li>
<li>对类型产生无效类型值</li>
<li>嵌入式汇编使用</li>
<li>含有以上成分的代码单元</li>
</ol>
<p>为安全提供的工具</p>
<ol>
<li>所有权，生命周期，自动drop；</li>
<li>自动解引用</li>
</ol>
<p>可以看到，编译器提供的安全特性实际上只是实现内存安全的基础设施。RUST程序员仍然需要依靠这些基础设施来构建整个程序的安全大厦。<br />
标准库提供了大量的语言类基础类型结构及操作系统相关的基础类型结构，并完成了这些基础类型结构的安全。如果仅仅使用标准库提供的类型结构，则一般不必额外考虑内存安全问题。但是如果超纲，则新的类型的内存安全必须由创建此类型的代码来做保证，而在当前RUST生态还不完善的情况下，这是必然要发生的事。</p>
<p>RUST的内存安全指的是编译器<strong>提供基础设施</strong>，程序员利用基础设施<strong>创建</strong>内存安全的类型结构使编译器能够保证此类型的内存安全。</p>
<p>在标准库的实践中，可以发现安全是由大量的不安全代码所实现。尤其在操作系统适配的那一层次上，rust实际就是语法改变了的C，为了提高性能所采用的那些技巧和C毫无二致，令人发指，但又不得不佩服。这些代码的安全高度依赖于程序员，语言本身基本没有保障。</p>
<p>RUST的安全本质上仍然是一批高水平程序员实现的一个语言安全框架。</p>
<p>RUST官方语言库安全戏法的一些套路：<br />
安全类型结构基本上是一个封装类型结构， 真正要操作的原始变量被封装在内，并且，此封装类型结构拥有原始变量的所有权。例如：RefCell<T>, 智能指针，Rc<T>，Arc<T>，Mutex<T>等。用于实现不同场景下的安全。<br />
实现封装类型结构的Drop trait，完成生命周期结束时需要的清理操作，例如，释放堆内存，关闭文件描述符等<br />
实现对封装类型结构的借用函数，对于复杂操作，往往需要一个额外的专用于借用的封装类型结构及可变借用的封装类型结构，如Ref<T>, RefMut<T>分别是RefCell的借用及可变借用的结构。不同的封装类型根据意义的不同会有不同的借用操作，如RefCell的borrow(), borrow_mut（）， Rc<T>的clone（）， Mutex<T>的lock()，但都是满足在某种安全机制下的获取原始变量的借用。<br />
实现对于封装类型结构或者借用封装类型结构的Deref trait及 DerefMut trait，得到原始变量的引用或可变引用，从而实现对于原始结构的访问及更改。<br />
实现对于借用封装类型的Drop trait，完成针对借用的清理工作，如减少计数，释放锁等。<br />
RUST的安全实际上都是由这些安全封装类型完成。可以说，每一个安全封装类型都是程序员的血汗得来的教训。</p>
<p>从后继标准库的源代码分析中，可以真实的熟悉RUST的安全戏法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust标准库内存模块代码分析"><a class="header" href="#rust标准库内存模块代码分析">RUST标准库内存模块代码分析</a></h1>
<p>内存模块的代码路径举例如下(以作者电脑上的路径):
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\alloc*.*
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ptr*.*
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\mem*.*
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\intrinsic.rs
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\alloc\src\alloc.rs</p>
<p>RUST最难以掌握特性之一是RUST的内存操作。RUST与C相同，需要对内存做彻底的控制，即程序可以在代码中编写专属内存管理系统，并将内存管理系统与语言类型相关联，在内存块与语言类型之间做自如的转换。对于当前现代语法的高级语言如Java/Python/JS/Go，内存管理是编译器的任务，这就导致大部分程序员对于内存管理缺乏经验，所以对RUST内存安全相关的所有权/生命周期等缺乏实践认知。相对于C，RUST的现代语法及内存安全语法导致RUST的内存块与类型系统相互转换的细节非常复杂，不容易被透彻理解。本章将从标准库的内存模块的代码分析中给出RUST内存操作的本质。对本章内容掌握了，RUST语言的最难关便过了。</p>
<p>从内存角度考察一个变量，则每个变量具备统一的内存参数，这些参数是：</p>
<ol>
<li>变量的首地址，是一个usize的数值</li>
<li>变量类型占用的内存块大小</li>
<li>变量类型内存字节对齐的基数</li>
<li>变量类型中成员内存顺序</li>
</ol>
<p>如果变量成员是复合类型，可递归上面的四个参数。<br />
RUST认为变量类型成员顺序与编译优化不可分割，因此，变量成员内存顺序完全由编译器控制，这与C不同，C中变量类型成员的顺序是不能被编译器改动的。这使得C变量的内存布局对程序员是透明的。这种透明性导致了C语言在涉及类型内存布局的操作中会出现坏代码。<br />
与C相同，RUST具备将一块内存块直接转换成某一类型变量的能力。这一能力是RUST系统级编程及高性能的一个基石。但因为这个转换使得代码可以绕过编译器的类型系统检查，造成了BUG也绕过了编译器的某些错误检查，而这些错误很可能在系统运行很久之后才真正的出错，造成排错的极高成本。<br />
GC类语言去掉了这一能力，但也牺牲了性能，且无法作为系统级语言。RUST没有因噎废食，在保留能力的同时给出这一能力明确的危险标识unsafe, 加上整体的内存安全设计，使得此类错误更易被发现，更易被定位，极大的降低了错误的数目及排错的成本。<br />
unsafe容易让初学RUST语言的程序员产生排斥感，但unsafe实际上是RUST不可分割的部分，一个好的RUST程序员绝不是不使用unsafe，而是能够准确的把握好unsafe使用的合适场合及合适范围，必要的时候必须使用，但绝不滥用。</p>
<p>掌握RUST的内存，主要有如下几个部分：</p>
<ol>
<li>编译器提供的固有内存操作函数</li>
<li>内存块与类型系统的结合点：裸指针 <code>*const T/*mut T</code></li>
<li>裸指针的包装结构: <code>NonNull&lt;T&gt;/Unique&lt;T&gt;</code></li>
<li>未初始化内存块的处理：<code>MaybeUninit&lt;T&gt;/ManuallyDrop&lt;T&gt;</code></li>
<li>堆内存申请及释放</li>
</ol>
<h2 id="裸指针标准库代码分析"><a class="header" href="#裸指针标准库代码分析">裸指针标准库代码分析</a></h2>
<p>裸指针<code>*const T/* mut T</code>将内存和类型系统相连接，裸指针代表了一个内存块，指示了内存块首地址，大小，对齐等属性及后文提到的元数据，但不保证这个内存块的有效性和安全性。<br />
与<code>*const T/* mut T</code>不同，<code>&amp;T/&amp;mut T</code>则保证内存块是安全和有效的，即<code>&amp;T/&amp;mut T</code>满足内存块首地址内存对齐，内存块已经完成了初始化。在RUST中，<code>&amp;T/&amp;mut T</code>是被绑定在某一内存块上，只能用于读写这一内存块。</p>
<p>对于内存块更复杂的操作，由<code>*const T/*mut T</code> 负责，主要有：</p>
<ol>
<li>将usize类型数值强制转换成裸指针类型，以此数值为首地址的内存块被转换为相应的类型。如果对这一转换后的内存块进行读写，可能造成内存安全问题。</li>
<li>在不同的裸指针类型之间进行强制转换，实质上完成了裸指针指向的内存块的类型强转，如果对这一转换后的内存块进行读写，可能造成内存安全问题。 </li>
<li><code>*const u8</code>作为堆内存申请的内存块绑定变量</li>
<li>内存块置值操作，如清零或置一个魔术值</li>
<li>显式的内存块拷贝操作，某些情况下，内存块拷贝是必须的高性能方式。</li>
<li>利用指针偏移计算获取新的内存块， 在数组及切片访问，字符串，协议字节填写，文件缓存等都需要指针偏移计算。</li>
<li>从外部的C函数接口对接的指针参数</li>
<li>...</li>
</ol>
<p>RUST的裸指针类型不象C语言的指针类型那样仅仅是一个地址值，为满足实现内存安全的类型系统需求，并兼顾内存使用效率和方便性，RUST的裸指针实质是一个较复杂的类型结构体。</p>
<h3 id="裸指针具体实现"><a class="header" href="#裸指针具体实现">裸指针具体实现</a></h3>
<p><code>*const T/*mut T</code>实质是个数据结构体，由两个部分组成，第一个部分是一个内存地址，第二个部分对这个内存地址的约束性描述-元数据</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//从下面结构定义可以看到，裸指针本质就是PtrComponents&lt;T&gt;
pub(crate) union PtrRepr&lt;T: ?Sized&gt; {
    pub(crate) const_ptr: *const T,
    pub(crate) mut_ptr: *mut T,
    pub(crate) components: PtrComponents&lt;T&gt;,
}

pub(crate) struct PtrComponents&lt;T: ?Sized&gt; {
    //*const ()保证元数据部分是空 
    pub(crate) data_address: *const (),
    //不同类型指针的元数据
    pub(crate) metadata: &lt;T as Pointee&gt;::Metadata,
}

//下面Pointee的定义展示一个RUST的编程技巧，即trait可以只用
//来定义关联类型，Pointee即只用来指定Metadata的类型。
pub trait Pointee {
    /// The type for metadata in pointers and references to `Self`.
    type Metadata: Copy + Send + Sync + Ord + Hash + Unpin;
}
//廋指针元数据是单元类型，即是空
pub trait Thin = Pointee&lt;Metadata = ()&gt;;
<span class="boring">}</span></code></pre></pre>
<p>元数据的规则:</p>
<ul>
<li>对于固定大小类型的指针（实现了 <code>Sized</code> Trait）, RUST定义为廋指针(thin pointer)，元数据大小为0，类型为(),这里要注意，RUST中数组也是固定大小的类型，运行中对数组下标合法性的检测，就是比较是否已经越过了数组的内存大小。</li>
<li>对于动态大小类型的指针(DST 类型)，RUST定义为胖指针(fat pointer 或 wide pointer), 元数据为：
<ul>
<li>对于结构类型，如果最后一个成员是动态大小类型(结构的其他成员不允许为动态大小类型)，则元数据为此动态大小类型<br />
的元数据</li>
<li>对于<code>str</code>类型, 元数据是按字节计算的长度值，元数据类型是usize</li>
<li>对于切片类型，例如<code>[T]</code>类型，元数据是数组元素的数目值，元数据类型是usize</li>
<li>对于trait对象，例如 dyn SomeTrait， 元数据是 [DynMetadata<Self>][DynMetadata]（后面代码解释）
（例如：DynMetadata<dyn SomeTrait>)
随着RUST的发展，有可能会根据需要引入新的元数据种类。</li>
</ul>
</li>
</ul>
<p>在标准库代码当中没有指针类型如何实现Pointee Trait的代码，编译器针对每个类型自动的实现了Pointee。
如下为rust编译器代码的一个摘录</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn ptr_metadata_ty(&amp;'tcx self, tcx: TyCtxt&lt;'tcx&gt;) -&gt; Ty&lt;'tcx&gt; {
        // FIXME: should this normalize?
        let tail = tcx.struct_tail_without_normalization(self);
        match tail.kind() {
            // Sized types
            ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
            | ty::Uint(_)
            | ty::Int(_)
            | ty::Bool
            | ty::Float(_)
            | ty::FnDef(..)
            | ty::FnPtr(_)
            | ty::RawPtr(..)
            | ty::Char
            | ty::Ref(..)
            | ty::Generator(..)
            | ty::GeneratorWitness(..)
            | ty::Array(..)
            | ty::Closure(..)
            | ty::Never
            | ty::Error(_)
            | ty::Foreign(..)
            | ty::Adt(..)
            // 如果是固定类型，元数据是单元类型 tcx.types.unit，即为空
            | ty::Tuple(..) =&gt; tcx.types.unit,

            //对于字符串和切片类型，元数据为长度tcx.types.usize，是元素长度
            ty::Str | ty::Slice(_) =&gt; tcx.types.usize,

            //对于dyn Trait类型， 元数据从具体的DynMetadata获取*
            ty::Dynamic(..) =&gt; {
                let dyn_metadata = tcx.lang_items().dyn_metadata().unwrap();
                tcx.type_of(dyn_metadata).subst(tcx, &amp;[tail.into()])
            },
            
            //以下类型不应有元数据
            ty::Projection(_)
            | ty::Param(_)
            | ty::Opaque(..)
            | ty::Infer(ty::TyVar(_))
            | ty::Bound(..)
            | ty::Placeholder(..)
            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) =&gt; {
                bug!(&quot;`ptr_metadata_ty` applied to unexpected type: {:?}&quot;, tail)
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>以上代码中的中文注释比较清晰的说明了编译器对每一个类型（或类型指针）都实现了Pointee中元数据类型的获取。
对于trait对象的元数据的具体结构定义见如下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//dyn trait裸指针的元数据结构,此元数据会被用于获取trait的方法
pub struct DynMetadata&lt;Dyn: ?Sized&gt; {
    //在堆内存中的VTTable变量的引用,VTable见后面的说明
    vtable_ptr: &amp;'static VTable,
    //标示结构对Dyn的所有权关系，
    //其中PhantomData与具体变量的联系在初始化时由编译器自行推断完成, 
    //这里PhantomData主要对编译器提示做Drop check时注意本结构体会
    //负责对Dyn类型变量做drop。
    phantom: crate::marker::PhantomData&lt;Dyn&gt;,
}

//此结构是实际的trait实现
struct VTable {
    //trait对象的drop方法的指针
    drop_in_place: fn(*mut ()),
    //trait对象的内存大小
    size_of: usize,
    //trait对象的内存对齐
    align_of: usize,
    //后继是trait对象的所有方法的指针数组
}
<span class="boring">}</span></code></pre></pre>
<p>元数据类型相同的裸指针可以任意的转换，例如：可以有 * const [usize; 3] as * const[usize; 5] 这种语句.<br />
元数据类型不同的裸指针之间不能转换，例如；* const [usize;3] as *const[usize] 这种语句无法通过编译器 </p>
<h3 id="裸指针的操作函数intrinsic模块内存相关固有函数"><a class="header" href="#裸指针的操作函数intrinsic模块内存相关固有函数">裸指针的操作函数——intrinsic模块内存相关固有函数</a></h3>
<p>intrinsics模块中的函数由编译器内置实现，并提供给其他模块使用。固有函数标准库没有代码，所以对其主要是了解功能和如何使用，intrinsics模块的内存函数一般不由库以外的代码直接调用，而是由mem模块和ptr模块封装后再提供给其他模块。 </p>
<p>内存申请及释放函数：<br />
<code>intrinsics::forget&lt;T:Sized?&gt; (_:T)</code>, 代码中调用这个函数后，在变量生命周期终止时，编译器不会调用变量的drop函数。<br />
<code>intrinsics::drop_in_place&lt;T:Sized?&gt;(to_drop: * mut T)</code> 在forget后，如果仍然需要对变量调用drop，则在代码中显式调用此函数以触发对变量的drop调用。<br />
<code>intrinsics::needs_drop&lt;T&gt;()-&gt;bool</code>, 判断T类型是否需要做drop操作，实现了Copy trait的类型会返回false</p>
<p>类型转换：
<code>intrinsics::transmute&lt;T,U&gt;(e:T)-&gt;U</code>, 对于内存布局相同的类型 T和U, 完成将类型T变量转换为类型U变量，此时T的所有权将转换为U的所有权</p>
<p>指针偏移函数:
<code>intrinsics::offset&lt;T&gt;(dst: *const T, offset: usize)-&gt;* const T</code>, 相当于C的基于类型的指针加计算<br />
<code>intrinsics::ptr_offset_from&lt;T&gt;(ptr: *const T, base: *const T) -&gt; isize</code> 相当于C的基于类型的指针减</p>
<p>内存块内容修改函数:
<code>intrinsics::copy&lt;T&gt;(src:*const T, dst: *mut T, count:usize)</code>, 内存拷贝， src和dst内存可重叠， 类似c语言中的memmove, 此时dst原有内存如果已经初始化，dst原有变量的drop实质会不执行。src的变量可能出现两次drop，因此调用此函数的代码需要处理这种情况。</p>
<p><code>intrinsics::copy_no_overlapping&lt;T&gt;(src:*const T, dst: * mut T, count:usize)</code>, 内存拷贝， src和dst内存不重叠，内存安全问题同上</p>
<p><code>intrinsics::write_bytes(dst: *mut T, val:u8, count:usize)</code> , C语言的memset的RUST实现, 此时，原内存如果已经初始化，则因为编译器会继续对dst的内存块做drop调用，有可能会UB。</p>
<p>类型内存参数函数：
<code>intrinsics::size_of&lt;T&gt;()-&gt;usize</code> 类型内存空间字节数<br />
<code>intrinsics::min_align_of&lt;T&gt;()-&gt;usize</code> 返回类型对齐字节数<br />
<code>intrinsics::size_of_val&lt;T&gt;(_:*const T)-&gt;usize</code>返回指针指向的变量内存空间字节数<br />
<code>intrinsics::min_align_of_val&lt;T&gt;(_: * const T)-&gt;usize</code> 返回指针指向的变量对齐字节数</p>
<p>禁止优化的内存函数：
形如<code>volatile_xxxx</code> 的函数是通知编译器不做内存优化的操作函数,一般硬件相关操作需要禁止优化。<br />
<code>intrinsics::volatile_copy_nonoverlapping_memory&lt;T&gt;(dst: *mut T, src: *const T, count: usize)</code> 内存拷贝</p>
<p><code>intrinsics::volatile_copy_memory&lt;T&gt;(dst: *mut T, src: *const T, count: usize)</code> 功能类似C语言memmove</p>
<p><code>intrinsics::volatile_set_memory&lt;T&gt;(dst: *mut T, val: u8, count: usize)</code>  功能类似C语言memset</p>
<p><code>intrinsics::volatile_load&lt;T&gt;(src: *const T) -&gt; T</code>读取内存或寄存器，T类型字节对齐到2的幂次</p>
<p><code>intrinsics::volatile_store&lt;T&gt;(dst: *mut T, val: T)</code>内存或寄存器写入，字节对齐</p>
<p><code>intrinsics::unaligned_volatile_load&lt;T&gt;(src: *const T) -&gt; T</code> 字节非对齐</p>
<p><code>intrinsics::unaligned_volatile_store&lt;T&gt;(dst: *mut T, val: T)</code>字节非对齐</p>
<p>内存比较函数：
<code>intrinsics::raw_eq&lt;T&gt;(a: &amp;T, b: &amp;T) -&gt; bool</code> 内存比较，类似C语言memcmp</p>
<p><code>pub fn ptr_guaranteed_eq&lt;T&gt;(ptr: *const T, other: *const T) -&gt; bool</code> 判断两个指针是否判断, 相等返回ture, 不等返回false</p>
<p><code>pub fn ptr_guaranteed_ne&lt;T&gt;(ptr: *const T, other: *const T) -&gt; bool</code> 判断两个指针是否不等，不等返回true</p>
<h3 id="裸指针方法"><a class="header" href="#裸指针方法">裸指针方法</a></h3>
<p>RUST针对<code>*const T/*mut T</code>的类型实现了若干方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T:?Sized&gt; * const T {
    ...
}
impl &lt;T:?Sized&gt; *mut T{
    ...
}
impl &lt;T&gt; *const [T] {
    ...
}
impl &lt;T&gt; *mut [T] {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>对于裸指针，RUST标准库包含了最基础的 <code>* const T/* mut T</code>， 以及在<code>* const T/*mut T</code> 基础上特化的切片类型[T]的裸指针<code>* const [T]/*mut [T]</code>。
标准库针对这两种类型实现了一些关联函数及方法。这里一定注意，所有针对 <code>* const T</code>的方法在<code>* const [T]</code>上都是适用的。</p>
<p>以上有几点值得注意：</p>
<ol>
<li>可以针对原生类型实现方法(实现trait)，这体现了RUST类型系统的强大扩展性，也是对函数式编程的强大支持</li>
<li>针对泛型约束实现方法，我们可以大致认为<code>*const T/* mut T</code>实质是一种泛型约束，<code>*const [T]/*mut [T]</code>是更进一步的约束，这使得RUST可以具备更好的数据抽象能力，简化代码，复用模块。</li>
</ol>
<h4 id="裸指针的创建"><a class="header" href="#裸指针的创建">裸指针的创建</a></h4>
<p>直接从已经初始化的变量创建裸指针：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    &amp;T as *const T;
    &amp;mut T as * mut T;
<span class="boring">}</span></code></pre></pre>
<p>直接用usize的数值创建裸指针：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    {
        let  a: usize = 0xf000000000000000;
        unsafe {a as * const i32};
    }
<span class="boring">}</span></code></pre></pre>
<p>操作系统内核经常需要直接将一个地址数值转换为某一类型的裸指针</p>
<p>RUST也提供了一些其他的裸指针创建关联函数：<br />
<code>ptr::null&lt;T&gt;() -&gt; *const T</code> 创建一个0值的<code>*const T</code>，实际上就是 <code>0 as *const T</code>，用null()函数明显更符合程序员的习惯<br />
<code>ptr::null_mut&lt;T&gt;()-&gt;*mut T</code> 除了类型以外，其他同上</p>
<p><code>ptr::invalid&lt;T&gt;(addr:usize)-&gt;*mut T</code> 将一个数值作为裸指针，指明这是一个无效的裸指针。<br />
<code>ptr::invalid_mut&lt;T&gt;(addr:usize)-&gt;*mut T</code> 将一个数值作为可变裸指针，指明这是一个无效的指针。<br />
以上两个函数通常是将指针变量用作他途以提高新能</p>
<p><code>ptr::from_raw_parts&lt;T: ?Sized&gt;(data_address: *const (), metadata: &lt;T as Pointee&gt;::Metadata) -&gt; *const T</code> 从内存地址和元数据创建裸指针 </p>
<p><code>ptr::from_raw_parts_mut&lt;T: ?Sized&gt;(data_address: *mut (), metadata: &lt;T as Pointee&gt;::Metadata) -&gt; *mut T</code> 功能同上，创建可变裸指针</p>
<p>RUST裸指针类型转换时，经常使用以上两个函数获得需要的指针类型。</p>
<p>切片类型的裸指针创建函数如下：<br />
<code>ptr::slice_from_raw_parts&lt;T&gt;(data: *const T, len: usize) -&gt; *const [T] </code><br />
<code>ptr::slice_from_raw_parts_mut&lt;T&gt;(data: *mut T, len: usize) -&gt; *mut [T]</code> 由裸指针类型及切片长度获得切片类型裸指针，调用代码应保证data事实上就是切片的裸指针地址。<br />
由类型裸指针转换为切片类型裸指针最突出的应用之一是内存申请，申请的内存返回 * const u8的指针，这个裸指针是没有包含内存大小的，只有头地址，因此需要将这个指针转换为 * const [u8]，将申请的内存大小包含入裸指针结构体中。</p>
<p>slice_from_raw_parts代码如下： </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn slice_from_raw_parts&lt;T&gt;(data: *const T, len: usize) -&gt; *const [T] {
    //data.cast()将*const T转换为 *const()
    from_raw_parts(data.cast(), len)
}

pub const fn from_raw_parts&lt;T: ?Sized&gt;(
    data_address: *const (),
    metadata: &lt;T as Pointee&gt;::Metadata,
) -&gt; *const T {
    //由以下代码可以确认 * const T实质就是PtrRepr类型结构体。
    unsafe { PtrRepr { components: PtrComponents { data_address, metadata } }.const_ptr }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="不属于方法的裸指针函数"><a class="header" href="#不属于方法的裸指针函数">不属于方法的裸指针函数</a></h4>
<p><code>ptr::drop_in_place&lt;T: ?Sized&gt;(to_drop: *mut T)</code> 此函数是编译器实现的，用于由程序代码人工释放所有权，而不是交由RUST编译器处理。此函数会引发T内部成员的系列drop调用。</p>
<p><code>ptr::metadata&lt;T: ?Sized&gt;(ptr: *const T) -&gt; &lt;T as Pointee&gt;::Metadata </code>用来返回裸指针的元数据</p>
<p><code>ptr::eq&lt;T&gt;(a: *const T, b: *const T)-&gt;bool</code> 比较指针，此处需要注意，地址比较不但是地址，也比较元数据</p>
<p>ptr模块的函数大部分逻辑都比较简单。很多就是对intrinsic 函数的直接调用。</p>
<h4 id="裸指针类型转换方法"><a class="header" href="#裸指针类型转换方法">裸指针类型转换方法</a></h4>
<p>裸指针类型之间的转换：
<code>*const T::cast&lt;U&gt;(self) -&gt; *const U </code> ，本质上就是一个<code>*const T as *const U</code>。利用RUST的类型推断，此函数可以简化代码并支持链式调用。 
<code>*mut T::cast&lt;U&gt;(self)-&gt;*mut U</code> 同上。</p>
<p>调用以上的函数要注意，如果后继要把返回的指针转换成引用，那必须保证T类型与U类型内存布局完全一致。如果仅仅是将返回值做数值应用，则此约束可以不遵守，cast函数转换后的类型通常由编译器自行推断，有时需要仔细分析。</p>
<p>裸指针与引用之间的类型转换：<br />
<code>*const T::as_ref&lt;‘a&gt;(self) -&gt; Option&lt;&amp;’a T&gt;</code> 将裸指针转换为引用，因为*const T可能为零，所有需要转换为<code>Option&lt;&amp; ‘a T&gt;</code>类型，转换的安全性由程序员保证，尤其注意满足RUST对引用的安全要求。这里注意，<strong>生命周期标注表明转换后的生命周期实际上与原变量的生命周期相独立</strong>。因此，生命周期的正确性将由调用代码保证。如果没有标注，则返回的引用的生命周期应该小于self,遵循函数参数及返回值的生命周期规则。<br />
<code>*mut T::as_ref&lt;`a&gt;(self)-&gt;Option&lt;&amp;`a T&gt;</code>   同上<br />
<code>*mut T::as_mut&lt;`a&gt;(self)-&gt;Option&lt;&amp;`a mut T&gt;</code>同上，但转化类型为 &amp;mut T。</p>
<p>切片类型裸指针类型转换：
<code>ptr::*const [T]::as_ptr(self) -&gt; *const T</code> 将切片类型的裸指针转换为切片成员类型的裸指针， 这个转换会导致指针的元数据丢失<br />
<code>ptr::*mut [T]::as_mut_ptr(self) -&gt; *mut T</code> 同上</p>
<h4 id="裸指针结构体属性相关方法"><a class="header" href="#裸指针结构体属性相关方法">裸指针结构体属性相关方法：</a></h4>
<p><code>ptr::*const T::to_raw_parts(self) -&gt; (*const (), &lt;T as super::Pointee&gt;::Metadata)</code></p>
<p><code>ptr::*mut T::to_raw_parts(self)-&gt;(* const (), &lt;T as super::Pointee&gt;::Metadata)</code>  由裸指针获得地址及元数据<br />
<code>ptr::*const T::is_null(self)-&gt;bool</code><br />
<code>ptr::*mut T::is_null(self)-&gt;bool此</code>函数判断裸指针的地址值是否为0</p>
<p>切片类型裸指针：<br />
<code>ptr::*const [T]:: len(self) -&gt; usize</code> 获取切片长度，直接从裸指针的元数据获取长度<br />
<code>ptr:: *mut [T]:: len(self) -&gt; usize</code> 同上</p>
<h4 id="裸指针偏移计算相关方法"><a class="header" href="#裸指针偏移计算相关方法">裸指针偏移计算相关方法</a></h4>
<p><code>ptr::*const T::offset(self, count:isize)-&gt;* const T</code> 得到偏移后的裸指针<br />
<code>ptr::*const T::wrapping_offset(self, count: isize) -&gt; *const T</code> 考虑溢出绕回的offset<br />
<code>ptr::*const T::offset_from(self, origin: *const T) -&gt; isize</code> 计算两个裸指针的offset值<br />
<code>ptr::*mut T::offset(self, count:isize)-&gt;* mut T</code> 偏移后的裸指针<br />
<code>ptr::*const T::wrapping_offset(self, count: isize) -&gt; *const T</code> 考虑溢出绕回的offset<br />
<code>ptr::*const T::offset_from(self, origin: *const T) -&gt; isize</code> 计算两个裸指针的offset值<br />
以上两个方法基本上通过intrinsic的函数实现</p>
<p><code>ptr::*const T::add(self, count: usize) -&gt; Self</code><br />
<code>ptr::*const T::wraping_add(self, count: usize)-&gt;Self</code><br />
<code>ptr::*const T::sub(self, count:usize) -&gt; Self</code><br />
<code>ptr::*const T::wrapping_sub(self, count:usize) -&gt; Self</code><br />
<code>ptr::*mut T::add(self, count: usize) -&gt; Self</code><br />
<code>ptr::*mut T::wraping_add(self, count: usize)-&gt;Self</code><br />
<code>ptr::*mut T::sub(self, count:usize) -&gt; Self</code><br />
<code>ptr::*mut T::wrapping_sub(self, count:usize) -&gt; Self</code><br />
以上是对offset函数的包装，使之更符合语义习惯，并便于理解</p>
<h4 id="裸指针直接赋值方法"><a class="header" href="#裸指针直接赋值方法">裸指针直接赋值方法</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //该方法用于仅给指针结构体的 address部分赋值  
    pub fn set_ptr_value(mut self, val: *const u8) -&gt; Self {
        // 以下代码因为只修改PtrComponent.address，所以不能直接用相等
        // 代码采取的方案是取self的可变引用，将此引用转换为裸指针的裸指针，
        let thin = &amp;mut self as *mut *const T as *mut *const u8;
        // 这个赋值仅仅做了address的赋值，对于瘦指针，这个相当于赋值操作，
        // 对于胖指针，则没有改变胖指针的元数据。这种操作方式仅仅在极少数的情况下
        // 可以使用，极度危险。
        unsafe { *thin = val };
        self
    }
<span class="boring">}</span></code></pre></pre>
<p>本节还有一部分裸指针方法没有介绍，留到mem模块分析完以后再介绍会更易于理解。 </p>
<h3 id="裸指针小结"><a class="header" href="#裸指针小结">裸指针小结</a></h3>
<p>裸指针相关的代码多数比较简单，重要的是理解裸指针的概念，理解intrinsic 相关函数，这样才能够准确的理解代码。</p>
<h4 id="rust引用t的安全要求"><a class="header" href="#rust引用t的安全要求">RUST引用<code>&amp;T</code>的安全要求</a></h4>
<ol>
<li>引用的内存地址必须满足类型T的内存对齐要求</li>
<li>引用的内存内容必须是初始化过的
举例：</li>
</ol>
<pre><pre class="playground"><code class="language-rust">   #[repr(packed)]
   struct RefTest {a:u8, b:u16, c:u32}
   fn main() {
       let test = RefTest{a:1, b:2, c:3};
       //下面代码编译会有告警，因为test.b 内存字节位于奇数，
       // 无法用于借用
       let ref1 = &amp;test.b
   }</code></pre></pre>
<p>编译器出现如下警告</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|
9 | let ref1 = &amp;test.b;
 |            ^^^^^^^
 |
 = note: `#[warn(unaligned_references)]` on by default
 = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
 = note: for more information, see issue #82523 &lt;https://github.com/rust-lang/rust/issues/82523&gt;
 = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)
 = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)

<span class="boring">}</span></code></pre></pre>
<h2 id="maybeuninitt标准库代码分析"><a class="header" href="#maybeuninitt标准库代码分析"><code>MaybeUninit&lt;T&gt;</code>标准库代码分析</a></h2>
<p>RUST对于变量的要求是必须初始化后才能使用，否则就会编译告警。但在程序中，总有内存还未初始化，但需要使用的情况：</p>
<ol>
<li>从堆申请的内存块，这些内存块都是没有初始化的</li>
<li>需要定义一个新的泛型变量时，并且不合适用转移所有权进行赋值时</li>
<li>需要定义一个新的变量，但希望不初始化便能使用其引用时</li>
<li>定义一个数组，但必须在后继代码对数组成员初始化时</li>
<li>...</li>
</ol>
<p>为了处理这种需要在代码中使用未初始化内存的情况，RUST标准库定义了<code>MaybeUninit&lt;T&gt;</code></p>
<h3 id="maybeuninitt结构定义"><a class="header" href="#maybeuninitt结构定义"><code>MaybeUninit&lt;T&gt;</code>结构定义</a></h3>
<p>源代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[repr(transparent)] 
    pub union MaybeUninit&lt;T&gt; {
        uninit: (),
        value: ManuallyDrop&lt;T&gt;,
    }
<span class="boring">}</span></code></pre></pre>
<p>属性<code>repr(transparent)</code>实际上表示外部的封装结构在内存中等价于内部的变量,<br />
<code>MaybeUninit&lt;T&gt;</code>的内存布局就是<code>ManuallyDrop&lt;T&gt;</code>的内存布局，从后文可以看到，<code>ManuallyDrop&lt;T&gt;</code>实际就是T的内存布局。所以<code>MaybeUninit&lt;T&gt;</code>在内存中实质也就是T类型。<br />
<code>MaybeUninit&lt;T&gt;</code>容器来实现对未初始化变量的封装，以便在不引发编译错误完成对T类型未初始化变量的相关操作.
如果T类型的变量未初始化，那需要显式的提醒编译器不做T类型的drop操作，因为drop操作可能会对T类型内部的变量做连锁drop处理，从而引用未初始化的内容，造成UB(undefined behavior)。<br />
RUST用<code>ManuallyDrop&lt;T&gt;</code>封装结构完成了对编译器的显式提示，对于用<code>ManuallyDrop&lt;T&gt;</code>封装的变量，生命周期终止的时候编译器不会调用drop操作。</p>
<h3 id="manuallydropt-结构及方法"><a class="header" href="#manuallydropt-结构及方法"><code>ManuallyDrop&lt;T&gt;</code> 结构及方法</a></h3>
<p>源代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct ManuallyDrop&lt;T: ?Sized&gt; {
    value: T,
}
<span class="boring">}</span></code></pre></pre>
<p>重点关注的一些方法： 
<code>ManuallyDrop&lt;T&gt;::new（val:T) -&gt; ManuallyDrop&lt;T&gt;</code>, 此函数返回ManuallyDrop变量拥有传入的T类型变量所有权，并将此块内存直接用ManuallyDrop封装, 对于ManuallyDrop，编译器不做drop操作，因此也不会触发val的drop。 </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn new(value: T) -&gt; ManuallyDrop&lt;T&gt; {
        //所有权转移到结构体内部，value生命周期结束时不会引发drop
        ManuallyDrop { value }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>ManuallyDrop&lt;T&gt;::into_inner(slot: ManuallyDrop&lt;T&gt;)-&gt;T</code>, 将封装的T类型变量所有权转移出来，转移出来的变量生命周期终止时，编译器会自动调用类型的drop。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn into_inner(slot: ManuallyDrop&lt;T&gt;) -&gt; T {
        //将value解封装，所有权转移到返回值中，编译器重新对所有权做处理
        slot.value
    }
<span class="boring">}</span></code></pre></pre>
<p><code>ManuallyDrop&lt;T&gt;::drop(slot: &amp;mut ManuallyDrop&lt;T&gt;)</code>，drop掉内部变量，封装入<code>ManuallyDrop&lt;T&gt;</code>的变量一定是在程序运行的某一时期不需要编译器drop，所以调用这个函数的时候一定要注意正确性。 
<code>ManuallyDrop&lt;T&gt;::deref(&amp;self)-&gt; &amp; T</code>, 返回内部包装变量的引用 </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn deref(&amp;self) -&gt; &amp;T {
        //返回后，代码可以用&amp;T对self.value做
        //读操作,但不改变drop的规则
        &amp;self.value
    }
<span class="boring">}</span></code></pre></pre>
<p><code>ManuallyDrop&lt;T&gt;::deref_mut(&amp;mut self)-&gt; &amp; mut T</code>返回内部包装变量的可变引用，调用代码可以利用可变引用对内部变量赋值，但不改变drop机制</p>
<p>ManuallyDrop代码举例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::mem::ManuallyDrop;
    let mut x = ManuallyDrop::new(String::from(&quot;Hello World!&quot;));
    x.truncate(5); // 此时会调用deref
    assert_eq!(*x, &quot;Hello&quot;);
    // 但对x的drop不会再发生
<span class="boring">}</span></code></pre></pre>
<h4 id="maybeuninitt-创建方法"><a class="header" href="#maybeuninitt-创建方法"><code>MaybeUninit&lt;T&gt;</code> 创建方法</a></h4>
<p><code>MaybeUninit&lt;T&gt;::uninit()-&gt;MaybeUninit&lt;T&gt;</code>, 可视为在栈空间上申请内存的方法，申请的内存大小是T类型的内存大小，该内存没有初始化。利用泛型和Union内存布局，RUST巧妙的利用此函数在栈上申请一块未初始化内存。此函数非常非常非常值得关注，在需要在栈空间定义一个未初始化泛型时，应第一时间想到<code>MaybeUninit::&lt;T&gt;::uninit()</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn uninit() -&gt; MaybeUninit&lt;T&gt; {
        //变量内存布局与T类型完全一致
        MaybeUninit { uninit: () }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>MaybeUninit&lt;T&gt;::new(val:T)-&gt;MaybeUninit&lt;T&gt;</code>, 内部用ManuallyDrop封装了val, 然后用MaybeUninit封装ManuallyDrop。因为如果T没有初始化过，调用这个函数会编译失败，所以此时内存实际上已经初始化过了。调用此函数要额外注意val的drop必须在后继有交代。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn new(val: T) -&gt; MaybeUninit&lt;T&gt; {
        //val这个时候是初始化过的。
        MaybeUninit { value: ManuallyDrop::new(val) }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>MaybeUninit&lt;T&gt;::zeroed()-&gt;MaybeUninit&lt;T&gt;</code>, 申请了T类型内存并清零。 </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn zeroed() -&gt; MaybeUninit&lt;T&gt; {
        let mut u = MaybeUninit::&lt;T&gt;::uninit();
        unsafe {
            //因为没有初始化，所以不存在所有权问题，
            //必须使用ptr::write_bytes，否则无法给内存清0
            //ptr::write_bytes直接调用了intrinsics::write_bytes
            u.as_mut_ptr().write_bytes(0u8, 1);
        }
        u
    }
<span class="boring">}</span></code></pre></pre>
<h4 id="对未初始化的变量赋值的方法"><a class="header" href="#对未初始化的变量赋值的方法">对未初始化的变量赋值的方法</a></h4>
<p>将值写入<code>MaybeUninit&lt;T&gt;</code>:
<code>MaybeUninit&lt;T&gt;::write(val)-&gt;&amp;mut T</code>, 这个函数将未初始化的变量初始化，如果调用此方法后不希望解封装，那后继的赋值使用返回的&amp;mut T，再次使用write会出现内存安全问题。代码如下： </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn write(&amp;mut self, val: T) -&gt; &amp;mut T {
        //下面这个赋值，会导致原*self的MaybeUninit&lt;T&gt;的变量生命周期截止，
        //会调用drop。但不会对内部的T类型变量做drop调用。所以如果*self内部
        //的T类型变量已经被初始化且需要做drop，那会造成内存泄漏。
        //所以下面这个等式实际上隐含了self内部的T类型变量必须是未初始化的
        //或者T类型变量不需要drop。
        *self = MaybeUninit::new(val);
        // 函数调用后的赋值用返回的&amp;mut T来做。
        unsafe { self.assume_init_mut() }
    }
<span class="boring">}</span></code></pre></pre>
<h4 id="初始化后解封装的方法"><a class="header" href="#初始化后解封装的方法">初始化后解封装的方法</a></h4>
<p>用assume_init返回初始化后的变量并消费掉<code>MaybeUninit&lt;T&gt;</code>变量，这是最标准的做法：
<code>MaybeUninit&lt;T&gt;::assume_init()-&gt;T</code>,代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const unsafe fn assume_init(self) -&gt; T {
        // 调用者必须保证self已经初始化了
        unsafe {
            intrinsics::assert_inhabited::&lt;T&gt;();
            //把T的所有权返回，编译器会主动对T调用drop
            ManuallyDrop::into_inner(self.value)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>assume_init_read是不消费self的情况下获得内部T变量，内部T变量的所有权已经转移到返回变量，后继要注意不能再次调用其他解封装函数。否则解封装后，会出现双份所有权，引发两次对同一变量的drop，导致UB。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const unsafe fn assume_init_read(&amp;self) -&gt; T {
        
        unsafe {
            intrinsics::assert_inhabited::&lt;T&gt;();
            //会调用ptr::read
            self.as_ptr().read()
        }
    }
    //此函即ptr::read, 会复制一个变量，此时注意，
    //实际上src指向的变量的所有权已经转移给了返回变量，
    //所以调用此函数的前提是src后继一定不能调用T类型的drop函数，
    //例如src本身处于ManallyDrop，或后继对src调用forget，或给src绑定新变量。
    //在RUST中，不支持 let xxx = *(&amp;T) 这种转移所有权的方式，
    //因此对于只有指针输入，又要转移所有权的，智能利用浅拷贝进行粗暴转移。
    pub const unsafe fn read&lt;T&gt;(src: *const T) -&gt; T {` 
        //利用MaybeUninit::uninit申请未初始化的T类型内存
        let mut tmp = MaybeUninit::&lt;T&gt;::uninit();
        unsafe {
            //完成内存拷贝
            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);
            //初始化后的内存解封装并返回
            tmp.assume_init()
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>与上个函数比较类似的<code>ManuallyDrop&lt;T&gt;::take</code>方法，用take函数将变量复制并获得变量的所有权。此时原变量仍然保留在ManuallyDrop中，后继不能再调用其他解封装函数，否则可能会出现UB。这里要特别注意理解take已经把变量的所有权转移到返回变量中。<br />
<em><strong>RUST中的take方法及replace方法的含义是，原变量的地址不能变动，但内容可以获取及更新，因为内容的获取及更新必然导致所有权的转移，为了确保正确性，RUST对很多类型提供了take,replace方法。</strong></em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub unsafe fn take(slot: &amp;mut ManuallyDrop&lt;T&gt;) -&gt; T {
        // 拷贝内部变量，并返回内部变量的所有权
        // 返回后，原有的变量所有权已经消失，不能再用into_inner来返回
        // 否则会UB
        unsafe { ptr::read(&amp;slot.value) }
    }

<span class="boring">}</span></code></pre></pre>
<p><code>MaybeUninit&lt;T&gt;::assume_init_drop(&amp;self)</code> 对于已经初始化过的MaybeUninit<T>， 如果所有权一直没有转移，则必须调用此函数以触发T类型的drop函数完成所有权的释放。<br />
<code>MaybeUninit&lt;T&gt;::assume_init_ref(&amp;self)-&gt;&amp;T</code> 返回内部T类型变量的借用，调用者应保证内部T类型变量已经初始化，返回值按照一个普通的引用使用。<em><strong>根据RUST的生命周期省略规则，此时&amp;T的生命周期小于&amp;self的生命周期，编译器可以借此检查出生命周期的错误。RUST很多从裸指针转换为引用的生命周期都是利用函数的输入及输出的生命周期规则约束才能保证编译器对生命周期的正确检查</strong></em>
<code>MaybeUninit&lt;T&gt;::assume_init_mut(&amp;mut self)-&gt;&amp;mut T</code>返回内部T类型变量的可变借用，调用者应保证内部T类型变量已经初始化，返回值按照一个普通的可变引用使用。此时&amp;mut T的生命周期小于&amp;mut self。此函数通常也用于防止assume_init导致的栈拷贝以提高性能。</p>
<h4 id="maybeuninitt的方法"><a class="header" href="#maybeuninitt的方法"><code>MaybeUninit&lt;[T]&gt;</code>的方法</a></h4>
<p>创建一个MaybeUninit的未初始化数组：<br />
<code>MaybeUninit&lt;T&gt;::uninit_array&lt;const LEN:usize&gt;()-&gt;[Self; LEN]</code> 此处对LEN的使用方式需要注意，这是不常见的一个泛型写法,这个函数同样的申请了一块内存。代码： </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn uninit_array&lt;const LEN: usize&gt;() -&gt; [Self; LEN] {
        unsafe { MaybeUninit::&lt;[MaybeUninit&lt;T&gt;; LEN]&gt;::uninit().assume_init() }
    }
<span class="boring">}</span></code></pre></pre>
<p>这里要注意区别数组类型和数组元素的初始化。对于数组<code>[MaybeUninit&lt;T&gt;;LEN]</code>这一类型本身来说，初始化就是确定整体的内存大小，所以数组类型的初始化在声明后就已经完成了。这时assume_init()是正确的。这是一个理解上的盲点。</p>
<p><code>MaybeUninit&lt;T&gt;::array_assume_init&lt;const N:usize&gt;(array: [Self; N]) -&gt; [T; N]</code> 这个函数没有把所有权转移出来，代码分析如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub unsafe fn array_assume_init&lt;const N: usize&gt;(array: [Self; N]) -&gt; [T; N] {
        unsafe {
            //最后调用是*const T::read()，此处 as *const _的写法可以简化代码,
            //read后，所有权已经转移到返回值
            //返回后，此数组内所有的MaybeUninit变量成员不能再解封装
            (&amp;array as *const _ as *const [T; N]).read()
        }
    }
<span class="boring">}</span></code></pre></pre>
<h4 id="maybeunint典型案列"><a class="header" href="#maybeunint典型案列">MaybeUnint<T>典型案列</a></h4>
<p>对T类型变量申请内存及赋值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::mem::MaybeUninit;

    // 获得一个未初始化的i32引用类型内存
    let mut x = MaybeUninit::&lt;&amp;i32&gt;::uninit();
    // 将&amp;0写入变量，完成初始化
    x.write(&amp;0);
    // 将初始化后的变量解封装供后继的代码使用。
    let x = unsafe { x.assume_init() };
<span class="boring">}</span></code></pre></pre>
<p>以上代码，编译器不会对x.write进行报警，这是<code>MaybeUninit&lt;T&gt;</code>的最重要的应用，这个例子展示了RUST如何给未初始化内存赋值的处理方式。调用assume_init前，必须保证变量已经被正确初始化。</p>
<p>更复杂的初始化例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::mem::{self, MaybeUninit};
    
    let data = {
    // data在声明后实际上就已经初始化完毕。
    let mut data: [MaybeUninit&lt;Vec&lt;u32&gt;&gt;; 1000] = unsafe {
        //这里注意实际调用是
        //MaybeUninit::&lt;[MaybeUninit&lt;Vec&lt;u32&gt;&gt;;1000]&gt;::uninit(),
        //RUST的类型推断机制完成了泛型实例化
        MaybeUninit::uninit().assume_init()
    };
    
    for elem in &amp;mut data[..] {
    elem.write(vec![42]);
    }
    
    // 直接用transmute完成整个数组类型的转换
    // 仔细思考一下，这里除了用transmute，似乎没有其他办法了，
    unsafe { mem::transmute::&lt;_, [Vec&lt;u32&gt;; 1000]&gt;(data) }
    };
    
    assert_eq!(&amp;data[0], &amp;[42]);
<span class="boring">}</span></code></pre></pre>
<p>下面例子说明一块内存被 <code>MaybeUnint&lt;T&gt;</code>封装后，编译器将不再对其做释放，必须在代码中显式释放：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::mem::MaybeUninit;
    use std::ptr;
   
    let mut data: [MaybeUninit&lt;String&gt;; 1000] = unsafe { MaybeUninit::uninit().assume_init() };
    // 初始化了500个String变量
    let mut data_len: usize = 0;
    for elem in &amp;mut data[0..500] {
        //write没有将所有权转移出ManuallyDrop
        elem.write(String::from(&quot;hello&quot;));
        data_len += 1;
    }
    //编译器无法自动调用drop释放String变量, 
    //必须显式用drop_in_place释放
    for elem in &amp;mut data[0..data_len] {
        //实际上也可以调用assume_init_drop来完成此工作
        unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }
    }
<span class="boring">}</span></code></pre></pre>
<p>上例中，在没有assume_init()调用的情况下，必须手工调用drop_in_place释放内存。<br />
<code>MaybeUninit&lt;T&gt;</code>是一个非常重要的类型结构，未初始化内存是编程中不可避免要遇到的情况，<code>MaybeUninit&lt;T&gt;</code>也就是RUST编程中必须熟练使用的一个类型。</p>
<h2 id="裸指针模块再分析"><a class="header" href="#裸指针模块再分析">裸指针模块再分析</a></h2>
<p>有了<code>MaybeUnint&lt;T&gt;</code>做基础后，可以对裸指针其他至关重要的标准库函数做出分析</p>
<p><code>ptr::read&lt;T&gt;(src: *const T) -&gt; T</code> 此函数在<code>MaybeUninit&lt;T&gt;</code>节中已经给出了代码，ptr::read是对所有类型通用的一种复制方法，需要指出，此函数完成浅拷贝，复制后，src指向的变量的所有权会转移至返回值。所以，调用此函数的代码必须保证src指向的变量生命周期结束后不会被编译器自动调用drop，否则可能导致重复drop，出现UB问题。 </p>
<p><code>ptr::read_unaligned&lt;T&gt;(src: *const T) -&gt; T</code>当数据结构中有未内存对齐的成员变量时，需要用此函数读取内容并转化为内存对齐的变量。否则会引发UB(undefined behaiver) 如下例：</p>
<p>从字节数组中读一个usize的值:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   use std::mem;
  
   fn read_usize(x: &amp;[u8]) -&gt; usize {
       assert!(x.len() &gt;= mem::size_of::&lt;usize&gt;());
      
       let ptr = x.as_ptr() as *const usize;
       //此处必须用ptr::read_unaligned，因为不确定字节是否对齐
       unsafe { ptr.read_unaligned() }
   }
<span class="boring">}</span></code></pre></pre>
<p>例子中，为了从byte串中读取一个usize，需要用read_unaligned来获取值，不能象C语言那样通过指针类型转换直接获取值。</p>
<p><code>ptr::write&lt;T&gt;(dst: *mut T, src: T)</code> 代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const unsafe fn write&lt;T&gt;(dst: *mut T, src: T) {
    unsafe {
        //浅拷贝
        copy_nonoverlapping(&amp;src as *const T, dst, 1);
        //必须调用forget，这里所有权已经转移。不允许再对src做drop操作
        intrinsics::forget(src);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>write函数本质上就是一个所有权转移的操作。完成src到dst的浅拷贝，然后调用了forget(src), 这使得src的Drop不再被调用。从而将所有权转移到dst。此函数是mem::replace， mem::transmute_copy的基础。底层由intrisic::copy_no_overlapping支持。 
这个函数中，如果dst已经初始化过，那原dst变量的所有权将被丢失掉，有可能引发内存泄漏。 </p>
<p><code>ptr::write_unaligned&lt;T&gt;(dst: *mut T, src: T)</code> 与read_unaligned相对应。举例如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[repr(packed, C)]
    struct Packed {
        _padding: u8,
        unaligned: u32,
    }
    
    let mut packed: Packed = unsafe { std::mem::zeroed() };
    
    // Take the address of a 32-bit integer which is not aligned.
    // In contrast to `&amp;packed.unaligned as *mut _`, this has no undefined behavior.
    // 对于结构中字节没有按照2幂次对齐的成员，要用addr_of_mut!宏来获得地址，无法用取引用的方式。
    let unaligned = std::ptr::addr_of_mut!(packed.unaligned);
    
    unsafe { std::ptr::write_unaligned(unaligned, 42) };
    
     assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.
<span class="boring">}</span></code></pre></pre>
<p><code>ptr::read_volatile&lt;T&gt;(src: *const T) -&gt; T</code>  是intrinsics::volatile_load的封装<br />
<code>ptr::write_volatile&lt;T&gt;(dst: *mut T, src:T)</code> 是intrinsics::volatiel_store的封装</p>
<p><code>ptr::macro addr_of($place:expr)</code> 因为用&amp;获得引用必须是字节按照2的幂次对齐的地址，所以用这个宏获取非地址对齐的变量地址</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub macro addr_of($place:expr) {
    //关键字是&amp;raw const，这个是RUST的原始引用语义，
    //但目前还没有在官方做公开。区别与&amp;, &amp;要求地址必
    //须满足字节对齐和初始化，&amp;raw 则没有这个问题
    &amp;raw const $place
}
<span class="boring">}</span></code></pre></pre>
<p><code>ptr::macro addr_of_mut($place:expr)</code> 作用同上。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub macro addr_of_mut($place:expr) {
    &amp;raw mut $place
}
<span class="boring">}</span></code></pre></pre>
<p>指针的通用函数请参考<a href="https://doc.rust-lang.org/core/ptr/index.html#functions">Rust库函数参考</a></p>
<h2 id="nonnullt代码分析"><a class="header" href="#nonnullt代码分析"><code>NonNull&lt;T&gt;</code>代码分析</a></h2>
<p>结构体定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct NonNull&lt;T: ?Sized&gt; {
    pointer: *const T,
}
<span class="boring">}</span></code></pre></pre>
<p>属性<code>repr(transparent)</code>实际上表示外部的封装结构在内存中等价于内部的变量。<code>NonNull&lt;T&gt;</code>在内存中与<code>*const T</code>完全一致。可以直接强转为<code>* const T</code>。<br />
裸指针的值因为可以为0，如果敞开来用，会有很多无法控制的代码隐患。按照RUST的习惯，标准库定义了非0的指针封装结构<code>NonNull&lt;T&gt;</code>，从而可以用<code>Option&lt;NonNull&lt;T&gt;&gt;</code>来对值可能为0的裸指针做出强制安全代码逻辑。不需要Option的则认为裸指针不会取值为0。<br />
<code>NonNull&lt;T&gt;</code>本身是协变(covarient)类型.<br />
<strong>RUST中的协变，在RUST中，不同的生命周期被视为<em>不同的类型</em>，对于带有生命周期的类型变量做赋值操作时，仅允许子类型赋给基类型(长周期赋给短周期), 为了从基本类型生成复合类型的子类型和基类型的关系，RUST引入了协变性。从基本类型到复合类型的协变性有 协变(covarient)/逆变(contracovarient)/不变(invarient)三种</strong> 
程序员分析代码时，可以从基本类型之间的生命周期关系及协变性确定复合类型变量之间的生命周期关系，从而做合适的赋值操作。</p>
<p>因为<code>NonNull&lt;T&gt;</code>实际上是封装<code>* mut T</code>类型，但<code>* mut T</code> 与<code>NonNull&lt;T&gt;</code>的协变性不同，所以程序员如果不能确定需要协变类型，就不要使用<code>NonNull&lt;T&gt;</code></p>
<h3 id="nonnullt创建关联方法"><a class="header" href="#nonnullt创建关联方法"><code>NonNull&lt;T&gt;</code>创建关联方法</a></h3>
<p>创建一个悬垂(dangling)指针, 保证指针满足类型内存对齐要求。该指针可能指向一个正常的变量，所以不能认为指向的内存是未初始化的。dangling实际表示<code>NonNull&lt;T&gt;</code>无意义，与<code>NonNull&lt;T&gt;</code>的本意有些违背，因为这个语义可以用None来实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn dangling() -&gt; Self {
        unsafe {
            //取内存对齐地址作为裸指针的地址。
            //调用者应保证不对此内存地址进行读写
            let ptr = mem::align_of::&lt;T&gt;() as *mut T;
            NonNull::new_unchecked(ptr)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>new函数，由输入的<code>*mut T</code>裸指针创建<code>NonNull&lt;T&gt;</code>。代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn new(ptr: *mut T) -&gt; Option&lt;Self&gt; {
        if !ptr.is_null() {
            //ptr的安全性已经检查完毕
            Some(unsafe { Self::new_unchecked(ptr) })
        } else {
            None
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>NonNull::&lt;T&gt;::new_unchecked(* mut T)-&gt;Self</code> 用<code>* mut T</code>生成NonNull<T>，不检查<code>* mut T</code>是否为0，调用者应保证<code>* mut T</code>不为0。</p>
<p>from_raw_parts函数，类似裸指针的from_raw_parts。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn from_raw_parts(
        data_address: NonNull&lt;()&gt;,
        metadata: &lt;T as super::Pointee&gt;::Metadata,
    ) -&gt; NonNull&lt;T&gt; {
        unsafe {
            //需要先用from_raw_parts_mut形成* mut T指针
            NonNull::new_unchecked(super::from_raw_parts_mut(data_address.as_ptr(), metadata))
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>由From trait创建<code>NonNull&lt;T&gt;</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; const From&lt;&amp;mut T&gt; for NonNull&lt;T&gt; {
    fn from(reference: &amp;mut T) -&gt; Self {
        unsafe { NonNull { pointer: reference as *mut T } }
    }
}

impl&lt;T: ?Sized&gt; const From&lt;&amp;T&gt; for NonNull&lt;T&gt; {
    fn from(reference: &amp;T) -&gt; Self {
        //此处说明NonNull也可以接收不可变引用，
        //代码要注意在后继不能将这个变量转换为可变引用
        unsafe { NonNull { pointer: reference as *const T } }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="nonnullt类型转换方法"><a class="header" href="#nonnullt类型转换方法"><code>NonNull&lt;T&gt;</code>类型转换方法</a></h3>
<p><code>NonNull&lt;T&gt;</code>的方法基本与<code>*const T/* mut T</code>相同，也容易理解，下文仅做罗列和简单说明<br />
<code>NonNull::&lt;T&gt;::as_ptr(self)-&gt;* mut T</code> 返回内部的pointer 裸指针<br />
<code>NonNull::&lt;T&gt;::as_ref&lt;'a&gt;(&amp;self)-&gt;&amp;'a T </code> 返回的引用的生命周期与self的生命周期独立，由调用代码保证正确性。<br />
<code>NonNull::&lt;T&gt;::as_mut&lt;'a&gt;(&amp;mut self)-&gt;&amp;'a mut T</code> 与 as_ref类似，但返回可变引用。<br />
<code>NonNull::&lt;T&gt;::cast&lt;U&gt;(self)-&gt;NonNull&lt;U&gt;</code> 指针类型转换，程序员应该保证T和U的内存布局相同 </p>
<h3 id="nonnullt-方法"><a class="header" href="#nonnullt-方法"><code>NonNull&lt;[T]&gt;</code> 方法</a></h3>
<p><code>NonNull::&lt;[T]&gt;::slice_from_raw_parts(data: NonNull&lt;T&gt;, len: usize) -&gt; Self</code> 将类型指针转化为类型的切片类型指针，实质是<code>ptr::slice_from_raw_parts</code>的一种包装。<br />
<code>NonNull::&lt;[T]&gt;::as_non_null_ptr(self) -&gt; NonNull&lt;T&gt;</code> * const [T]::as_ptr的NonNull版本</p>
<h3 id="nonnullt的使用实例"><a class="header" href="#nonnullt的使用实例"><code>NonNull&lt;T&gt;</code>的使用实例</a></h3>
<p>以下的实例展示了 <code>NonNull&lt;T&gt;</code>在动态申请堆内存的使用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Global {
        fn alloc_impl(&amp;self, layout: Layout, zeroed: bool) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
            match layout.size() {
                0 =&gt; Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
                // SAFETY: `layout` is non-zero in size,
                size =&gt; unsafe {
                    //raw_ptr是 *const u8类型
                    let raw_ptr = if zeroed { alloc_zeroed(layout) } else { alloc(layout) };
                    //NonNull::new处理了raw_ptr为零的情况,返回NonNull&lt;u8&gt;,
                    //此时内存长度还与T不匹配
                    let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                    //将NonNull&lt;u8&gt;转换为NonNull&lt;[u8]&gt;, NonNull&lt;[u8]&gt;已经
                    //是类型T的内存长度。后继可以直接转换为T类型的指针了。
                    //这个转换极为重要。
                    Ok(NonNull::slice_from_raw_parts(ptr, size))
                },
            }
        }
        ....
    }
<span class="boring">}</span></code></pre></pre>
<p>基本上，如果<code>* const T/*mut T</code>要跨越函数使用，或作为数据结构体的成员时，应将之转化成<code>NonNull&lt;T&gt;</code> 或<code>Unique&lt;T&gt;</code>。<code>*const T</code>应该仅仅保持在单一函数内。</p>
<h4 id="nonnullt-与maybeuninitt相关函数"><a class="header" href="#nonnullt-与maybeuninitt相关函数"><code>NonNull&lt;T&gt;</code> 与<code>MaybeUninit&lt;T&gt;</code>相关函数</a></h4>
<p><code>NonNull&lt;T&gt;::as_uninit_ref&lt;'a&gt;(&amp;self) -&gt; &amp;'a MaybeUninit&lt;T&gt;</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub unsafe fn as_uninit_ref&lt;'a&gt;(&amp;self) -&gt; &amp;'a MaybeUninit&lt;T&gt; {
        // self.cast将NonNull&lt;T&gt;转换为NonNull&lt;MaybeUninit&lt;T&gt;&gt;
        //self.cast.as_ptr将NonNull&lt;MaybeUninit&lt;T&gt;&gt;转换为 *mut MaybeUninit&lt;T&gt;
        unsafe { &amp;*self.cast().as_ptr() }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>NonNull&lt;T&gt;::as_uninit_mut&lt;'a&gt;(&amp;self) -&gt; &amp;'a mut MaybeUninit&lt;T&gt;</code><br />
<code>NonNull&lt;[T]&gt;::as_uninit_slice&lt;'a&gt;(&amp;self) -&gt; &amp;'a [MaybeUninit&lt;T&gt;]</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub unsafe fn as_uninit_slice&lt;'a&gt;(&amp;self) -&gt; &amp;'a [MaybeUninit&lt;T&gt;] {
        // 下面的函数调用ptr::slice_from_raw_parts
        unsafe { slice::from_raw_parts(self.cast().as_ptr(), self.len()) }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>NonNull&lt;[T]&gt;::as_uninit_slice_mut&lt;'a&gt;(&amp;self) -&gt; &amp;'a mut [MaybeUninit&lt;T&gt;]</code></p>
<h2 id="uniquet-代码分析"><a class="header" href="#uniquet-代码分析"><code>Unique&lt;T&gt;</code> 代码分析</a></h2>
<p><code>Unique&lt;T&gt;</code>类型结构定义如下:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[repr(transparent)]
    pub struct Unique&lt;T: ?Sized&gt; {
        pointer: *const T,
        _marker: PhantomData&lt;T&gt;,
    }
<span class="boring">}</span></code></pre></pre>
<p>和<code>NonNull&lt;T&gt;</code>对比，<code>Unique&lt;T&gt;</code>多了<code>PhantomData&lt;T&gt;</code>类型成员。这个定义使得编译器知晓，<code>Unique&lt;T&gt;</code>拥有了pointer指向的内存的所有权，<code>NonNull&lt;T&gt;</code>没有这个特性。具备所有权后，<code>Unique&lt;T&gt;</code>可以实现Send, Sync等trait。因为获得了所有权，此块内存无法用于他处，这也是Unique的名字由来原因.
指针在被<code>Unique&lt;T&gt;</code>封装前，必须保证是NonNull的。
对于RUST从堆内存申请的内存块，其指针都是用<code>Unique&lt;T&gt;</code>封装后来作为智能指针结构体内部成员变量，保证智能指针结构体拥有申请出来的内存块的所有权。</p>
<p><code>Unique&lt;T&gt;</code>模块的函数及代码与<code>NonNull&lt;T&gt;</code>函数代码相类似，此处不分析。
<code>Unique::cast&lt;U&gt;(self)-&gt;Unique&lt;U&gt;</code> 类型转换，程序员应该保证T和U的内存布局相同<br />
<code>Unique::&lt;T&gt;::new(* mut T)-&gt;Option&lt;Self&gt;</code> 此函数内部判断* mut T是否为0值<br />
<code>Unique::&lt;T&gt;::new_unchecked(* mut T)-&gt;Self</code> 封装* mut T, 调用代码应该保证* mut T的安全性<br />
<code>Unique::as_ptr(self)-&gt;* mut T</code><br />
<code>Unique::as_ref(&amp;self)-&gt;&amp; T</code> 因为Unique具备所有权，此处&amp;T的生命周期与self相同，不必特别声明声明周期<br />
<code>Unique::as_mut(&amp;mut self)-&gt;&amp; mut T</code> 同上</p>
<h2 id="mem模块函数"><a class="header" href="#mem模块函数">mem模块函数</a></h2>
<h3 id="泛型类型创建"><a class="header" href="#泛型类型创建">泛型类型创建</a></h3>
<p><code>mem::zeroed&lt;T&gt;() -&gt; T</code> 返回一个内存块清零的泛型变量，内存块在栈空间，代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn zeroed&lt;T&gt;() -&gt; T {
    // 调用代码必须确认T类型的变量可以取全零值
    unsafe {
        intrinsics::assert_zero_valid::&lt;T&gt;();
        MaybeUninit::zeroed().assume_init()
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>mem::uninitialized&lt;T&gt;() -&gt; T</code> 返回一个未初始化过的泛型变量，内存块在栈空间。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn uninitialized&lt;T&gt;() -&gt; T {
    // 调用者必须确认T类型的变量允许未初始化的任意值
    unsafe {
        intrinsics::assert_uninit_valid::&lt;T&gt;();
        MaybeUninit::uninit().assume_init()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="泛型类型拷贝与替换"><a class="header" href="#泛型类型拷贝与替换">泛型类型拷贝与替换</a></h3>
<p>下面的take及replace都是针对在只有引用的情况下对变量值作更新。这对于结构体成员更新值非常重要。因为在使用结构体引用时，无法单独的转移结构体成员的所有权，而更新值往往需要获取所有权，修改，然后再将新值赋回。此场景一般用take来获取所有权，修改后再用replace将值更新。</p>
<p><code>mem::take&lt;T: Default&gt;(dest: &amp;mut T) -&gt; T</code> 将dest设置为默认内容(不改变所有权)，用一个新变量返回dest的内容。这里有一个坑，即任何类型的default()必然能够满足多次drop不会出现内存安全问题。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn take&lt;T: Default&gt;(dest: &amp;mut T) -&gt; T {
    //即mem::replace，见下文
    //此处，对于引用类型，编译器禁止用*dest来转移所有权，
    //所以不能用let xxx = *dest; xxx这种形式返回T
    //其他语言简单的事情在RUST中必须用一个较难理解的方
    //式来进行解决。replace()对所有权有仔细的处理
    replace(dest, T::default())
}
<span class="boring">}</span></code></pre></pre>
<p><code>mem::replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T</code> 用src的内容赋值dest(不改变所有权)，用一个新变量返回dest的内容。replace函数的难点在于了解所有权的转移。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T {
    unsafe {
        //因为要替换dest, 所以必须对dest原有变量的所有权做处理，
        //因此先用read将*dest的所有权转移到T，交由调用者进行处理, 
        //RUST不支持对引用类型做解引用的相等来转移所有权。将一个引用
        //的所有权进行转移的方式只有粗暴的内存浅拷贝这种方法。
        //使用这个函数，调用代码必须了解T类型的情况，T类型有可能需要
        //显式的调用drop函数。ptr::read前文已经分析过。
        let result = ptr::read(dest);
        //ptr::write本身会导致src的所有权转移到dest，后继不允许
        //在src生命周期终止时做drop。ptr::write会用forget(src)做到这一点。
        ptr::write(dest, src);
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>mem::transmute_copy&lt;T, U&gt;(src: &amp;T) -&gt; U</code> 新建类型U的变量，并把src的内容拷贝到U。调用者应保证T类型的内容与U一致，src后继的所有权问题需要做处理。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const unsafe fn transmute_copy&lt;T, U&gt;(src: &amp;T) -&gt; U {
    if align_of::&lt;U&gt;() &gt; align_of::&lt;T&gt;() {
        // 如果两个类型字节对齐U 大于 T. 使用read_unaligned
        unsafe { ptr::read_unaligned(src as *const T as *const U) }
    } else {
        //用read即可完成
        unsafe { ptr::read(src as *const T as *const U) }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="所有权转移的底层实现"><a class="header" href="#所有权转移的底层实现">所有权转移的底层实现</a></h4>
<p>所有权的本质是只能对变量做一次drop操作。变量的drop操作会引起变量结构体内部成员的链式drop。
所以，只要引发了变量的浅拷贝，所有权便被转移。原先放置变量的那块内存就必须被处理，forget及ManuallyDrop是两种典型方案。
不涉及裸指针的代码，一般不必考虑所有权必须人工处理的情况。但一旦涉及到裸指针，那就必须注意看是否出现了一个变量的双份或多份拷贝，每多一次拷贝，意味着编译器会对变量多做一次drop，触发UB。</p>
<h5 id="变量调用drop的时机"><a class="header" href="#变量调用drop的时机">变量调用drop的时机</a></h5>
<p>如下例子：</p>
<pre><pre class="playground"><code class="language-rust">struct TestPtr {a: i32, b:i32}
impl Drop for TestPtr {
    fn drop(&amp;mut self) {
        println!(&quot;{} {}&quot;, self.a, self.b);
    }
}
fn main() {
   let test = Box::new(TestPtr{a:1,b:2});
   let test1 = *test;
   let mut test2 = TestPtr{a:2, b:3};
   //此行代码会导致先释放test2拥有所有权的变量，
   //然后再给test2赋值。代码后的输出会给出证据
   //将test1的所有权转移给test2，无疑代表着test2
   //现有的所有权会在后继无法访问，因此drop被立即调用。
   test2 = test1;
   println!(&quot;{:?}&quot;, test2);
}</code></pre></pre>
<p>输出：
2 3
TestPtr { a: 1, b: 2 }
1 2</p>
<h3 id="其他函数"><a class="header" href="#其他函数">其他函数</a></h3>
<p><code>mem::forget&lt;T&gt;(t:T)</code> 通知RUST不做变量的drop操作</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn forget&lt;T&gt;(t: T) {
    //没有使用intrinsic::forget, 实际上效果
    //一致，这里应该是尽量规避用intrinsic函数
    let _ = ManuallyDrop::new(t);
}
<span class="boring">}</span></code></pre></pre>
<p><code>mem::forget_unsized&lt;T:Sized?&gt;</code> 对intrinsics::forget的封装<br />
<code>mem::size_of&lt;T&gt;()-&gt;usize</code>/<code>mem::min_align_of&lt;T&gt;()-&gt;usize</code>/<code>mem::size_of_val&lt;T&gt;(val:&amp; T)-&gt;usize</code>/<code>mem::min_align_of_val&lt;T&gt;(val: &amp;T)-&gt;usize</code>/<code>mem::needs_drop&lt;T&gt;()-&gt;bool</code> 基本就是直接调用intrinsic模块的同名函数<br />
<code>mem::drop&lt;T&gt;(_x:T)</code> 释放内存</p>
<h2 id="rust堆内存申请及释放"><a class="header" href="#rust堆内存申请及释放">RUST堆内存申请及释放</a></h2>
<h3 id="rust类型系统的内存布局"><a class="header" href="#rust类型系统的内存布局">RUST类型系统的内存布局</a></h3>
<p>RUST提供了<code>Layout</code>内存布局类型, 此布局类型结构主要用于做堆内存申请。
<code>Layout</code>的数据结构如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Layout {
    // 类型需占用的内存大小，用字节数目表示
    size_: usize,
    //  按照此字节数目进行类型内存对齐， 
    //  NonZeroUsize见代码后面文字分析
    align_: NonZeroUsize,
}
<span class="boring">}</span></code></pre></pre>
<p><em><code>NonZeroUsize</code>是一种非0值的usize, 这种类型主要应用于不可取0的值，本结构中， 字节对齐属性变量不能被置0，所以用<code>NonZeroUsize</code>来确保安全性。如果用usize类型，那代码中就可能会把0置给align_，导致bug产生。这是RUST的一个设计规则，所有的约束要在类型定义即显性化，从而使bug在编译中就被发现。</em></p>
<p>每一个RUST的类型都有自身独特的内存布局Layout。一种类型的Layout可以用<code>intrinsic::&lt;T&gt;::size_of()</code>及<code>intrinsic::&lt;T&gt;::min_align_of()</code>获得的类型内存大小和对齐来获得。
RUST的内存布局更详细原理阐述请参考[RUST内存布局] (https://doc.rust-lang.org/nomicon/data.html)，
Layout比较有典型意义的函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Layout {
    ...
    ...

    //array函数是计算n个T类型变量形成的数组所需的Layout，
    //是从代码了解Rust Layout概念的一个好的实例
    //这里主要注意的是T类型的对齐会导致内存申请不是T类型的内存大小*n
    //而且对齐也是数组的算法
    pub fn array&lt;T&gt;(n: usize) -&gt; Result&lt;Self, LayoutError&gt; {
        //获得n个T类型的内存Layout
        let (layout, offset) = Layout::new::&lt;T&gt;().repeat(n)?;
        debug_assert_eq!(offset, mem::size_of::&lt;T&gt;());
        //以完全对齐的大小  ，得出数组的Layout
        Ok(layout.pad_to_align())
    }

    //计算n个T类型需要的内存Layout, 以及成员之间的空间
    pub fn repeat(&amp;self, n: usize) -&gt; Result&lt;(Self, usize), LayoutError&gt; {
        // 所有的成员必须以成员的对齐大小来做内存对齐,首先计算对齐需要的padding空间
        let padded_size = self.size() + self.padding_needed_for(self.align());
        // 计算共需要多少内存空间，如果溢出，返回error
        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutError)?;

        //由已经验证过得原始数据生成Layout，并返回单成员占用的空间
        unsafe { Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size)) }
    }

    //填充以得到一个与T类型完全对齐的，最小的内存大小的Layout
    pub fn pad_to_align(&amp;self) -&gt; Layout {
        //得到T类型与对齐之间的空间大小
        let pad = self.padding_needed_for(self.align());
        // 完全对齐的大小
        let new_size = self.size() + pad;
        
        //以完全对齐的大小生成新的Layout
        Layout::from_size_align(new_size, self.align()).unwrap()
    }

    //计算T类型长度与完全对齐的差
    pub const fn padding_needed_for(&amp;self, align: usize) -&gt; usize {
        let len = self.size();

        // 实际上相当与C语言的表达式
        //   len_rounded_up = (len + align - 1) &amp; !(align - 1);
        // 就是对对齐大小做除，如果有余数，商加1，是一种常用的方式.
        // 但注意，在rust中C语言的&quot;+&quot;等同于wrapping_add, C语言的“-”等同于
        // wrapping_sub
        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) &amp; !align.wrapping_sub(1);
        //减去len，得到差值
        len_rounded_up.wrapping_sub(len)
    }

    //不检查输入参数，根据输入参数表示的原始数据生成Layout变量,调用代码应保证安全性
    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -&gt; Self {
        // 必须保证align满足不为0.
        Layout { size_: size, align_: unsafe { NonZeroUsize::new_unchecked(align) } }
    }

    //对参数进行检查，生成一个类型的Layout
    pub const fn from_size_align(size: usize, align: usize) -&gt; Result&lt;Self, LayoutError&gt; {
        //必须保证对齐是2的幂次
        if !align.is_power_of_two() {
            return Err(LayoutError);
        }

        //满足下面的表达式，则size将不可能对齐 
        if size &gt; usize::MAX - (align - 1) {
            return Err(LayoutError);
        }

        // 参数已经检查完毕.
        unsafe { Ok(Layout::from_size_align_unchecked(size, align)) }
    }
    ...
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reprtransparent内存布局模式"><a class="header" href="#reprtransparent内存布局模式"><code>#[repr(transparent)]</code>内存布局模式</a></h3>
<p>repr(transparent)用于仅包含一个成员变量的类型，该类型的内存布局与成员变量类型的内存布局完全一致。类型仅仅具备编译阶段的意义，在运行时，类型变量与其成员变量可以认为是一个相同变量，可以相互无障碍类型转换。使用repr(transparent)布局的类型基本是一种封装结构。</p>
<h4 id="reprpacked内存布局模式"><a class="header" href="#reprpacked内存布局模式"><code>#[repr(packed)]</code>内存布局模式</a></h4>
<p>强制类型成员变量以1字节对齐，此种结构在协议分析和结构化二进制数据文件中经常使用</p>
<h4 id="repralignn-内存布局模式"><a class="header" href="#repralignn-内存布局模式"><code>#[repr(align(n))]</code> 内存布局模式</a></h4>
<p>强制类型以2的幂次对齐</p>
<h4 id="reprrust内存布局模式"><a class="header" href="#reprrust内存布局模式"><code>#[repr(RUST)]</code>内存布局模式</a></h4>
<p>默认的布局方式，采用此种布局，RUST编译器会根据情况来自行优化内存</p>
<h4 id="reprc内存布局模式"><a class="header" href="#reprc内存布局模式"><code>#[repr(C)]</code>内存布局模式</a></h4>
<p>采用C语言布局方式， 所有结构变量按照声明的顺序在内存排列。默认4字节对齐。</p>
<h3 id="rust堆内存申请与释放接口"><a class="header" href="#rust堆内存申请与释放接口">RUST堆内存申请与释放接口</a></h3>
<p>资深的C/C++程序员都了解，在大型系统开发时，往往需要自行实现内存管理模块，以根据系统的特点优化内存使用及性能，并作出内存跟踪。
对于操作系统，内存管理模块更是核心功能。
对于C/C++小型系统，没有内存管理，仅仅是调用操作系统的内存系统调用，内存管理交给操作系统负责。操作系统内存管理模块接口是内存申请及内存释放的系统调用
对于GC语言，内存管理由虚拟机或语言运行时负责，利用语言提供的new来完成类型结构内存获取。
RUST的内存管理分成了三个界面：</p>
<ol>
<li>由智能指针类型提供的类型创建函数，一般有new, 与其他的GC类语言相同，同时增加了一些更直观的函数。</li>
<li>智能指针使用实现Allocator Trait的类型做内存申请及释放。Allocator使用编译器提供的函数名申请及释放内存。</li>
<li>实现了GlobalAlloc Trait的类型来完成独立的内存管理模块，并用#[global_allocator]注册入编译器，替代编译器默认的内存申请及释放函数。
这样，RUST达到了：</li>
<li>对于小规模的程序，拥有与GC语言相类似的内存获取机制</li>
<li>对于大型程序和操作系统内核，从语言层面提供了独立的内存管理模块接口，达成了将现代语法与内存管理模块共同存在，相互配合的目的。
但因为所有权概念的存在，从内存申请到转换为类型系统仍然还存在复杂的工作。
堆内存申请和释放的Trait GlobalAlloc定义如下:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe trait GlobalAlloc {
    //申请内存，因为Layout中内存大小不为0，所以，alloc不会申请大小为0的内存
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8;
    //释放内存
    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout);
    
    //申请后的内存应初始化为0
    unsafe fn alloc_zeroed(&amp;self, layout: Layout) -&gt; *mut u8 {
        let size = layout.size();
        let ptr = unsafe { self.alloc(layout) };
        if !ptr.is_null() {
            // 此处必须使用write_bytes，确保每个字节都清零
            unsafe { ptr::write_bytes(ptr, 0, size) };
        }
        ptr
    }

    //其他方法
    ...
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>在内核编程或大的框架系统编程中，开发人员通常开发自定义的堆内存管理模块，模块实现GlobalAlloc Trait并添加#[global_allocator]标识。对于用户态，RUST标准库有默认的GlobalAlloc实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;Rust&quot; {
    // 编译器会将实现了GlobalAlloc Trait，并标记 
    //#[global_allocator]的四个方法自动转化为以下的函数
    #[rustc_allocator]
    #[rustc_allocator_nounwind]
    fn __rust_alloc(size: usize, align: usize) -&gt; *mut u8;
    #[rustc_allocator_nounwind]
    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);
    #[rustc_allocator_nounwind]
    fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -&gt; *mut u8;
    #[rustc_allocator_nounwind]
    fn __rust_alloc_zeroed(size: usize, align: usize) -&gt; *mut u8;
}

//对__rust_xxxxx_再次封装
pub unsafe fn alloc(layout: Layout) -&gt; *mut u8 {
    unsafe { __rust_alloc(layout.size(), layout.align()) }
}

pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
    unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }
}

pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -&gt; *mut u8 {
    unsafe { __rust_realloc(ptr, layout.size(), layout.align(), new_size) }
}

pub unsafe fn alloc_zeroed(layout: Layout) -&gt; *mut u8 {
    unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }
}

<span class="boring">}</span></code></pre></pre>
<p>再实现Allocator Trait，对以上四个函数做封装处理。作为RUST其他模块对堆内存的申请和释放接口。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe trait Allocator {
    fn allocate(&amp;self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt;;

    fn allocate_zeroed(&amp;self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        let ptr = self.allocate(layout)?;
        // SAFETY: `alloc` returns a valid memory block
        // 复杂的类型转换，实际是调用 *const u8::write_bytes(0, layout.size_)
        unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }
        Ok(ptr)
    }

    unsafe fn deallocate(&amp;self, ptr: NonNull&lt;u8&gt;, layout: Layout);

    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Global 实现了 Allocator Trait。Rust大部分alloc库数据结构的实现使用Global作为Allocator。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl Allocator for Global {
    fn allocate(&amp;self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        //上文已经给出alloc_impl的说明
        self.alloc_impl(layout, false)
    }

    fn allocate_zeroed(&amp;self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        self.alloc_impl(layout, true)
    }

    unsafe fn deallocate(&amp;self, ptr: NonNull&lt;u8&gt;, layout: Layout) {
        if layout.size() != 0 {
            // SAFETY: `layout` is non-zero in size,
            // other conditions must be upheld by the caller
            unsafe { dealloc(ptr.as_ptr(), layout) }
        }
    }
    ...
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Allocator使用GlobalAlloc接口获取内存，然后将GlobalAlloc申请到的* mut u8转换为确定大小的单一指针NonNull&lt;[u8]&gt;， 并处理申请内存可能出现的不成功。NonNull&lt;[u8]&gt;此时内存布局与 T的内存布局已经相同，后继可以转换为真正需要的T的指针并进一步转化为相关类型的引用，从而符合RUST类型系统安全并进行后继的处理。
以上是堆内存的申请和释放。 基于泛型，RUST也巧妙实现了栈内存的申请和释放机制 <code>mem::MaybeUninit&lt;T&gt;</code></p>
<p>用Box的内存申请做综合举例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //此处A是一个A:Allocator类型
    pub fn try_new_uninit_in(alloc: A) -&gt; Result&lt;Box&lt;mem::MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt; {
        //实质是T类型的内存Layout
        let layout = Layout::new::&lt;mem::MaybeUninit&lt;T&gt;&gt;();
        //allocate(layout)?返回NonNull&lt;[u8]&gt;, 
        //NonNull&lt;[u8]&gt;::&lt;MaybeUninit&lt;T&gt;&gt;::cast()返回
        //NonNull&lt;MaybeUninit&lt;T&gt;&gt;
        let ptr = alloc.allocate(layout)?.cast();
        //as_ptr 成为 *mut MaybeUninit&lt;T&gt;类型裸指针
        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
    }
    
    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -&gt; Self {
        //使用Unique封装* mut T，并拥有了*mut T指向的变量的所有权
        Box(unsafe { Unique::new_unchecked(raw) }, alloc)
    }
<span class="boring">}</span></code></pre></pre>
<p>以上代码可以看到，<code>NonNull&lt;[u8]&gt;</code>可以直接通过cast 转换为<code>NonNull&lt;MaybeUninit&lt;T&gt;&gt;</code>, 这是另一种<code>MaybeUninit&lt;T&gt;</code>的生成方法，直接通过指针类型转换将未初始化的内存转换为<code>MaybeUninit&lt;T&gt;</code>。</p>
<h2 id="rust的全局变量内存探讨"><a class="header" href="#rust的全局变量内存探讨">RUST的全局变量内存探讨</a></h2>
<p>RUST支持const 及 static类型的全局变量，且static支持可写操作。所有对static的写操作都是unsafe的。
需要特别注意的，全局变量不支持非Copy trait类型所有权转移，这也很好理解，所有权转移实际上一个内存&quot;move“的操
作。但static变量的内存显然是没有办法&quot;move&quot;的。</p>
<p>static这一性质导致如果要有转移所有权的操作，必须使用mem::replace的方式进行，RUST标准库中很多类型基于mem::replace实现类型自身的replace方法或take方法。</p>
<p>C/C++程序员比较习惯于设计全局变量及其变种静态方法，RUST的全局变量所有权的限制会对这个设计思维有较大的冲击
推荐这篇全局变量的链接： <a href="https://www.sitepoint.com/rust-global-variables/">rust-global-variable</a><br />
下面是摘录的一张图 <img src="./rust%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.png" alt="全局变量使用" /></p>
<h1 id="rust所有权生命周期借用探讨"><a class="header" href="#rust所有权生命周期借用探讨">RUST所有权，生命周期，借用探讨</a></h1>
<p>RUST在定义一个变量时，实际上把变量在逻辑上分成了两个部分，变量的内存块与变量内容。<br />
变量类型定义了内存块内容的格式，变量声明语句定义了一个内存块，变量初始化赋值则在内存块中写入初始化变量内容。<br />
<strong>所有权</strong>指变量内容的独占性。所有权转移指的是变量内容在不同的内存块之间的转移(浅拷贝)。当变量内容转移到新的内存块，旧的内存块就失去了这个变量内容的所有权。由此可见，变量名实际仅代表一个内存块，内存块的变量内容与变量名是一个暂时关联关系，RUST定义这种关联关系为<strong>绑定</strong>。<br />
设计所有权的目的是保证对变量进行清理操作的正确，如果一个变量内容在多个内存块中有效，变量清理的正确性用静态编译的方法无法保证。<br />
这里有个例外，就是实现Copy trait的类型变量不做所有权转移操作，实现Copy trait的类型可通过栈拷贝完成变量内容赋值，清理也可以仅通过通常的调用栈返回完成。<br />
RUST被设计成自动调用变量类型的drop以完成清理，对变量的生命周期跟踪成为一个必然的选择，在判断变量的生命周期终结的时候调用变量的drop函数。</p>
<p>RUST采用生命周期仅与内存块(变量名)相关联的设计，这样的设计容易对生命周期进行跟踪。没有绑定所有权的内存块在生命周期终结不做任何操作，拥有所有权的内存块生命周期终结会自动触发变量的drop操作。<br />
如果仅仅考虑drop操作，那生命周期的方案不会太复杂，但RUST决定用生命周期同时解决另一个问题，变量引用导致的野指针问题。因为所有权的关系，RUST将变量引用改了一个RUST的名字——<strong>借用</strong>，意味着对所有权的借用。
用生命周期解决借用导致的野指针问题思路很简单，就是借用的生命周期应该短于所有权的生命周期。但这个简单的思路却需要极为复杂的设计来完成，对这个复杂设计的理解也成了RUST最被人诟病的点。</p>
<p>理想的生命周期方案是完全由编译器搞定，程序员不要参与。但这显然不可能，编译器没办法在所有的情况下都能够完成全部的推断，势必需要程序员在编码中给出提示。生命周期因此成为rust的一个语法部分。</p>
<p>首先，生命周期被设计成一种实现继承语法的<strong>类型</strong>，<strong>每一个生命周期都是一个类型</strong>，不同的生命周期之间的关系用类型继承语法来完成。生命周期类型的继承具体而言: 假设有两个生命周期类型A和B，如果A完全被B包含在内，那就说B继承于A。A是基类型，B是子类型。从继承的概念，B类型能被转换为A类型，A类型无法转换为B类型。也就是说B类型的值能赋给A类型的变量，A类型的值无法赋给B类型变量。
生命周期是类型这一点与直观感觉有区别，毕竟，一个作用域给人的感觉就应该是个值。但是，用类型这个方案：</p>
<ol>
<li>可以利用类型系统来完成生命周期方案，没有给rust编译器增加太大的负担，代码也几乎不受影响。</li>
<li>利用继承语法，在变量赋值时根据类型能否转换完成生命周期长短的判断，是极为巧妙的，简化的，自然的设计。</li>
</ol>
<p>因为生命周期仅对内存块有意义，而在转移所有权的操作中，是两个不同的内存块发生的联系，他们的生命周期彼此独立。所以所有权转移时，所有权变量的类型层次上不涉及生命周期类型转换。如果类型成员中有引用，则见下面的内容。
当对一个引用类型变量做赋值时，便出现了生命周期类型转换，举例分析如下：</p>
<ol>
<li>当声明一个类型引用的变量时，例如:<code>let a: &amp;i32</code> 实质声明了一个i32类型引用的内存块，这个内存块有一个生命周期泛型, 假设为'a,</li>
<li>假设要对此变量赋值为另一个变量的引用，例如: <code>let b:i32 = 4; a = &amp;b;</code> &amp;b实质是对b的内存块进行引用，该内存块的生命周期假设为'b，</li>
<li>赋值实质是将一个&amp;'b i32 类型的变量赋值给&amp;'a i32类型变量。则必然发生<strong>类型转换</strong>关系，这时，只有当'b是'a的子类型时，即'b长于'a时，这个<strong>类型转换</strong>才能被编译器认为正确。</li>
</ol>
<p>以上实际就是生命周期的奥秘所在了，RUST对生命周期设计的关键点就是：</p>
<ol>
<li>在变量赋值时捕捉触发生命周期类型转换的情况</li>
<li>确保类型转换不正确时，给出生命周期不正确的编译错误警告。</li>
</ol>
<p>但是，还有些其他情况需要考虑。<br />
因为引用类型是泛型的一种，那由泛型派生的类型的赋值也就会出现类型转换的问题，例如：<code>*const T，*mut T，Box&lt;T&gt; ,...</code> 具体的类型可以参考RUST Reference。这时，需要由T的继承关系推断出派生类型的继承关系。这就是变异性Variance特性存在的意义，Variance存在三种情况</p>
<ol>
<li>协变covariant，泛型是子类，派生类型也是子类。泛型是父类，派生类型也是父类</li>
<li>逆变contravariant，泛型是子类，派生类型是父类。泛型是父类，派生类型是子类</li>
<li>不变invariant, 泛型的子类还是父类都推导不出派生类型是否是子类还是父类。</li>
</ol>
<p>复合类型之间的继承的关系可根据成员变异性得出。
因为在RUST编程中引用派生类型及其赋值操作的广泛性，所以变异性是一个重要的需要被理解的概念。完整的变异性请参考RUST Reference。</p>
<p>对生命周期推断的复杂性，RUST采用了每个函数自决的方式(推断)。<br />
每一个函数的生命周期类型转换处理正确与否在函数内完成判断(以下为根据逻辑进行的推断，可能不准确)：</p>
<ol>
<li>函数作用域会有一个生命周期泛型；</li>
<li>函数的定义会定义函数参数的生命周期泛型，以及这些生命周期泛型之间的继承关系。显然，函数作用域生命周期泛型是所有输入参数生命周期泛型的基类型</li>
<li>函数的定义会定义输出的生命周期泛型，以及输出的生命周期泛型与输入参数生命周期泛型的继承关系。如果输出是一个借用或由借用派生的类型或者有借用成员的复合类型，则输出的生命周期泛型必须是某一输入生命周期泛型的基类型。</li>
<li>编译器会分析函数中的作用域，针对每个作用域生成生命周期泛型，并形成这些生命周期泛型之间的继承关系，当然，函数内所有生命周期泛型都是函数作用域生命周期泛型的基类型。</li>
<li>根据这些生命周期泛型及他们之间的继承关系，处理函数内操作时引发的生命周期泛型类型转换，并对错误的转换做出错警告。</li>
<li>如果调用了其他函数，则对调用函数的输入参数及输出之间的转换是否正确判断转移至调用函数。</li>
</ol>
<p>如果一个复合类型内部存在引用类型成员或递归至引用类型成员，则必须明确此复合类型的生命周期泛型与成员生命周期泛型的继承关系。一般复合类型的生命周期应该是基类型。</p>
<p>RUST编译器做了很多工作以避免生命周期泛型标注在代码中出现。这部分的工作仍然在持续进行中。
举几个生命周期的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl *const T{
    pub const unsafe fn as_ref&lt;'a&gt;(self) -&gt; Option&lt;&amp;'a T&gt; {
        if self.is_null() { None } else { unsafe { Some(&amp;*self) } }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因为*const T没有生命周期类型与之相关。所以上面这个函数必须声明一个生命周期泛型用于标注返回的生命周期，此泛型独立存在，不与其他生命周期泛型有关系。因此返回的引用变量的生命周期完全决定于调用此函数的代码定义。因为返回引用的生命周期应短于self指向的内存块的生命周期，这只能由调用此函数的代码即程序员来保证，RUST编译器此时无能为力。</p>
<p>RUST中，对于申请的堆内存内存块，通常将其与一个位于栈内存空间的智能指针的类型变量相结合。智能指针类型变量生命周期终止时，调用drop方法释放堆内存的内存块。智能指针类型通常会提供leak函数，将堆内存的内存块与智能指针类型的关联切断。这通常是一个中间状态，需要尽快再将堆内存与另一个智能指针类型的变量建立联系，以便其能重新被纳入生命周期的体系中。</p>
<h2 id="小结-1"><a class="header" href="#小结-1">小结</a></h2>
<p>本章主要分析了RUST标准库内存相关模块， 内存相关模块代码多数不复杂，主要是要对内存块与类型系统之间的转换要有比较深刻的理解，并能领会在实际编码过程中在那些场景会使用内存相关的代码和API。RUST的内存安全给编码加了非常多的限制，有些时候这些限制只有通过内存API来有效的突破。如将引用指向的变量所有权转移出来的take函数。后继我们会看到几乎每个标准库的模块都大量的使用了ptr, mem模块中的方法和函数。只要是大型系统，不熟悉内存模块的代码，基本上无法做出良好的程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust的固有intrinsic函数库"><a class="header" href="#rust的固有intrinsic函数库">RUST的固有（intrinsic）函数库</a></h1>
<p>代码路径：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\intrinsic.rs</p>
<p>intrinsic库函数是指由编译器内置实现的函数，一般如下特点的函数用固有函数：</p>
<ol>
<li>与CPU架构相关性很大，必须利用汇编实现或者利用汇编才能具备最高性能的函数，</li>
<li>和编译器密切相关的函数，由编译器来实现最为合适。<br />
上面内存库章节中已经介绍了内存部分的intrinsic库函数，本节对其他部分做简略介绍</li>
</ol>
<h2 id="intrinsic-原子操作函数"><a class="header" href="#intrinsic-原子操作函数">intrinsic 原子操作函数</a></h2>
<p>原子操作函数主要用于多核CPU，多线程CPU时对数据的原子操作。intrinsic库中atomic_xxx及atomic_xxx_xxx类型的函数即为原子操作函数。原子操作函数主要用于并发编程中做临界保护，并且是其他临界保护机制的基础，如Mutex，RWlock等。</p>
<h2 id="数学函数及位操作函数"><a class="header" href="#数学函数及位操作函数">数学函数及位操作函数</a></h2>
<p>各种整数及浮点的数学函数实现。这一部分放在intrinsic主要是因为现代CPU对浮点计算由很多支持，这些数学函数由汇编语言来实现更具备效率，那就有必要由编译器来内置实现。</p>
<h2 id="intrinsic-指令优化及调试函数"><a class="header" href="#intrinsic-指令优化及调试函数">intrinsic 指令优化及调试函数</a></h2>
<p>断言类: assert_xxxx 类型的函数<br />
函数栈：caller_location</p>
<h2 id="小结-2"><a class="header" href="#小结-2">小结</a></h2>
<p>intrinsic函数库是从编译器层面完成跨CPU架构的一个手段，intrinsic通常被上层的库所封装。但在操作系统编程和框架编程时，仍然会不可避免的需要接触。</p>
<h1 id="rust基本类型代码分析一"><a class="header" href="#rust基本类型代码分析一">RUST基本类型代码分析(一)</a></h1>
<p>原生数据类型，Option类型，Result类型的某些代码是分析其他模块的基础，因此先对这些类型的部分代码做个基础分析。</p>
<h2 id="整形数据类型"><a class="header" href="#整形数据类型">整形数据类型</a></h2>
<p>代码目录如下：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\num</p>
<p>整形数据类型标准库是在整形类型上实现一系列方法和trait。对整形类型标准库分析的主要目的是:</p>
<ol>
<li>更好的了解RUST是如何从细节上来保证代码安全。</li>
<li>RUST将整形数学库及一些其他常用函数纳入了整形类型的方法中，这与其他语言不同，需要了解。</li>
</ol>
<p>整形数据的方法主要有：</p>
<ol>
<li>整形位操作：左移，右移，为1的位数目，为0的位数目，头部为0的位数目，尾部为0的位数目，头部为1的位数目，尾部为1的位数目，循环左移，循环右移</li>
<li>整形字节序操作：字节序反转，位序反转，大小端变换</li>
<li>整形数学函数：针对溢出做各种不同处理的加减乘除，传统的整形数学库函数如对数，幂，绝对值，取两者大值及两者小值</li>
</ol>
<p>整形有有符号整形，无符号整形，大整形(大于计算机字长的整形)，但基本内容都是实现以上方法</p>
<h3 id="无符号整形类型相关库代码分析"><a class="header" href="#无符号整形类型相关库代码分析">无符号整形类型相关库代码分析</a></h3>
<p>标准库用宏简化的对不同位长的无符号整形的方法实现。本文着重介绍若干不易注意的方法，如大小端转换，对数学方法仅给出加法做为代表。代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! uint_impl {
    ($SelfT:ty, $ActualT:ident, $SignedT:ident, $BITS:expr, $MaxV:expr,
        //以下主要是rust doc文档需要
        $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,
        $reversed:expr, $le_bytes:expr, $be_bytes:expr,
        $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) =&gt; {
<span class="boring">}</span></code></pre></pre>
<p>这个宏实现所有无符号整形的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        pub const MIN: Self = 0;
        //按位非
        pub const MAX: Self = !0;

        pub const BITS: u32 = $BITS;
<span class="boring">}</span></code></pre></pre>
<p>以上是无符号整形的常量</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        //利用intrinsics的位函数完成整数的位操作相关函数，
        //这里仅分析一个，其他请参考标准库手册
        pub const fn count_ones(self) -&gt; u32 {
            intrinsics::ctpop(self as $ActualT) as u32
        }

        //其他位操作函数
        ...
        ...
<span class="boring">}</span></code></pre></pre>
<p>字节序变换是网络编程与结构化数据文件的必须功能，RUST将之在整形的方法里实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        //变量内存空间的字节序交换
        pub const fn swap_bytes(self) -&gt; Self {
            intrinsics::bswap(self as $ActualT) as Self
        }
        
        //big endian 到硬件架构字节序
        pub const fn from_be(x: Self) -&gt; Self {
            #[cfg(target_endian = &quot;big&quot;)]
            {
                x
            }
            #[cfg(not(target_endian = &quot;big&quot;))]
            {
                x.swap_bytes()
            }
        }

        //little endian 转换为硬件架构字节序
        pub const fn from_le(x: Self) -&gt; Self {
            #[cfg(target_endian = &quot;little&quot;)]
            {
                x
            }
            #[cfg(not(target_endian = &quot;little&quot;))]
            {
                x.swap_bytes()
            }
        }

        //硬件架构字节序到big endian
        pub const fn to_be(self) -&gt; Self { // or not to be?
            #[cfg(target_endian = &quot;big&quot;)]
            {
                self
            }
            #[cfg(not(target_endian = &quot;big&quot;))]
            {
                self.swap_bytes()
            }
        }

        //硬件架构字节序到little endian
        pub const fn to_le(self) -&gt; Self {
            #[cfg(target_endian = &quot;little&quot;)]
            {
                self
            }
            #[cfg(not(target_endian = &quot;little&quot;))]
            {
                self.swap_bytes()
            }
        }

        //获得大端字节序字节数组
        pub const fn to_be_bytes(self) -&gt; [u8; mem::size_of::&lt;Self&gt;()] {
            self.to_be().to_ne_bytes()
        }
        
        //获得小端
        pub const fn to_le_bytes(self) -&gt; [u8; mem::size_of::&lt;Self&gt;()] {
            self.to_le().to_ne_bytes()
        }
        
        //硬件平台字节序
        pub const fn to_ne_bytes(self) -&gt; [u8; mem::size_of::&lt;Self&gt;()] {
            unsafe { mem::transmute(self) }
        }
        
        //从big endian 字节数组获得类型值
        pub const fn from_be_bytes(bytes: [u8; mem::size_of::&lt;Self&gt;()]) -&gt; Self {
            Self::from_be(Self::from_ne_bytes(bytes))
        }

        //从little endian 字节数组获得类型值
        pub const fn from_le_bytes(bytes: [u8; mem::size_of::&lt;Self&gt;()]) -&gt; Self {
            Self::from_le(Self::from_ne_bytes(bytes))
        }

        //从硬件架构字节序字节数组获得类型值
        pub const fn from_ne_bytes(bytes: [u8; mem::size_of::&lt;Self&gt;()]) -&gt; Self {
            unsafe { mem::transmute(bytes) }
        }
<span class="boring">}</span></code></pre></pre>
<p>RUST的整数类形各种算术方法突出的展示了RUST对安全的极致关注。算术方法也更好的支持了链式调用的函数式编程风格。对于算术溢出，RUST给出了各种情况下的处理方案：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        //对溢出做检查的加法运算,溢出情况下会返回wrapping_add的值，即溢出后值回绕
        //这里每种类型运算都以加法为例，其他诸如减、乘、除、幂次请参考官方标准库手册
        pub const fn overflowing_add(self, rhs: Self) -&gt; (Self, bool) {
            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
            (a as Self, b)
        }
        //其他的对溢出做检查的算数运算，略
        ...
        ...
                
        //溢出后对最大值取余，即回绕
        pub const fn wrapping_add(self, rhs: Self) -&gt; Self {
            intrinsics::wrapping_add(self, rhs)
        }
        //以边界值取余的其他数学运算方法，略
        ...
        ...

        //饱和加法，超过边界值结果为边界值
        pub const fn saturating_add(self, rhs: Self) -&gt; Self {
            intrinsics::saturating_add(self, rhs)
        }
        //其他饱和型的数学运算，略
        ...
        ...

        //对加法有效性检查的加法运算，如发生溢出，则返回异常
        pub const fn checked_add(self, rhs: Self) -&gt; Option&lt;Self&gt; {
            let (a, b) = self.overflowing_add(rhs);
            if unlikely!(b) {None} else {Some(a)}
        }

        //无检查add,  是 + 符号的默认调用函数。
        pub const unsafe fn unchecked_add(self, rhs: Self) -&gt; Self {
            // 调用者要保证不发生错误
            unsafe { intrinsics::unchecked_add(self, rhs) }
        }
        //其他对有效性检查的数学运算， 略
        ...
        ...
        
        pub const fn min_value() -&gt; Self { Self::MIN }

        pub const fn max_value() -&gt; Self { Self::MAX }
}
<span class="boring">}</span></code></pre></pre>
<p>算术算法基本上是使用了intrinsics提供的函数。</p>
<p>下面用u8给出一个上述宏具体的实例</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl u8 {
    //利用宏实现 u8类型的方法
    uint_impl! { u8, u8, i8, 8, 255, 2, &quot;0x82&quot;, &quot;0xa&quot;, &quot;0x12&quot;, &quot;0x12&quot;, &quot;0x48&quot;, &quot;[0x12]&quot;,
    &quot;[0x12]&quot;, &quot;&quot;, &quot;&quot; }
    
    pub const fn is_ascii(&amp;self) -&gt; bool {
        *self &amp; 128 == 0
    }
    
    //其他ASCII相关函数，请参考标准库手册，略
    ...
    ...
}

//u16 实现
impl u16 {
    uint_impl! { u16, u16, i16, 16, 65535, 4, &quot;0xa003&quot;, &quot;0x3a&quot;, &quot;0x1234&quot;, &quot;0x3412&quot;, &quot;0x2c48&quot;,
    &quot;[0x34, 0x12]&quot;, &quot;[0x12, 0x34]&quot;, &quot;&quot;, &quot;&quot; }
    widening_impl! { u16, u32, 16, unsigned }
}

//其他无符号整形的实现，略
...
...
<span class="boring">}</span></code></pre></pre>
<p>RUST整形库代码逻辑并不复杂，宏也很简单。但因为RUST将其他语言的独立的数学库函数，单独的大小端变换等集成入整形(浮点类型)，有可能造成出于习惯而无法找到相应的函数。</p>
<h2 id="浮点类型"><a class="header" href="#浮点类型">浮点类型</a></h2>
<p>本节主要说明RUST的数学库所在位置。
代码目录如下：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\std\src\f32.rs</p>
<p>core库中不包含更多的数学函数，因此用了std的的f32的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl f32 {
    ...
    ...
    pub fn abs(self) -&gt; f32 {
        unsafe { intrinsics::fabsf32(self) }
    }

    pub fn signum(self) -&gt; f32 {
        if self.is_nan() { Self::NAN } else { 1.0_f32.copysign(self) }
    }

    pub fn copysign(self, sign: f32) -&gt; f32 {
        unsafe { intrinsics::copysignf32(self, sign) }
    }

    pub fn powf(self, n: f32) -&gt; f32 {
        unsafe { intrinsics::powf32(self, n) }
    }

    pub fn sqrt(self) -&gt; f32 {
        unsafe { intrinsics::sqrtf32(self) }
    }

    pub fn exp(self) -&gt; f32 {
        unsafe { intrinsics::expf32(self) }
    }

    pub fn exp2(self) -&gt; f32 {
        unsafe { intrinsics::exp2f32(self) }
    }

    pub fn sin(self) -&gt; f32 {
        unsafe { intrinsics::sinf32(self) }
    }

    pub fn cos(self) -&gt; f32 {
        unsafe { intrinsics::cosf32(self) }
    }

    pub fn tan(self) -&gt; f32 {
        unsafe { cmath::tanf(self) }
    }

    pub fn asin(self) -&gt; f32 {
        unsafe { cmath::asinf(self) }
    }

    pub fn acos(self) -&gt; f32 {
        unsafe { cmath::acosf(self) }
    }

    pub fn atan(self) -&gt; f32 {
        unsafe { cmath::atanf(self) }
    }

    pub fn atan2(self, other: f32) -&gt; f32 {
        unsafe { cmath::atan2f(self, other) }
    }

    pub fn sin_cos(self) -&gt; (f32, f32) {
        (self.sin(), self.cos())
    }
    ...
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>RUST将数学函数与浮点类型关联在一起，除了更好的模块性以外，应该更多的出于支持函数式编程中的链式调用为目的。</p>
<h2 id="rust-option类型标准库代码分析"><a class="header" href="#rust-option类型标准库代码分析">RUST Option类型标准库代码分析</a></h2>
<p>代码路径：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\option.rs</p>
<p>Option<T>虽然在RUST中具有重要地位，但它本身不是RUST语法的最底层。实际上，可以认为它只是RUST的一个很普通的类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>借用RUST的enum语法，RUST标准库定义<code>Option&lt;T&gt;</code>，并将其作为解决某一变量不存在有效值的标准化解决方案。但一定要明确的是，<code>Option&lt;T&gt;</code>的方案是可以根据情况来作选择的，RUST的程序员完全可以根据情况另外构建合适的定制方案。最关键是<code>Option&lt;T&gt;</code>这种解决问题的思考方法。</p>
<p>很多语言通常把类型的取值域中的某一个值设计成代表值不存在,这就给bug开了一个口子，检查类型值是否存在成了程序员的责任，虽然这已经被程序员所接受并视作自己的能力之一，且无数家公司的编程规范也规定了相关内容。但RUST用<code>Option&lt;T&gt;</code>说了不，有了<code>Option&lt;T&gt;</code>后，RUST编译器承担起了类型值检查的责任，程序的正确性得到了更好的保证。由此可见，<code>Option&lt;T&gt;</code>对安全的保证仍然是靠基础架构代码而不是靠编译器。</p>
<p><code>Option&lt;T&gt;</code>也提供了变量声明时无法初始化的另一个方案：<br />
在初始化时无法确定T类型的值时，除了<code>MaybeUninit&lt;T&gt;</code>外，还可以用<code>Option&lt;T&gt;</code>来声明变量并初始化为None。</p>
<p><code>Option&lt;T&gt;</code>是对T类型变量的封装，在使用的时候会带来一些不便，针对这点，<code>Option&lt;T&gt;</code>提供了很酷的打开方式：用以map为代表的方法来完成函数链式调用。当然，Try trait及各种解封装方法也极大的方便了编程。</p>
<p><code>Option&lt;T&gt;</code>创建：
直接用<code>Some(val)</code>做包装，或者直接使用<code>None</code>。</p>
<p><code>Option&lt;T&gt;</code>的指针获取方法源代码如下：
RUST的习惯是每个复合类型都要有<code>as_ref/as_mut/as_ptr/as_mut_ptr</code>来获取“不可变引用/可变引用/不可变裸指针/可变裸指针”，每个复合类型可以根据自己的需求来实现这些方法，<code>Option&lt;T&gt;</code>没有实现裸指针相关内容</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Option&lt;T&gt; {
    //根据Option&lt;T&gt;自身的设计，只能返回Option&lt;&amp;T&gt;
    pub const fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        match *self {
            Some(ref x) =&gt; Some(x),
            None =&gt; None,
        }
    }

    //类似于as_ref，但返回的是可变引用
    pub const fn as_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        //略
    }
<span class="boring">}</span></code></pre></pre>
<p>对于所有的封装结构类型，如何方便的解封装都是重要的内容，RUST往往利用Try trait(后文有详述)及闭包来获得更精炼的解封装代码实践。
以下解封装函数，看过源码后功能即一目了然，不同封装结构的解封装方法功能都类似，可以从<code>Option&lt;T&gt;</code>对这些功能做出总结。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //解封装函数，正常返回封装中的变量，异常输出期待的错误消息
    pub fn expect(self, msg: &amp;str) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; expect_failed(msg),
        }
    }

    //解封装函数，正常返回封装中的变量，异常触发panic
    pub const fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }

    //解封装，正常返回封装中变量，异常返回变量默认值
    pub fn unwrap_or(self, default: T) -&gt; T {
        match self {
            Some(x) =&gt; x,
            None =&gt; default,
        }
    }
    
    //解封装，正常返回封装中变量，异常执行闭包并返回闭包返回值
    pub fn unwrap_or_else&lt;F: FnOnce() -&gt; T&gt;(self, f: F) -&gt; T {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }

    //确认不会异常的解封装函数
    pub unsafe fn unwrap_unchecked(self) -&gt; T {
        debug_assert!(self.is_some());
        match self {
            Some(val) =&gt; val,
            // SAFETY: the safety contract must be upheld by the caller.
            None =&gt; unsafe { hint::unreachable_unchecked() },
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>针对函数式编程的链式调用设计的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //主要用于函数式编程，map即是对值集合中的每个值作为闭包输入变量，并输出闭包输出
    // Option&lt;T&gt;的map对异常不处理
    pub fn map&lt;U, F: FnOnce(T) -&gt; U&gt;(self, f: F) -&gt; Option&lt;U&gt; {
        match self {
            Some(x) =&gt; Some(f(x)),
            None =&gt; None,
        }
    }

    //正常时将变量输入闭包，返回闭包返回值，异常则返回默认值
    pub fn map_or&lt;U, F: FnOnce(T) -&gt; U&gt;(self, default: U, f: F) -&gt; U {
        match self {
            Some(t) =&gt; f(t),
            None =&gt; default,
        }
    }

    //正常将变量输入闭包，返回闭包返回值，异常返回另一闭包返回值
    pub fn map_or_else&lt;U, D: FnOnce() -&gt; U, F: FnOnce(T) -&gt; U&gt;(self, default: D, f: F) -&gt; U {
        match self {
            Some(t) =&gt; f(t),
            None =&gt; default(),
        }
    }

    //将Option转换为Result，也是为支持函数式编程
    pub fn ok_or&lt;E&gt;(self, err: E) -&gt; Result&lt;T, E&gt; {
        match self {
            Some(v) =&gt; Ok(v),
            None =&gt; Err(err),
        }
    }

    //同上，None时调用默认函数处理
    pub fn ok_or_else&lt;E, F: FnOnce() -&gt; E&gt;(self, err: F) -&gt; Result&lt;T, E&gt; {
        match self {
            Some(v) =&gt; Ok(v),
            None =&gt; Err(err()),
        }
    }
    
    //Option&lt;T&gt;的与运算，正常返回输入参数，异常返回None
    pub fn and&lt;U&gt;(self, optb: Option&lt;U&gt;) -&gt; Option&lt;U&gt; {
        match self {
            Some(_) =&gt; optb,
            None =&gt; None,
        }
    }

    //主要用于函数式编程，与and 形成系列，值为Some(x)调用函数并返回函数值
    pub fn and_then&lt;U, F: FnOnce(T) -&gt; Option&lt;U&gt;&gt;(self, f: F) -&gt; Option&lt;U&gt; {
        match self {
            Some(x) =&gt; f(x),
            None =&gt; None,
        }
    }

    //如果是Some(x), 判断是否满足预设条件
    pub fn filter&lt;P: FnOnce(&amp;T) -&gt; bool&gt;(self, predicate: P) -&gt; Self {
        if let Some(x) = self {
            if predicate(&amp;x) {
                return Some(x);
            }
        }
        None
    }

    //如果是Some(x)返回本身，如果是None，返回预设值
    pub fn or(self, optb: Option&lt;T&gt;) -&gt; Option&lt;T&gt; {
        match self {
            Some(_) =&gt; self,
            None =&gt; optb,
        }
    }

    //如果是Some(x)返回本身，否则返回预设函数
    pub fn or_else&lt;F: FnOnce() -&gt; Option&lt;T&gt;&gt;(self, f: F) -&gt; Option&lt;T&gt; {
        match self {
            Some(_) =&gt; self,
            None =&gt; f(),
        }
    }

    //类似xor操作
    pub fn xor(self, optb: Option&lt;T&gt;) -&gt; Option&lt;T&gt; {
        match (self, optb) {
            //一方为Some,一方为None，返回Some值
            (Some(a), None) =&gt; Some(a),
            (None, Some(b)) =&gt; Some(b),
            //两者都为Some，或两者都为None, 返回None
            _ =&gt; None,
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>其他方法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //不解封装的重新设置内部的值，并返回值的可变引用
    //例子：let a = None; a.insert(1);
    //上例也是一种常用方法，利用None可以实现不知道初始值但需要有一个变量的情况。
    pub fn insert(&amp;mut self, value: T) -&gt; &amp;mut T {
        //原有*self会被drop
        *self = Some(value);
        //确认不会为None
        unsafe { self.as_mut().unwrap_unchecked() }
    }

    //使用一个闭包生成变量
    pub fn get_or_insert_with&lt;F: FnOnce() -&gt; T&gt;(&amp;mut self, f: F) -&gt; &amp;mut T {
        if let None = *self {
            *self = Some(f());
        }

        match self {
            //此处RUST专门设计了针对引用的match语法
            //如果仅仅依照普通的语法来分析，此处是有问题的，具体见此节后的分析。
            Some(v) =&gt; v,
            None =&gt; unsafe { hint::unreachable_unchecked() },
        }
    }

    //针对Option的zip操作
    pub fn zip&lt;U&gt;(self, other: Option&lt;U&gt;) -&gt; Option&lt;(T, U)&gt; {
        match (self, other) {
            (Some(a), Some(b)) =&gt; Some((a, b)),
            _ =&gt; None,
        }
    }

    //执行一个函数
    pub fn zip_with&lt;U, F, R&gt;(self, other: Option&lt;U&gt;, f: F) -&gt; Option&lt;R&gt;
    where
        F: FnOnce(T, U) -&gt; R,
    {
        //此处，顺序应该是先执行self? other？，然后再调用函数
        Some(f(self?, other?))
    }
<span class="boring">}</span></code></pre></pre>
<p>下面的take及replace对于<code>Option&lt;T&gt;</code>非常重要，<code>Option&lt;T&gt;</code>多用于包装引用或者智能指针且作为结构体成员。因为在使用结构体引用时，无法单独的转移结构体成员的所有权，而经常需要在这种情况下对<code>Option&lt;T&gt;</code>成员的值作改动，此时便只能用take来获取所有权，修改后再用replace将值更新。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //mem::replace分析请参考前文，用None替换原来的变量，并用新变量返回self，同时也完成了所有权的转移
    pub const fn take(&amp;mut self) -&gt; Option&lt;T&gt; {
        mem::replace(self, None)
    }O

    //用新value替换原变量，并把原变量返回
    pub const fn replace(&amp;mut self, value: T) -&gt; Option&lt;T&gt; {
        mem::replace(self, Some(value))
    }

}
<span class="boring">}</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code>的take及replace组合因为引入两次拷贝，降低效率。所以当采用这种形式作更新方案时，要考虑是否可以用unsafe的方式得到性能更高的方案。</p>
<h3 id="对结构体引用类型tmut-t的match语法研究"><a class="header" href="#对结构体引用类型tmut-t的match语法研究">对结构体引用类型<code>&amp;T/&amp;mut T</code>的match语法研究</a></h3>
<p>上节的代码中：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn get_or_insert_with&lt;F: FnOnce() -&gt; T&gt;(&amp;mut self, f: F) -&gt; &amp;mut T {
        ...
        match self {
            //这里因为没有自动解引用，所以self应该是&amp;Some(T)的类型
            //这就和下面的Some(v)出现冲突了，&amp;Some(T)怎么可能变成Some(v)
            //而v 为什么会是一个引用变量。这是一般的match无法解释的。
            //按照理解中的语法，应该是
            //&amp;Some(ref v) =&gt; v             
            Some(v) =&gt; v,
            None =&gt; unsafe { hint::unreachable_unchecked() },
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>更清晰的，再请参考如下代码：</p>
<pre><pre class="playground"><code class="language-rust">struct TestStructA {a:i32,b:i32}
fn main() {
    let c = TestStructA{a:1, b:2};
    let d = [1,2,3];

    match ((&amp;c, &amp;d)) {
        //用&amp;TestStructA表示c的类型，&amp;[]表示切片类型，可以内部绑定引用或Copy trait变量
        (&amp;TestStructA{a:ref u, b:w}, &amp;[ref x, y, ..]) =&gt; println!(&quot;{} {} {} {}&quot;, *u, w, *x, y),
        _  =&gt; println!(&quot;match nothing&quot;),
    }
}</code></pre></pre>
<p>上面代码的match是按照正常理解思路的一个写法，对结构内部的变量需要用引用绑定来获取，但结构内部变量如果实现Copy Trait，那可以不用引用绑定。但如果结构内部变量没有实现Copy，则必须使用引用，否则会因为错误的所有权转移导致编译器告警。</p>
<p>为了编码上的方便，RUST针对引用绑定的代码，支持如下简化形式：</p>
<pre><pre class="playground"><code class="language-rust">
struct TestStructA {a:i32,b:i32}
fn main() {
    let c = TestStructA{a:1, b:2};
    let d = [1, 2, 3];

    match ((&amp;c, &amp;d)) {
        //对比上述代码，头部少了&amp;，模式绑定内部少了 ref，但代码功能完全一致，但这个代码不支持Copy trait的变量绑定了。
        (TestStructA{a: u}, [x,..]) =&gt; println!(&quot;{} {}&quot;, *u, *x),
        _  =&gt; println!(&quot;match nothing&quot;),
    }
}</code></pre></pre>
<p>这是RUST的标准写法，但如果不知道RUST为这个语义专门做了语法设计，很可能会对这里的类型绑定感到疑惑。
从实际的使用场景分析，对结构体引用做match，其目的就是对结构体内部的成员的引用做pattern绑定。而且如果结构体内部的成员不支持Copy，那也不可能对结构体成员做pattern绑定。所以，此语法也是在RUST的所有权定义下的一个必然的简化选择。</p>
<h2 id="rust-result类型标准库代码分析"><a class="header" href="#rust-result类型标准库代码分析">RUST Result类型标准库代码分析</a></h2>
<p>代码路径：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\result.rs</p>
<p><code>Result&lt;T,E&gt;</code>实际是针对其他语言的try..catch..的对应设计。try..catch..试图简化方法/函数返回值错误处理。但仍然显得繁琐及影响代码的阅读体验，同时使用了复杂的实现机制。<code>Result&lt;T,E&gt;</code>与?运算符的配合使得代码对错误处理实现了最简练化，代码的主体功能一目了然。实现上仅仅使用了语法规则做了代码简化，但机制是最普通的函数返回。且可以由出错代码封装具体的变量，可以按需要定制获得具体的错误信息如变量，描述，函数，文件行等，提供了比try..catch..更强一筹的错误处理手段。 </p>
<p><code>Result&lt;T,E&gt;</code>的Try trait十分重要，另外，以map为代表的函数同样打开函数链式调用的通道。<br />
<code>Result&lt;T,E&gt;</code>值得关注方法的源代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Result&lt;T, E&gt; {
    /// Contains the success value
    Ok(T),

    /// Contains the error value
    Err(E),
}
impl&lt;T, E&gt; Result&lt;T, E&gt; {

    //应用于函数式编程，如果是Ok, 利用闭包直接处理Result值，返回需要的新Result类型
    pub fn map&lt;U, F: FnOnce(T) -&gt; U&gt;(self, op: F) -&gt; Result&lt;U, E&gt; {
        match self {
            Ok(t) =&gt; Ok(op(t)),
            Err(e) =&gt; Err(e),
        }
    }

    //如果是Ok, 利用闭包处理Result值，返回需要的类型，如果是Err返回默认值
    pub fn map_or&lt;U, F: FnOnce(T) -&gt; U&gt;(self, default: U, f: F) -&gt; U {
        match self {
            Ok(t) =&gt; f(t),
            Err(_) =&gt; default,
        }
    }

    //如果是Ok, 调用闭包处理Result，返回需要的类型, 如果是Err，调用错误闭包函数处理错误
    pub fn map_or_else&lt;U, D: FnOnce(E) -&gt; U, F: FnOnce(T) -&gt; U&gt;(self, default: D, f: F) -&gt; U {
        match self {
            Ok(t) =&gt; f(t),
            Err(e) =&gt; default(e),
        }
    }

    //如果是Err, 调用闭包函数处理错误，返回需要的类型， Ok则返回原值
    pub fn map_err&lt;F, O: FnOnce(E) -&gt; F&gt;(self, op: O) -&gt; Result&lt;T, F&gt; {
        match self {
            Ok(t) =&gt; Ok(t),
            Err(e) =&gt; Err(op(e)),
        }
    }

    //Result传递，Ok则返回给定的Result类型值，否则返回原值
    pub fn and&lt;U&gt;(self, res: Result&lt;U, E&gt;) -&gt; Result&lt;U, E&gt; {
        match self {
            Ok(_) =&gt; res,
            Err(e) =&gt; Err(e),
        }
    }

    //Ok 则调用闭包处理,返回需要的Result类型值， 否则返回原值
    pub fn and_then&lt;U, F: FnOnce(T) -&gt; Result&lt;U, E&gt;&gt;(self, op: F) -&gt; Result&lt;U, E&gt; {
        match self {
            Ok(t) =&gt; op(t),
            Err(e) =&gt; Err(e),
        }
    }

    //Ok返回原值，Err返回传入的默认Result类型值
    pub fn or&lt;F&gt;(self, res: Result&lt;T, F&gt;) -&gt; Result&lt;T, F&gt; {
        match self {
            Ok(v) =&gt; Ok(v),
            Err(_) =&gt; res,
        }
    }

    //Ok返回原值，Err调用函数进行处理，返回需要的Result类型值
    pub fn or_else&lt;F, O: FnOnce(E) -&gt; Result&lt;T, F&gt;&gt;(self, op: O) -&gt; Result&lt;T, F&gt; {
        match self {
            Ok(t) =&gt; Ok(t),
            Err(e) =&gt; op(e),
        }
    }

    //解封装，Ok返回封装内的值，Err返回默认值
    pub fn unwrap_or(self, default: T) -&gt; T {
        match self {
            Ok(t) =&gt; t,
            Err(_) =&gt; default,
        }
    }

    //解封装， Ok返回封装内的值， Err调用处理函数处理
    pub fn unwrap_or_else&lt;F: FnOnce(E) -&gt; T&gt;(self, op: F) -&gt; T {
        match self {
            Ok(t) =&gt; t,
            Err(e) =&gt; op(e),
        }
    }

    //确认返回一定是Ok时的解封装函数
    pub unsafe fn unwrap_unchecked(self) -&gt; T {
        debug_assert!(self.is_ok());
        match self {
            Ok(t) =&gt; t,
            // SAFETY: the safety contract must be upheld by the caller.
            Err(_) =&gt; unsafe { hint::unreachable_unchecked() },
        }
    }

    //确认返回一定是Err时调用的解封装函数
    pub unsafe fn unwrap_err_unchecked(self) -&gt; E {
        debug_assert!(self.is_err());
        match self {
            // SAFETY: the safety contract must be upheld by the caller.
            Ok(_) =&gt; unsafe { hint::unreachable_unchecked() },
            Err(e) =&gt; e,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result&lt;T,E&gt;</code>的解封装函数如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, E: fmt::Debug&gt; Result&lt;T, E&gt; {
    //典型的expect解封装方法，内容略
    pub fn expect(self, msg: &amp;str) -&gt; T ;

    //典型的unwrap解封装方法，内容略
    pub fn unwrap(self) -&gt; T ;
}

impl&lt;T: fmt::Debug, E&gt; Result&lt;T, E&gt; {
    //解封装，对于Ok输出参数指定的信息并退出，Err解封装
    pub fn expect_err(self, msg: &amp;str) -&gt; E {
        match self {
            Ok(t) =&gt; unwrap_failed(msg, &amp;t),
            Err(e) =&gt; e,
        }
    }
    
    //解封装，对于Ok输出固定的信息并退出，Err解封装
    pub fn unwrap_err(self) -&gt; E {
        match self {
            Ok(t) =&gt; unwrap_failed(&quot;called `Result::unwrap_err()` on an `Ok` value&quot;, &amp;t),
            Err(e) =&gt; e,
        }
    }
}


impl&lt;T: Default, E&gt; Result&lt;T, E&gt; {
    //解封装，Ok解封装， Err返回T的Default值
    pub fn unwrap_or_default(self) -&gt; T {
        match self {
            Ok(x) =&gt; x,
            Err(_) =&gt; Default::default(),
        }
    }
}

impl&lt;T, E: Into&lt;!&gt;&gt; Result&lt;T, E&gt; {
    //解封装，Ok解封装，Err返回Never类型
    pub fn into_ok(self) -&gt; T {
        match self {
            Ok(x) =&gt; x,
            Err(e) =&gt; e.into(),
        }
    }
}

impl&lt;T: Into&lt;!&gt;, E&gt; Result&lt;T, E&gt; {
    //解封装，Err解封装， Ok返回Never类型
    pub fn into_err(self) -&gt; E {
        match self {
            Ok(x) =&gt; x.into(),
            Err(e) =&gt; e,
        }
    }
}

impl&lt;T, E&gt; Result&lt;Option&lt;T&gt;, E&gt; {
    //将Result&lt;&gt;转换为Option
    pub const fn transpose(self) -&gt; Option&lt;Result&lt;T, E&gt;&gt; {
        match self {
            Ok(Some(x)) =&gt; Some(Ok(x)),
            Ok(None) =&gt; None,
            Err(e) =&gt; Some(Err(e)),
        }

    }
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust标准库的基础trait"><a class="header" href="#rust标准库的基础trait">RUST标准库的基础Trait</a></h1>
<h2 id="编译器内置trait代码分析"><a class="header" href="#编译器内置trait代码分析">编译器内置Trait代码分析</a></h2>
<p>代码路径：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\marker.rs</p>
<p>marker trait是没有实现体，是一种特殊的类型性质，这类性质无法用类型成员来表达，因此用trait来实现是最合适的。</p>
<p>Send trait是标识变量类型可以安全的在线程间转移所有权的marker。<br />
Sync trait是标识变量类型的引用可以安全的由多线程并发访问的marker。
对于auto trait，RUST的默认规则是如果T支持auto trait，则<code>*const T, *mut T, [T], [T;N], &amp;T, &amp;mut T</code>都自动支持该auto trait, 如果实际情况不符合这条默认规则，需要在代码中显式声明。<br />
如果一个复合类型的所有成员都支持auto trait, 则该复合类型支持auto trait。如果实际上不符合这条默认规则，也需要显式在代码作声明。<br />
如果一个符合类型中有成员不支持auto trait, 但该复合类型支持auto trait, 需要在代码中作显式声明。</p>
<p>变量在线程间安全指的是对变量操作需要具备事务性，在一个事务周期内只允许一个线程对变量进行读写。<br />
RUST中，因为所有权和借用语法，对于大部分类型，不会出现多线程的并发操作。因此RUST类型默认都是实现了Send trait和Sync trait的，如果类型不支持Send或Sync或者有约束条件，需要进行显式的定义。
在所有权转移后可能出现多线程并发操作的基本类型只有内部可变性类型的引用，裸指针，多份所有权的智能指针三种情况。
目前可以多线程并发操作的类型有：</p>
<ol>
<li>内部可变性类型引用，</li>
<li>具有递归到内部可变性类型成员的复合类型变量引用, 并且利用变量引用可触发内部可变操作</li>
<li>具有递归到内部可变性引用类型成员的复合类型变量及变量引用，并且利用变量或变量引用可触发内部可变操作</li>
<li><code>*const T/* mut T/NonNull&lt;T&gt;/Unique&lt;T&gt;</code>及引用，</li>
<li>具有递归到4类型成员的复合类型变量及变量引用，并且利用变量及变量引用可触发对裸指针指向内容的改变</li>
<li>支持多份所有权的智能指针，</li>
<li>能够递归到多份所有权智能指针类型成员的复合类型变量及其引用，并且利用变量及变量引用可触发对智能指针操作。 </li>
<li>对引用转换为裸指针后进行unsafe的操作<br />
unsafe操作我们不做讨论。<br />
对于上述1-6，都需要进行明确Send trait及Sync Trait的定义。 这里要注意的是RUST结构体内的成员默认私有，所以即使类型结构体有能多线程并发操作的成员，也不代表类型本身就能够被多线程并发操作。例如：只有当取得结构类型可变引用时，才能对内部可变性成员操作，就使得结构类型可以成为支持Send和Sync的类型。 这些情况下，需要做Send和Sync的显式声明。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub unsafe auto trait Send {
    // empty.
}

//以下因为与RUST的默认规则不一样，所以需要在代码中显式定义出来
impl&lt;T: ?Sized&gt; !Send for *const T {}
impl&lt;T: ?Sized&gt; !Send for *mut T {}

//以下也是因为与RUST的默认规则不一致，所以需要显式的声明
mod impls {
    // 如果将&amp;T转移到其他线程，不支持Sync trait的类型利用&amp;T对变量的操作导致事务性不能保证。所以不能将&amp;T转移到其他线程，
    unsafe impl&lt;T: Sync + ?Sized&gt; Send for &amp;T {}
    // &amp;mut T具备独占性，导致线程外不会有其他写操作，包括内部可变性类型。
    unsafe impl&lt;T: Send + ?Sized&gt; Send for &amp;mut T {}
}

  
pub unsafe auto trait Sync {
    // Empty
}
//与RUST代码默认规则不一致
impl&lt;T: ?Sized&gt; !Sync for *const T {}
impl&lt;T: ?Sized&gt; !Sync for *mut T {}

//类型内存大小固定，泛型 &quot;T&quot; 默认是Sized，如果表示所有类型，需要 T:?Sized.
pub trait Sized {
    // Empty.
}

//如果一个Sized的类型要强制转换为动态大小类型，那必须实现Unsize Trait
//例如 [T;N] 实现了 Unsize&lt;[T]&gt;
pub trait Unsize&lt;T: ?Sized&gt; {
    // Empty.
}

//模式匹配表达式匹配时编译器需要使用的Trait，如果一个结构实现了PartialEq，该Trait会自动被实现。
pub trait StructuralPartialEq {
    // Empty.
}

//主要用于模式匹配，如果一个结构实现了Eq, 该Trait会自动被实现。
pub trait StructuralEq {
    // Empty.
}
<span class="boring">}</span></code></pre></pre>
<p>以下给出了一个针对所有的原生类型都实现Copy Trait的实现代码, 实现了Copy Trait的类型编译器不必调用drop来对类型进行内存释放。
这也是RUST针对原生类型可以直接实现trait的实例。任意模块可以定义一个trait,然后即可在原生类型上实现这个trait，这极大的提高了RUST的语法一致性及函数式编程的能力：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Copy，略
pub trait Copy: Clone {
    // Empty.
}

//统一实现原生类型对Copy Trait的支持
mod copy_impls {

    use super::Copy;

    macro_rules! impl_copy {
        ($($t:ty)*) =&gt; {
            $(
                impl Copy for $t {}
            )*
        }
    }

    impl_copy! {
        usize u8 u16 u32 u64 u128
        isize i8 i16 i32 i64 i128
        f32 f64
        bool char
    }

    impl Copy for ! {}

    impl&lt;T: ?Sized&gt; Copy for *const T {}

    impl&lt;T: ?Sized&gt; Copy for *mut T {}

    impl&lt;T: ?Sized&gt; Copy for &amp;T {}

    //&amp; mut T不支持Copy，以保证RUST的借用规则
}
<span class="boring">}</span></code></pre></pre>
<p><code>PhantomData&lt;T&gt;</code>类型可以在其他类型结构体中定义一个变量，标记此结构体逻辑上拥有，但不需要或不方便在结构体成员变量体现的某个属性。实质上，智能指针一般都需要利用<code>Unique&lt;T&gt;</code>，以PhantomData来实现对堆内存的逻辑拥有权.
PhantomData最常用来标记生命周期及所有权。主要给编译器提示检验类型变量的生命周期和类型构造时输入的生命周期关系。也用来提示拥有PhantomData<T>的结构体会负责对T做drop操作。需要编译器做drop检查的时候更准确的判断出内存安全错误。 
<code>PhantomData&lt;T&gt;</code>属性与所有权或生命周期的关系由编译器自行推断。具体实例可参考官方标准库文档及后继相关章节。<br />
PhantomData是个单元结构体，单元结构体的变量名就是单元结构体的类型名。<br />
所以使用的时候直接使用PhantomData即可，编译器会将泛型的类型实例化信息自动带入PhantomData中</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PhantomData&lt;T: ?Sized&gt;;
<span class="boring">}</span></code></pre></pre>
<h2 id="ops-运算符-trait-代码分析"><a class="header" href="#ops-运算符-trait-代码分析">ops 运算符 Trait 代码分析</a></h2>
<p>代码路径如下：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ops*.rs</p>
<p>RUST中，所有的运算符号都可以重载。Ops重载允许提供<em>两个不同类型</em>之间的运算。</p>
<h3 id="一个小规则"><a class="header" href="#一个小规则">一个小规则</a></h3>
<p>在重载函数中，如果重载的符号出現，编译器用规定的默认操作来实现。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        impl const BitAnd for u8 {
            type Output = u8;
            //下面函数内部的 &amp; 符号不再引发重载，是编译器的默认按位与操作。
            fn bitand(self, rhs: u8) -&gt; u8 { self &amp; u8 }
        }


<span class="boring">}</span></code></pre></pre>
<h3 id="数学运算符-trait"><a class="header" href="#数学运算符-trait">数学运算符 Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Add&lt;Rhs = Self&gt; {
    type Output;

    //此函数会消费self, 设计一些复杂结构的加法
    //时可能导致一些复杂性
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

macro_rules! add_impl {
    ($($t:ty)*) =&gt; ($(
        //注意这里的const实现，代表trait里面的函数
        //都是const函数,为了使得加法能够给const及static赋值
        impl const Add for $t {
            type Output = $t;

            fn add(self, other: $t) -&gt; $t { self + other }
        }

        forward_ref_binop! { impl const Add, add for $t, $t }
    )*)
}
//实现了所有数据类型的加法
add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }


pub trait AddAssign&lt;Rhs = Self&gt; {
    //使用可变引用，与Add不同
    fn add_assign(&amp;mut self, rhs: Rhs);
}

macro_rules! add_assign_impl {
    ($($t:ty)+) =&gt; ($(
        impl const AddAssign for $t {
            fn add_assign(&amp;mut self, other: $t) { *self += other }
        }

        forward_ref_op_assign! { impl const AddAssign, add_assign for $t, $t }
    )+)
}
//实现了所有数据类型的加法
add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }

<span class="boring">}</span></code></pre></pre>
<p>其他数学运算类似，略</p>
<h3 id="位运算符-trait"><a class="header" href="#位运算符-trait">位运算符 Trait</a></h3>
<p>与数学运算类似，略</p>
<h3 id="关系运算符trait"><a class="header" href="#关系运算符trait">关系运算符Trait</a></h3>
<p>代码路径如下：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\cmp.rs</p>
<p>关系运算符的代码稍微复杂，这里给出较完整的代码。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//&quot;==&quot; &quot;!=&quot;的运算符trait，PartialEq用于在整个类型
//定义域内存在值无法满足相等条件的情况。例如浮点类型 “NaN != NaN&quot; 
//可以定义不同与self的泛型实现不同类型&quot;==&quot;及&quot;!=&quot;的运算
pub trait PartialEq&lt;Rhs: ?Sized = Self&gt; {
    /// “==” 重载方法
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;

    ///`!=` 重载方法
    fn ne(&amp;self, other: &amp;Rhs) -&gt; bool {
        !self.eq(other)
    }
}

//对于全作用域所有值都可相等的类型。实现Eq trait，
//PartialEq和Eq区别实现，也是Rust安全性的体现之一
//相等判断还是由PartialEq的方法负责
pub trait Eq: PartialEq&lt;Self&gt; {
    fn assert_receiver_is_total_eq(&amp;self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>对于&quot;&lt;,&gt;,&lt;=,&gt;=&quot;等四种运算，如果全域有可能出现无法比较的情况，仅实现<code>PartialOrd&lt;Rhs&gt;</code>，如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// &quot;&lt;&quot; &quot;&gt;&quot; &quot;&gt;=&quot; &quot;&lt;=&quot; 运算符重载结构, 事实上关系运算只需要重载这个Trait
// Ord Trait 不用编码,
// 可以为一个类型实现不同于此类型的PartialEq
pub trait PartialOrd&lt;Rhs: ?Sized = Self&gt;: PartialEq&lt;Rhs&gt; {
    // 显然，只能有一个比较函数, 对于全域都满足比较的，此函数内部一般用Ord
    // Trait的cmp，对于无法比较的，需要实现独立的代码，如浮点,因为存在不可比较
    //的值，所以需要用Option
    fn partial_cmp(&amp;self, other: &amp;Rhs) -&gt; Option&lt;Ordering&gt;;

    // &quot;&lt;&quot; 运算符重载
    fn lt(&amp;self, other: &amp;Rhs) -&gt; bool {
        matches!(self.partial_cmp(other), Some(Less))
    }
    
    //&quot;&lt;=&quot;运算符重载
    fn le(&amp;self, other: &amp;Rhs) -&gt; bool {
        // Pattern `Some(Less | Eq)` optimizes worse than negating `None | Some(Greater)`.
        !matches!(self.partial_cmp(other), None | Some(Greater))
    }

    //&quot;&gt;&quot;运算符重载, 代码略
    fn gt(&amp;self, other: &amp;Rhs) -&gt; bool;
    
    //&quot;&gt;=&quot;运算符重载，代码略
    fn ge(&amp;self, other: &amp;Rhs) -&gt; bool;

    //eq已经在PatialEq中包含
}

//Ord是全域值都可比较的Trait，其与PartialOrd结果应该一致
pub trait Ord: Eq + PartialOrd&lt;Self&gt; {
    //通常partial_cmp() == Some(cmp()),因为全域值
    //都可以比较，不会出现Ordering之外的情况
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;

    fn max(self, other: Self) -&gt; Self
    where
        Self: Sized,
    {
        //见下面代码分析
        max_by(self, other, Ord::cmp)
    }

    fn min(self, other: Self) -&gt; Self
    where
        Self: Sized,
    {
        //见下面代码分析
        min_by(self, other, Ord::cmp)
    }

    fn clamp(self, min: Self, max: Self) -&gt; Self
    where
        Self: Sized,
    {
        assert!(min &lt;= max);
        if self &lt; min {
            min
        } else if self &gt; max {
            max
        } else {
            self
        }
    }
}
//用于表示关系结果的结构体,注意此结构在函数式编程中的实用性
#[derive(Clone, Copy, PartialEq, Debug, Hash)]
#[repr(i8)]
pub enum Ordering {
    /// 小于.
    Less = -1,
    /// 等于.
    Equal = 0,
    /// 大于.
    Greater = 1,
}

impl Ordering {
    //对Ordering做逆操作, 代码略
    pub const fn reverse(self) -&gt; Ordering ;

    //用来简化代码及更好的支持函数式编程
    //举例：
    // let x: (i64, i64, i64) = (1, 2, 7);
    // let y: (i64, i64, i64) = (1, 5, 3);
    // let result = x.0.cmp(&amp;y.0).then(x.1.cmp(&amp;y.1)).then(x.2.cmp(&amp;y.2));
    pub const fn then(self, other: Ordering) -&gt; Ordering {
        match self {
            Equal =&gt; other,
            _ =&gt; self,
        }
    }

    //用来简化代码实及支持函数式编程
    pub fn then_with&lt;F: FnOnce() -&gt; Ordering&gt;(self, f: F) -&gt; Ordering {
        match self {
            Equal =&gt; f(),
            _ =&gt; self,
        }
    }
}

//用输入的闭包比较函数获取两个值中大的一个
pub fn max_by&lt;T, F: FnOnce(&amp;T, &amp;T) -&gt; Ordering&gt;(v1: T, v2: T, compare: F) -&gt; T {
    match compare(&amp;v1, &amp;v2) {
        Ordering::Less | Ordering::Equal =&gt; v2,
        Ordering::Greater =&gt; v1,
    }
}

//用输入的闭包比较函数获取两个值中小的一个
pub fn min_by&lt;T, F: FnOnce(&amp;T, &amp;T) -&gt; Ordering&gt;(v1: T, v2: T, compare: F) -&gt; T {
    match compare(&amp;v1, &amp;v2) {
        Ordering::Less | Ordering::Equal =&gt; v1,
        Ordering::Greater =&gt; v2,
    }
}

//cmp::min 作为两变量取小的api调用
pub fn min&lt;T: Ord&gt;(v1: T, v2: T) -&gt; T {
    v1.min(v2)
}

//对变量生成key，两变量取小的key值变量的api
pub fn min_by_key&lt;T, F: FnMut(&amp;T) -&gt; K, K: Ord&gt;(v1: T, v2: T, mut f: F) -&gt; T {
    min_by(v1, v2, |v1, v2| f(v1).cmp(&amp;f(v2)))
}

//cmp::max 作为两变量取大的api调用
pub fn max&lt;T: Ord&gt;(v1: T, v2: T) -&gt; T {
    v1.max(v2)
}

//对变量生成key，两变量取大的key值的api
pub fn max_by_key&lt;T, F: FnMut(&amp;T) -&gt; K, K: Ord&gt;(v1: T, v2: T, mut f: F) -&gt; T {
    max_by(v1, v2, |v1, v2| f(v1).cmp(&amp;f(v2)))
}
<span class="boring">}</span></code></pre></pre>
<p>以下是利用泛型和Adapter模式的典型的解决一类问题的RUST解决方案，下面是对有序的类型实现逆序的方案</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//对于实现了PartialOrd的类型实现一个Ord的反转，这个设计是典型的RUST的思考方式，
//利用一个Adpater设计模式+泛型，很轻松的解决了一类需求
//adapter的设计模式例子
pub struct Reverse&lt;T&gt;(pub T);

impl&lt;T: PartialOrd&gt; PartialOrd for Reverse&lt;T&gt; {
    fn partial_cmp(&amp;self, other: &amp;Reverse&lt;T&gt;) -&gt; Option&lt;Ordering&gt; {
        other.0.partial_cmp(&amp;self.0)
    }

    fn lt(&amp;self, other: &amp;Self) -&gt; bool {
        other.0 &lt; self.0
    }

    //其他方法，略
    ...
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>以下是关系运算trait在原生类型上的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 具体的实现宏 
mod impls {
    use crate::cmp::Ordering::{self, Equal, Greater, Less};
    use crate::hint::unreachable_unchecked;
    
    //PartialEq在原生类型上的实现,利用宏减少重复代码
    macro_rules! partial_eq_impl {
        ($($t:ty)*) =&gt; ($(
            //Rhs类型默认为Self
            impl PartialEq for $t {
                fn eq(&amp;self, other: &amp;$t) -&gt; bool { (*self) == (*other) }
                fn ne(&amp;self, other: &amp;$t) -&gt; bool { (*self) != (*other) }
            }
        )*)
    }
    //单元类型，一定相等
    impl PartialEq for () {
        fn eq(&amp;self, _other: &amp;()) -&gt; bool {
            true
        }
        fn ne(&amp;self, _other: &amp;()) -&gt; bool {
            false
        }
    }
    //所有类型都实现PartialEq
    partial_eq_impl! {
        bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64
    }
    
    macro_rules! eq_impl {
        ($($t:ty)*) =&gt; ($(
            #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
            impl Eq for $t {}
        )*)
    }

    //浮点不实现Eq
    eq_impl! { () bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }

    //关系运算，利用宏减少代码, 这个宏仅仅针对浮点数
    macro_rules! partial_ord_impl {
        ($($t:ty)*) =&gt; ($(
            #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
            impl PartialOrd for $t {
                fn partial_cmp(&amp;self, other: &amp;$t) -&gt; Option&lt;Ordering&gt; {
                    //RUST的典型的代码，要记住这种简练的语法表达
                    //这个表达主要是考虑到浮点, 注意这里是用了impl PartialOrd&lt;&amp;B&gt; for &amp;A
                    //从而self &lt;= other导致对 （&amp;f32).le()的调用
                    //为什么不直接使用(*self &lt;= *other, *self &gt;= *other)呢
                    //提交了PR，最新的代码库已经修改了
                    match (self &lt;= other, self &gt;= other) {
                        (false, false) =&gt; None,
                        (false, true) =&gt; Some(Greater),
                        (true, false) =&gt; Some(Less),
                        (true, true) =&gt; Some(Equal),
                    }
                }
                //不使用默认函数
                fn lt(&amp;self, other: &amp;$t) -&gt; bool { (*self) &lt; (*other) }
                fn le(&amp;self, other: &amp;$t) -&gt; bool { (*self) &lt;= (*other) }
                fn ge(&amp;self, other: &amp;$t) -&gt; bool { (*self) &gt;= (*other) }
                fn gt(&amp;self, other: &amp;$t) -&gt; bool { (*self) &gt; (*other) }
            }
        )*)
    }

    //仅在浮点数实现
    partial_ord_impl! { f32 f64 }
    
    //为支持全域值可比较的类型实现的宏
    macro_rules! ord_impl {
        ($($t:ty)*) =&gt; ($(
            impl PartialOrd for $t {
                //复用Ord的cmp函数
                fn partial_cmp(&amp;self, other: &amp;$t) -&gt; Option&lt;Ordering&gt; {
                    Some(self.cmp(other))
                }
                fn lt(&amp;self, other: &amp;$t) -&gt; bool { (*self) &lt; (*other) }
                fn le(&amp;self, other: &amp;$t) -&gt; bool { (*self) &lt;= (*other) }
                fn ge(&amp;self, other: &amp;$t) -&gt; bool { (*self) &gt;= (*other) }
                fn gt(&amp;self, other: &amp;$t) -&gt; bool { (*self) &gt; (*other) }
            }

            impl Ord for $t {
                fn cmp(&amp;self, other: &amp;$t) -&gt; Ordering {
                    if *self &lt; *other { Less }
                    else if *self == *other { Equal }
                    else { Greater }
                }
            }
        )*)
    }
    //浮点数不支持Ord
    ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }

    //A实现了PartialEq&lt;B&gt;, PartialOrd&lt;B&gt;后，对&amp;A实现PartialEq&lt;&amp;B&gt;， PartialOrd&lt;&amp;B&gt;
    impl&lt;A: ?Sized, B: ?Sized&gt; PartialEq&lt;&amp;B&gt; for &amp;A
    where
        A: PartialEq&lt;B&gt;,
    {
        fn eq(&amp;self, other: &amp;&amp;B) -&gt; bool {
            //注意这个调用方式，此时不能用self.eq调用。
            //eq方法参数为引用
            PartialEq::eq(*self, *other)
        }
        fn ne(&amp;self, other: &amp;&amp;B) -&gt; bool {
            PartialEq::ne(*self, *other)
        }
    }
    
}

<span class="boring">}</span></code></pre></pre>
<p>以上较完整的给出了关系运算Trait的代码，可以看到，RUST标准库除了对原生类型做了Trait的实现，也针对受约束的泛型尽可能的做了关系运算符 Trait的实现，以便最大的减少后继的开发量。程序员需要精通RUST的标准库已经针对那些泛型类型做好了实现，避免再重复的造轮子。</p>
<h3 id="运算符-trait代码分析"><a class="header" href="#运算符-trait代码分析">？运算符 Trait代码分析</a></h3>
<p>代码路径：try_trait.rs</p>
<p>?操作引入有两个目的：</p>
<ol>
<li>作为解封装的最简化代码表达形式</li>
<li>作为try..catch..的RUST实现方式</li>
</ol>
<p>Try trait定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Try: FromResidual {
    /// ?操作如果结果正常，返回的解封装的正常变量类型
    /// 具体实例可参考随后的Option的Try trait实现
    type Output;

    /// ?操作如果结果异常，返回解封装的异常变量类型
    type Residual;

    /// 从Self::Output解封装的正常类型变量获得封装后的类型变量的函数。当然，封装类型实现了Try trait
    /// 函数必须符合下面代码的原则，
    /// `Try::from_output(x).branch() --&gt; ControlFlow::Continue(x)`.
    /// 例子：
    /// ```
    /// assert_eq!(&lt;Result&lt;_, String&gt; as Try&gt;::from_output(3), Ok(3));
    /// assert_eq!(&lt;Option&lt;_&gt; as Try&gt;::from_output(4), Some(4));
    /// assert_eq!(
    ///     &lt;std::ops::ControlFlow&lt;String, _&gt; as Try&gt;::from_output(5),
    ///     std::ops::ControlFlow::Continue(5),
    /// );
    fn from_output(output: Self::Output) -&gt; Self;

    /// branch函数会返回ControlFlow类型变量，用以标识代码继续流程还是中断流程并提前返回
    /// 例子：
    ///
    /// assert_eq!(Ok::&lt;_, String&gt;(3).branch(), ControlFlow::Continue(3));
    /// assert_eq!(Err::&lt;String, _&gt;(3).branch(), ControlFlow::Break(Err(3)));
    ///
    /// assert_eq!(Some(3).branch(), ControlFlow::Continue(3));
    /// assert_eq!(None::&lt;String&gt;.branch(), ControlFlow::Break(None));
    ///
    /// assert_eq!(ControlFlow::&lt;String, _&gt;::Continue(3).branch(), ControlFlow::Continue(3));
    /// assert_eq!(
    ///     ControlFlow::&lt;_, String&gt;::Break(3).branch(),
    ///     ControlFlow::Break(ControlFlow::Break(3)),
    /// );
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;;
}

pub trait FromResidual&lt;R = &lt;Self as Try&gt;::Residual&gt; {
    /// 该函数从解封装的异常类型变量获取封装后的类型变量。封装后的类型实现了Try Trait。
    ///
    /// 此函数必须符合下面代码的原则
    /// `FromResidual::from_residual(r).branch() --&gt; ControlFlow::Break(r)`.
    /// 例子：
    /// assert_eq!(Result::&lt;String, i64&gt;::from_residual(Err(3_u8)), Err(3));
    /// assert_eq!(Option::&lt;String&gt;::from_residual(None), None);
    /// assert_eq!(
    ///     ControlFlow::&lt;_, String&gt;::from_residual(ControlFlow::Break(5)),
    ///     ControlFlow::Break(5),
    /// );
    fn from_residual(residual: R) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p>Try Trait对? 操作支持的举例如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//不用? 操作的代码
 pub fn simple_try_fold_3&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
     iter: impl Iterator&lt;Item = T&gt;,
     mut accum: A,
     mut f: impl FnMut(A, T) -&gt; R,
 ) -&gt; R {
     for x in iter {
         let cf = f(accum, x).branch();
         match cf {
             ControlFlow::Continue(a) =&gt; accum = a,
             ControlFlow::Break(r) =&gt; return R::from_residual(r),
         }
     }
     R::from_output(accum)
 }
// 使用? 操作的代码:
 fn simple_try_fold&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
     iter: impl Iterator&lt;Item = T&gt;,
     mut accum: A,
     mut f: impl FnMut(A, T) -&gt; R,
 ) -&gt; R {
     for x in iter {
         accum = f(accum, x)?;
     }
     R::from_output(accum)
 }
<span class="boring">}</span></code></pre></pre>
<p>由上，可推断出T?表示如下代码</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   match((T as Try).branch()) {
       ControlFlow::Continue(a) =&gt; a,
       ControlFlow::Break(r) =&gt; return (T as Try)::from_residual(r),
   }
<span class="boring">}</span></code></pre></pre>
<p>ControlFlow类型代码如下, 主要用于指示代码控制流程指示， 逻辑上可类比于continue, break 关键字 代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ControlFlow&lt;B, C = ()&gt; {
    //代码过程继续执行，可以从C中得到代码过程的中间结果
    Continue(C),
    /// 代码过程应退出，可以从B中得到代码退出时的中间结果
    Break(B),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="option的try-trait实现"><a class="header" href="#option的try-trait实现">Option<T>的Try Trait实现</a></h4>
<p>实现代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; ops::Try for Option&lt;T&gt; {
    type Output = T;
    // Infallible是一种错误类型，但该错误永远也不会发生，
    // Residual 只可能是None，所以是Option类型，但是因为不会返回Some(),
    // 所以T使用Infallible来表示不会有Some，这也表现了RUST的安全理念，
    // 一定在类型定义的时候保证代码安全。
    type Residual = Option&lt;convert::Infallible&gt;;

    fn from_output(output: Self::Output) -&gt; Self {
        Some(output)
    }

    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt; {
        match self {
            Some(v) =&gt; ControlFlow::Continue(v),
            None =&gt; ControlFlow::Break(None),
        }
    }
}

impl&lt;T&gt; const ops::FromResidual for Option&lt;T&gt; {
    fn from_residual(residual: Option&lt;convert::Infallible&gt;) -&gt; Self {
        match residual {
            None =&gt; None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>所以，一个Option<T>？等同于如下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   match(Option&lt;T&gt;.branch()) {
       ControlFlow::Continue(a) =&gt; a,
       //下面代码实际就是return None
       ControlFlow::Break(None) =&gt; return (Option&lt;T&gt;::from_residual(None)),
   }
<span class="boring">}</span></code></pre></pre>
<p>Result&lt;T,E&gt;类型的Try Trait请自行分析</p>
<h4 id="小结-3"><a class="header" href="#小结-3">小结</a></h4>
<p>利用Try Trait，程序员可以实现自定义类型的?，提供函数式编程的有力手段并简化代码，提升代码的理解度。</p>
<h3 id="range-运算符代码分析"><a class="header" href="#range-运算符代码分析">Range 运算符代码分析</a></h3>
<p>代码路径：<br />
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ops\range.rs</p>
<p>Range是符号 .. , start..end , start.. , ..end , ..=end，start..=end 形式<br />
代码书写虽然采用了上面的形式，但编译器将其转换成了不同的具体结构。如下：</p>
<p><code>.. </code>的数据结构是 <code>RangeFull</code>,如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RangeFull;
<span class="boring">}</span></code></pre></pre>
<p><code>start.. end</code>的数据结构 是 <code>Range&lt;Idx&gt;</code>,如下</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Range&lt;Idx&gt; {
    pub start: Idx,
    pub end: Idx,
}
<span class="boring">}</span></code></pre></pre>
<p><code>start..</code>的数据结构是<code>RangeFrom&lt;Idx&gt;</code>, 代码略
<code>.. end</code>的数据结构是<code>RangeTo&lt;Idx&gt;</code>, 略
<code>start..=end</code>的数据结构是<code>RangeInclusive&lt;Idx&gt;</code> 略
<code>..=end</code>的数据结构是<code>RangeToInclusive&lt;Idx&gt;</code>,略</p>
<p>以上的Idx需要满足Idx:PartialOrd<Idx></p>
<p>为了明确上述结构中的边界值是否属于Range内部，定义了Range的边界类型结构Bound
源代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Bound&lt;T&gt; {
    /// 边界包括在Range内
    Included(T),
    /// 边界不包括在Range内
    Excluded(T),
    /// 边界是无限的，边界不存在
    Unbounded,
}
<span class="boring">}</span></code></pre></pre>
<p>利用<code>RangeBounds&lt;T: ?Sized&gt;</code>的trait实现了对Range的边界取值及判断某值是否在Range中。
所有Range类型都实现了此trait。代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait RangeBounds&lt;T: ?Sized&gt; {
    /// 获取范围的起始值
    ///
    /// 例子
    /// assert_eq!((..10).start_bound(), Unbounded);
    /// assert_eq!((3..10).start_bound(), Included(&amp;3));
    fn start_bound(&amp;self) -&gt; Bound&lt;&amp;T&gt;;

    /// 获取范围的终止值.
    /// 例子
    /// assert_eq!((3..).end_bound(), Unbounded);
    /// assert_eq!((3..10).end_bound(), Excluded(&amp;10));
    fn end_bound(&amp;self) -&gt; Bound&lt;&amp;T&gt;;

    /// 范围是否包括某个值.
    /// 例子
    /// assert!( (3..5).contains(&amp;4));
    /// assert!(!(3..5).contains(&amp;2));
    ///
    /// assert!( (0.0..1.0).contains(&amp;0.5));
    /// assert!(!(0.0..1.0).contains(&amp;f32::NAN));
    /// assert!(!(0.0..f32::NAN).contains(&amp;0.5));
    /// assert!(!(f32::NAN..1.0).contains(&amp;0.5));
    fn contains&lt;U&gt;(&amp;self, item: &amp;U) -&gt; bool
    where
        T: PartialOrd&lt;U&gt;,
        U: ?Sized + PartialOrd&lt;T&gt;,
    {
        //比较有意思的典型的RUST代码
        (match self.start_bound() {
            Included(start) =&gt; start &lt;= item,
            Excluded(start) =&gt; start &lt; item,
            Unbounded =&gt; true,
        }) &amp;&amp; (match self.end_bound() {
            Included(end) =&gt; item &lt;= end,
            Excluded(end) =&gt; item &lt; end,
            Unbounded =&gt; true,
        })
    }
}

<span class="boring">}</span></code></pre></pre>
<p>RangeBounds针对RangeFull，RangeTo, RangeInclusive, RangeToInclusive, RangeFrom, Range结构都进行了实现。同时针对(Bound<T>, Bound<T>)的元组做了实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RangeBounds&lt;T&gt; for RangeFrom&lt;T&gt; {
    fn start_bound(&amp;self) -&gt; Bound&lt;&amp;T&gt; {
        Included(&amp;self.start)
    }
    fn end_bound(&amp;self) -&gt; Bound&lt;&amp;T&gt; {
        Unbounded
    }
}

impl&lt;T&gt; RangeBounds&lt;T&gt; for Range&lt;T&gt; {
    fn start_bound(&amp;self) -&gt; Bound&lt;&amp;T&gt; {
        Included(&amp;self.start)
    }
    fn end_bound(&amp;self) -&gt; Bound&lt;&amp;T&gt; {
        Excluded(&amp;self.end)
    }
}
//其他略

<span class="boring">}</span></code></pre></pre>
<h4 id="range的灵活性"><a class="header" href="#range的灵活性">Range的灵活性</a></h4>
<p>完全可以定义 ((0,0)..(100,100))； (&quot;1st&quot;..&quot;30th&quot;)这种极有表现力的Range。
Range使用的时候，需要先定义一个取值集合，定义类型表示这个集合，针对类型实现PartialOrd。就可以对这个集合的类型用Range符号了。
值得注意的是，对于<code>Range&lt;Idx&gt;</code> ,如果一个变量类型为U, 则如果实现了<code>PartialOrd&lt;U&gt; for Idx</code>， 那U就有可能属于Range, 即U可以与Idx不同。
Range操作符多用于与Index运算符结合或与Iterator Trait结合使用，在后继的Index运算符和Iterator中会研究Range是如何与他们结合的。</p>
<h4 id="小结-4"><a class="header" href="#小结-4">小结</a></h4>
<p>基于泛型的Range类型提供了非常好的语法手段，只要某类型支持排序，那就可以定义一个在此类型基础上实现的Range类型。再结合Index和Iterator, 将高效的实现极具冲击力的代码。</p>
<h3 id="rust的index-运算符代码分析"><a class="header" href="#rust的index-运算符代码分析">RUST的Index 运算符代码分析</a></h3>
<p>代码路径：<br />
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ops\index.rs</p>
<p>数组下标符号[]由Index, IndexMut两个Trait完成重载。数组下标符号重载使得程序更有可读性。两个Trait如下定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// [T][Idx] 形式重载
pub trait Index&lt;Idx: ?Sized&gt; {
    /// The returned type after indexing.
    type Output: ?Sized;

    /// 如果传入的参数超过内存界限将马上引发panic
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}
//mut [T][Idx]形式重载
pub trait IndexMut&lt;Idx: ?Sized&gt;: Index&lt;Idx&gt; {
    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>由以上可以看出类似[&quot;Hary&quot;], [&quot;Bold&quot;]之类的下标表达形式都是可以存在的。</p>
<h4 id="切片数据结构t的index实现"><a class="header" href="#切片数据结构t的index实现">切片数据结构[T]的Index实现</a></h4>
<p>切片的Index实现采用了一个辅助的trait  <code>SliceIndex&lt;[T]&gt;</code>来支持。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, I&gt; ops::Index&lt;I&gt; for [T]
where
    I: SliceIndex&lt;[T]&gt;,
{
    type Output = I::Output;

    fn index(&amp;self, index: I) -&gt; &amp;I::Output {
        index.index(self)
    }
}

impl&lt;T, I&gt; ops::IndexMut&lt;I&gt; for [T]
where
    I: SliceIndex&lt;[T]&gt;,
{
    fn index_mut(&amp;mut self, index: I) -&gt; &amp;mut I::Output {
        index.index_mut(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>SliceIndex trait 被设计同时满足Index trait及切片类型自身方法的需求。因为这些需求在逻辑上是同领域的。集中在SliceIndex trait模块内聚性更好。如：
<code>[T]::get&lt;I:SliceIndex&gt;(&amp;self, I)-&gt;Option&lt;&amp;I::Output&gt;</code> 就是直接调用SliceIndex中的方法来实现切片成员的获取。</p>
<p>以下是SliceIndex trait的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod private_slice_index {
    use super::ops;
    //在私有模块中定义一个Sealed Trait，后继的SliceIndex继承Sealed。
    //带来的结果是只有在本模块实现了Sealed Trait的类型才能实现SliceIndex
    //即使SliceIndex是公有定义，其他类型仍然不能够实现SliceIndex
    pub trait Sealed {}

    impl Sealed for usize {}
    impl Sealed for ops::Range&lt;usize&gt; {}
    impl Sealed for ops::RangeTo&lt;usize&gt; {}
    impl Sealed for ops::RangeFrom&lt;usize&gt; {}
    impl Sealed for ops::RangeFull {}
    impl Sealed for ops::RangeInclusive&lt;usize&gt; {}
    impl Sealed for ops::RangeToInclusive&lt;usize&gt; {}
    impl Sealed for (ops::Bound&lt;usize&gt;, ops::Bound&lt;usize&gt;) {}
}

pub unsafe trait SliceIndex&lt;T: ?Sized&gt;: private_slice_index::Sealed {
    /// 此类型通常为T或者T的引用，切片，裸指针类型
    type Output: ?Sized;

    // 从slice变量中用self获取Option&lt;Output&gt;变量
    fn get(self, slice: &amp;T) -&gt; Option&lt;&amp;Self::Output&gt;;

    fn get_mut(self, slice: &amp;mut T) -&gt; Option&lt;&amp;mut Self::Output&gt;;

    //slice是序列的头指针，后面的具体实现会看到为什么用 *const
    unsafe fn get_unchecked(self, slice: *const T) -&gt; *const Self::Output;

    unsafe fn get_unchecked_mut(self, slice: *mut T) -&gt; *mut Self::Output;
    
    //如果self超出slice的安全范围，会panic
    fn index(self, slice: &amp;T) -&gt; &amp;Self::Output;

    fn index_mut(self, slice: &amp;mut T) -&gt; &amp;mut Self::Output;
}

//为usize实现SliceIndex
unsafe impl&lt;T&gt; SliceIndex&lt;[T]&gt; for usize {
    type Output = T;

    //此函数主要用在不适合使用下标时，例如不确定切片长度，又不希望panic
    fn get(self, slice: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {
        // 这里slice 被强制转化成了* const [T]
        if self &lt; slice.len() { unsafe { Some(&amp;*self.get_unchecked(slice)) } } else { None }
    }

    fn get_mut(self, slice: &amp;mut [T]) -&gt; Option&lt;&amp;mut T&gt; {
        //这里slice 被强制转化成了*mut [T]
        if self &lt; slice.len() { unsafe { Some(&amp;mut *self.get_unchecked_mut(slice)) } } else { None }
    }
    
    //此函数主要用在不适合下标的情况下
    unsafe fn get_unchecked(self, slice: *const [T]) -&gt; *const T {
        //slice.as_ptr()获得* const T，利用* const T的add方法来取得slice成员的地址
        unsafe { slice.as_ptr().add(self) }
    }

    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -&gt; *mut T {
        //as_mut_ptr返回* mut T指针，在用add方法获得成员地址。
        unsafe { slice.as_mut_ptr().add(self) }
    }

    fn index(self, slice: &amp;[T]) -&gt; &amp;T {
        //使用编译器内置支持，为了效率直接使用了内置的数组下标表示。此操作可能引发panic
        &amp;(*slice)[self]
    }

    fn index_mut(self, slice: &amp;mut [T]) -&gt; &amp;mut T {
        // 使用编译器内置下标运算符，可能引发panic
        &amp;mut (*slice)[self]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上就是针对[T]的以无符号数作为下标取出单一元素的ops::Index 及 ops::IndexMut的底层实现。</p>
<p>针对Range做下标的代码实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;T&gt; SliceIndex&lt;[T]&gt; for ops::Range&lt;usize&gt; {
    type Output = [T];
    
    //不会引发panic的方法
    //此处注意，self是Rang&lt;usize&gt;
    fn get(self, slice: &amp;[T]) -&gt; Option&lt;&amp;[T]&gt; {
        //提前做判断
        if self.start &gt; self.end || self.end &gt; slice.len() {
            None
        } else {
            unsafe { Some(&amp;*self.get_unchecked(slice)) }
        }
    }
    
    //可变引用获取
    fn get_mut(self, slice: &amp;mut [T]) -&gt; Option&lt;&amp;mut [T]&gt; {
        if self.start &gt; self.end || self.end &gt; slice.len() {
            None
        } else {
            unsafe { Some(&amp;mut *self.get_unchecked_mut(slice)) }
        }
    }

    //不对输出参数做判断, 调用者要保证输入参数没有问题
    unsafe fn get_unchecked(self, slice: *const [T]) -&gt; *const [T] {
        // 先将*const [T] 转换为 * const T，完成指针运算，然后再转换成* const [T]
        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }
    }
    
    //与上面函数类似，略
    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -&gt; *mut [T] {
        unsafe {
            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)
        }
    }

    fn index(self, slice: &amp;[T]) -&gt; &amp;[T] {
        //超出范围会直接panic
        if self.start &gt; self.end {
            slice_index_order_fail(self.start, self.end);
        } else if self.end &gt; slice.len() {
            slice_end_index_len_fail(self.end, slice.len());
        }
        //将* const [T]转化为切片引用
        unsafe { &amp;*self.get_unchecked(slice) }
    }

    fn index_mut(self, slice: &amp;mut [T]) -&gt; &amp;mut [T] {
        //超出范围会直接panic
        if self.start &gt; self.end {
            slice_index_order_fail(self.start, self.end);
        } else if self.end &gt; slice.len() {
            slice_end_index_len_fail(self.end, slice.len());
        }
        unsafe { &amp;mut *self.get_unchecked_mut(slice) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上是实现用Range从slice中取出子slice的实现。同样是使用裸指针来达到最高效率。实际上，不用裸指针就没法实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl&lt;T&gt; SliceIndex&lt;[T]&gt; for ops::RangeTo&lt;usize&gt; {
    type Output = [T];

    fn get(self, slice: &amp;[T]) -&gt; Option&lt;&amp;[T]&gt; {
        //将RangeTo转换成Range, 然后对ops::Range&lt;usize&gt;的方法直接调用
        (0..self.end).get(slice)
    }

    fn get_mut(self, slice: &amp;mut [T]) -&gt; Option&lt;&amp;mut [T]&gt; {
        //对ops::Range&lt;usize&gt;的方法直接调用
        (0..self.end).get_mut(slice)
    }
    
    //其他方法也是直接对Range&lt;usize&gt;的实现做调用， 略
}
<span class="boring">}</span></code></pre></pre>
<p>RangeFrom, RangeInclusive, RangeToInclusive, RangeFull等与RangeTo的实现类似，略。</p>
<h5 id="小结-5"><a class="header" href="#小结-5">小结</a></h5>
<p>RUST切片的下标计算展示了裸指针的使用技巧，在数组类的成员操作中，基本无法脱离裸指针。在这里，只要不越界，裸指针操作是安全的。</p>
<h4 id="数组数据结构tn的opsindex实现"><a class="header" href="#数组数据结构tn的opsindex实现">数组数据结构[T;N]的ops::Index实现</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//注意这里的常量的Trait约束的写法
impl&lt;T, I, const N: usize&gt; Index&lt;I&gt; for [T; N]
where
    [T]: Index&lt;I&gt;,
{
    type Output = &lt;[T] as Index&lt;I&gt;&gt;::Output;

    fn index(&amp;self, index: I) -&gt; &amp;Self::Output {
        Index::index(self as &amp;[T], index)
    }
}

impl&lt;T, I, const N: usize&gt; IndexMut&lt;I&gt; for [T; N]
where
    [T]: IndexMut&lt;I&gt;,
{
    fn index_mut(&amp;mut self, index: I) -&gt; &amp;mut Self::Output {
        IndexMut::index_mut(self as &amp;mut [T], index)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上， <code>self as &amp;[T]</code> 即把[T;N]转化为了切片[T], 所以数组的Index就是[T]的Index实现</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust的iterator实现代码分析"><a class="header" href="#rust的iterator实现代码分析">RUST的Iterator实现代码分析</a></h1>
<p>代码路径：<br />
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\iter*.*</p>
<p>Iterator在函数式编程中是居于最核心的地位。在函数式编程中，最关键的就是把问题的解决方式设计成能够使用Iterator方案来解决。RUST基本上可以说是原生的Iterator语言，几乎所有的核心关键复合类型都对Iterator作出实现。</p>
<h2 id="rust的iterator与其他语言iterator比较"><a class="header" href="#rust的iterator与其他语言iterator比较">RUST的Iterator与其他语言Iterator比较</a></h2>
<p>RUST定义了三种迭代器:</p>
<ol>
<li>对变量本身进行遍历的的into_iter，需要实现如下trait：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}</span></code></pre></pre>
<p>into_iter返回的迭代器迭代时，会消费变量及容器，完全迭代后容器将不再存在。</p>
<ol start="2">
<li>对变量不可变引用进行遍历的iter,类型一般实现以下方法获得此迭代器: </li>
</ol>
<p><code>pub fn iter(&amp;self) -&gt; I:Iterator</code>
这种迭代器在程序中经常使用，例如，遍历游戏玩家的列表以进行统计</p>
<ol start="3">
<li>对变量的可变引用进行遍历的iter_mut,类型一般实现以下方法获得此迭代器：</li>
</ol>
<p><code>pub fn iter_mut(&amp;self) -&gt; I:Iterator </code>
这种迭代器的一个例子是遍历游戏玩家，更新玩家在线时间。</p>
<p>其他语言一般仅实现第3种迭代器。</p>
<p>对变量本身遍历的迭代器是RUST独有的所有权和drop机制带来的一种迭代器。在适合的场景下会缩减代码量及提高效率。</p>
<p>一般的，RUST要求额外实现下面的两种机制<br />
T::iter() 等同于 &amp;T::into_iter()<br />
T::iter_mut() 等同于 &amp;mut T::into_iter()</p>
<h2 id="iterator-trait-定义"><a class="header" href="#iterator-trait-定义">Iterator Trait 定义</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    /// 每次迭代时返回的变量类型.
    type Item;
    
    //灵魂方法
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    
    //size_hint返回值是此迭代器最少产生多少个有效迭代输出，最多产生多少有有效迭代输出。
    //所以，诸如(0..10).int_iter(), 最少是10个，最多也是10个，
    //而（0..10).filter(|x| x%2 == 0), 因为编译器不会提前计算，所以符合条件的最少可能是0个，最多是10个
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (0, None)
    }

    //将Iterator中所有的成员做累积操作
    //init作为f的初始值输入，
    fn fold&lt;B, F&gt;(mut self, init: B, mut f: F) -&gt; B
    where
        Self: Sized,
        F: FnMut(B, Self::Item) -&gt; B,
    {
        let mut accum = init;
        while let Some(x) = self.next() {
            accum = f(accum, x);
        }
        accum
    }

    //其他方法
    ...
    ...
}

//在定义一个trait后，
//要考虑针对已经实现这种trait的
//类型的引用/可变引用/切片/数组
//能否用adapter的方式实现该trait
//下面是Iterator的一个例子
impl&lt;I: Iterator + ?Sized&gt; Iterator for &amp;mut I {
    type Item = I::Item;
    fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt; {
        (**self).next()
    }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (**self).size_hint()
    }
    fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), usize&gt; {
        (**self).advance_by(n)
    }
    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt; {
        (**self).nth(n)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="iterator与其他集合类型转换结构与分析"><a class="header" href="#iterator与其他集合类型转换结构与分析">Iterator与其他集合类型转换结构与分析</a></h2>
<p>RUST提供了<em>集合类型</em>与Iterator互相转换的trait：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//从Iterator创建集合
pub trait FromIterator&lt;A&gt;: Sized {
    //从Iterator中创建集合
    fn from_iter&lt;T: IntoIterator&lt;Item = A&gt;&gt;(iter: T) -&gt; Self;
}

//对实现Iterator trait的集合类型实现IntoIterator
impl&lt;I: Iterator&gt; IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    fn into_iter(self) -&gt; I {
        self
    }
}

//此trait用于从一个Iterator给集合扩充成员
pub trait Extend&lt;A&gt; {
    //将Iterator的成员增加到集合
    fn extend&lt;T: IntoIterator&lt;Item = A&gt;&gt;(&amp;mut self, iter: T);

    /// 仅增加一个成员
    fn extend_one(&amp;mut self, item: A) {
        //Option实现了Iterator
        self.extend(Some(item));
    }

    //扩充容量以备后用
    fn extend_reserve(&amp;mut self, additional: usize) {
        let _ = additional;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Iterator中的转换方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    ...
    ...

    fn collect&lt;B: FromIterator&lt;Self::Item&gt;&gt;(self) -&gt; B
    where
        Self: Sized,
    {
        FromIterator::from_iter(self)
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>以上说明，对于任意的集合类型，只要实现了FromIterator trait，即可通过collect生成。从而使得不同集合类型之间的转换变得统一，方便及松耦合。</p>
<h2 id="opsrange类型的iterator实现"><a class="header" href="#opsrange类型的iterator实现">ops::Range类型的Iterator实现</a></h2>
<p>代码路径：</p>
<p>%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\iter\range.rs</p>
<p>Range被直接实现Iterator trait，没有用其他辅助结构。
定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;A: Step&gt; Iterator for ops::Range&lt;A&gt; {
    type Item = A;
    
    fn next(&amp;mut self) -&gt; Option&lt;A&gt; {
        self.spec_next()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        if self.start &lt; self.end {
            let hint = Step::steps_between(&amp;self.start, &amp;self.end);
            (hint.unwrap_or(usize::MAX), hint)
        } else {
            (0, Some(0))
        }
    }

    fn nth(&amp;mut self, n: usize) -&gt; Option&lt;A&gt; {
        self.spec_nth(n)
    }
    ...
    ...
    
}
<span class="boring">}</span></code></pre></pre>
<p>Range Iterator的具体实现RangeIteratorImpl trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;A: Step&gt; RangeIteratorImpl for ops::Range&lt;A&gt; {
    type Item = A;

    default fn spec_next(&amp;mut self) -&gt; Option&lt;A&gt; {
        if self.start &lt; self.end {
            //self.start.clone()是为了不转移self.start的所有权
            let n =
                Step::forward_checked(self.start.clone(), 1).expect(&quot;`Step` invariants not upheld&quot;);
            //mem::replace将self.start赋值为n，返回self.start的值，这个方式适用于任何类型，且处理了所有权问题
            //mem::replace是效率最高的代码方式
            Some(mem::replace(&amp;mut self.start, n))
        } else {
            None
        }
    }

    ...
}
<span class="boring">}</span></code></pre></pre>
<p>由上面的代码可以看出，每一次next实际都对Range本身做出了修改，这一修改是使用mem::replace实现的。要理解这是为什么。</p>
<p>只有基于实现<code>Step Trait</code>的类型的Range才支持了Iterator, 而代码关键是Step Trait的方法，
<code>Step Trait</code>的定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Step: Clone + PartialOrd + Sized {
    /// 从start 到end一共多少step
    fn steps_between(start: &amp;Self, end: &amp;Self) -&gt; Option&lt;usize&gt;;

    /// 向前count步返回值
    fn forward_checked(start: Self, count: usize) -&gt; Option&lt;Self&gt;;

    /// 向前count步 返回值，出错退出
    fn forward(start: Self, count: usize) -&gt; Self {
        Step::forward_checked(start, count).expect(&quot;overflow in `Step::forward`&quot;)
    }

    /// 向前不检查 count步
    unsafe fn forward_unchecked(start: Self, count: usize) -&gt; Self {
        Step::forward(start, count)
    }

    /// 向后count步
    fn backward_checked(start: Self, count: usize) -&gt; Option&lt;Self&gt;;

    /// 向后count步，出错退出
    fn backward(start: Self, count: usize) -&gt; Self {
        Step::backward_checked(start, count).expect(&quot;overflow in `Step::backward`&quot;)
    }
    
    /// 向后count步，出错退出
    unsafe fn backward_unchecked(start: Self, count: usize) -&gt; Self {
        Step::backward(start, count)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>照此，可以实现一个自定义类型的类型, 并支持Step Trait，如此，即可使用Range符号的Iterator。例如，一个二维的点的range,例如Range&lt;(i32, i32)&gt;的变量((0,0)..(10,10)), 三维的点的range，数列等。</p>
<p>一下是为所有整数类型实现Step的宏：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>macro_rules! step_identical_methods {
    () =&gt; {
        unsafe fn forward_unchecked(start: Self, n: usize) -&gt; Self {
            // 调用代码需要保证加法不会越界.
            unsafe { start.unchecked_add(n as Self) }
        }

        unsafe fn backward_unchecked(start: Self, n: usize) -&gt; Self {
            // 调用代码需要保证减法不会越界.
            unsafe { start.unchecked_sub(n as Self) }
        }

        fn forward(start: Self, n: usize) -&gt; Self {
            // debug 编译情况下 以下代码对溢出会panic，release以下代码会被优化掉
            if Self::forward_checked(start, n).is_none() {
                let _ = Self::MAX + 1;
            }
            // release 编译采用的加法 
            start.wrapping_add(n as Self)
        }

        fn backward(start: Self, n: usize) -&gt; Self {
            // debug编译，以下代码在debug目标对溢出会panic，release会被优化掉.
            if Self::backward_checked(start, n).is_none() {
                let _ = Self::MIN - 1;
            }
            // release编译采用的加法
            start.wrapping_sub(n as Self)
        }
    };
}

macro_rules! step_integer_impls {
    {
        //比CPU字长小的无符号整数类型及有符号整数类型
        narrower than or same width as usize:
            $( [ $u_narrower:ident $i_narrower:ident ] ),+;
        //比CPU字长大的无符号整数类型及有符号整数类型
        wider than usize:
            $( [ $u_wider:ident $i_wider:ident ] ),+;
    } =&gt; {
        $(
            //为所有比CPU字长小的无符号整数类型的Step实现
            impl Step for $u_narrower {
                //通用实现
                step_identical_methods!();

                fn steps_between(start: &amp;Self, end: &amp;Self) -&gt; Option&lt;usize&gt; {
                    if *start &lt;= *end {
                        // u_nrrower类型字长必须小于usize字长
                        Some((*end - *start) as usize)
                    } else {
                        None
                    }
                }

                fn forward_checked(start: Self, n: usize) -&gt; Option&lt;Self&gt; {
                    //将类型转换可能不成功显化，这是需要养成的RUST的特有思维
                    match Self::try_from(n) {
                        //checked_add完成溢出检查
                        Ok(n) =&gt; start.checked_add(n),
                        Err(_) =&gt; None, 
                    }
                }

                fn backward_checked(start: Self, n: usize) -&gt; Option&lt;Self&gt; {
                    match Self::try_from(n) {
                        Ok(n) =&gt; start.checked_sub(n),
                        Err(_) =&gt; None, // if n is out of range, `unsigned_start - n` is too
                    }
                }
            }
            
            //略
            ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Range实现Iterator的代码不复杂，但是从类型转换及加减法的处理上深刻的体现了RUST的安全理念。</p>
<h2 id="slice的iterator实现"><a class="header" href="#slice的iterator实现">slice的Iterator实现</a></h2>
<p>代码路径：<br />
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\slice\iter.rs</p>
<p>首先定义了适合&amp;[T]的Iter结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T: 'a&gt; {
    //当前元素的指针，与end用不同的类型表示
    ptr: NonNull&lt;T&gt;,
    //尾元素指针，用ptr == end以快速检测iterator是否为空
    end: *const T, 
    //这里PhantomData 主要用来做生命周期标识，用来做Iter结构体与切片之间的生命周期关系检测
    _marker: PhantomData&lt;&amp;'a T&gt;, 
}

pub struct IterMut&lt;'a, T: 'a&gt; {
    ptr: NonNull&lt;T&gt;,
    end: *mut T, 
    _marker: PhantomData&lt;&amp;'a mut T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这里，一个疑惑就是为什么不用下标及切片长度来作为Iter结构。这是因为可变的Iterator实现无法支持。
例如，给出如下结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IterMut &lt;'a, T:'a&gt; {
    current: usize,
    len: usize,
    slice: 'a mut &amp;[T]
}
<span class="boring">}</span></code></pre></pre>
<p>显然，当IterMut结构是可变借用时，无法再返回一个内部成员的借用用作迭代器的迭代返回值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; IterMut&lt;'a, T&gt; {
    pub(super) fn new(slice: &amp;'a mut [T]) -&gt; Self {
        let ptr = slice.as_mut_ptr();
        unsafe {
            assume(!ptr.is_null());

            let end = if mem::size_of::&lt;T&gt;() == 0 {
                (ptr as *mut u8).wrapping_add(slice.len()) as *mut T
            } else {
                ptr.add(slice.len())
            };

            Self { ptr: NonNull::new_unchecked(ptr), end, _marker: PhantomData }
        }
    }
    
    ...
    ...
}
//用宏来实现切片的Iterator trait
iterator! {struct IterMut -&gt; *mut T, &amp;'a mut T, mut, {mut}, {}}

//上面的宏定义
macro_rules! iterator {
    (
        struct $name:ident -&gt; $ptr:ty,
        $elem:ty,
        $raw_mut:tt,
        {$( $mut_:tt )?},
        {$($extra:tt)*}
    ) =&gt; {
        // 正向next函数辅助宏，实际的逻辑见post_inc_start函数
        macro_rules! next_unchecked {
            ($self: ident) =&gt; {&amp; $( $mut_ )? *$self.post_inc_start(1)}
        }

        // 反向的next函数
        macro_rules! next_back_unchecked {
            ($self: ident) =&gt; {&amp; $( $mut_ )? *$self.pre_dec_end(1)}
        }

        // 0长度元素next的移动
        macro_rules! zst_shrink {
            ($self: ident, $n: ident) =&gt; {
                //0元素数组因为不能移动指针，所以移动尾指针
                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;
            }
        }
        
        //具体的方法实现 
        // $name 即 IterMut
        impl&lt;'a, T&gt; $name&lt;'a, T&gt; {
            // 从Iterator获得切片.
            fn make_slice(&amp;self) -&gt; &amp;'a [T] {
                // Iter::ptr::as_ptr，由内存首地址和切片长度创建切片指针，然后转换为引用
                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }
            }

            //实质的next
            unsafe fn post_inc_start(&amp;mut self, offset: isize) -&gt; * $raw_mut T {
                if mem::size_of::&lt;T&gt;() == 0 {
                    //0字节元素偏移实现，调整end的值，ptr不变
                    zst_shrink!(self, offset);
                    self.ptr.as_ptr()
                } else {
                    //非0字节元素，返回首地址，然后后移正确的字节
                    let old = self.ptr.as_ptr();
                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().offset(offset)) };
                    old
                }
            }

            // 从尾部做Iterator的实际实现函数
            unsafe fn pre_dec_end(&amp;mut self, offset: isize) -&gt; * $raw_mut T {
                if mem::size_of::&lt;T&gt;() == 0 {
                    //对于0字节元素，从头部及从尾部逻辑相同
                    zst_shrink!(self, offset);
                    self.ptr.as_ptr()
                } else {
                    //尾部的end即偏移后的位置。
                    self.end = unsafe { self.end.offset(-offset) };
                    self.end
                }
            }
        }

        //Iterator的实现, 即
        //impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt;
        impl&lt;'a, T&gt; Iterator for $name&lt;'a, T&gt; {
            // $elem即&amp;'a T
            type Item = $elem;

            fn next(&amp;mut self) -&gt; Option&lt;$elem&gt; {
                unsafe {
                    //安全性确认
                    assume(!self.ptr.as_ptr().is_null());
                    if mem::size_of::&lt;T&gt;() != 0 {
                        assume(!self.end.is_null());
                    }
                    if is_empty!(self) {
                        //Iter为空的话，返回None
                        None
                    } else {
                        //实际调用post_inc_start(1)
                        Some(next_unchecked!(self))
                    }
                }
            }

            fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
                //用len!宏计算Iter的长度
                let exact = len!(self);
                (exact, Some(exact))
            }

            fn count(self) -&gt; usize {
                len!(self)
            }

            fn nth(&amp;mut self, n: usize) -&gt; Option&lt;$elem&gt; {
                //如果n大于Iter的长度，清空
                if n &gt;= len!(self) {
                    if mem::size_of::&lt;T&gt;() == 0 {
                        self.end = self.ptr.as_ptr();
                    } else {
                        unsafe {
                            self.ptr = NonNull::new_unchecked(self.end as *mut T);
                        }
                    }
                    return None;
                }
                // 否则，失效前n-1个元素，然后做next
                unsafe {
                    self.post_inc_start(n as isize);
                    Some(next_unchecked!(self))
                }
            }

            fn advance_by(&amp;mut self, n: usize) -&gt; Result&lt;(), usize&gt; {
                //取长度与n中的小值
                let advance = cmp::min(len!(self), n);

                //失效advance-1个值
                unsafe { self.post_inc_start(advance as isize) };
                //返回
                if advance == n { Ok(()) } else { Err(advance) }
            }

            //从尾部Iterator
            fn last(mut self) -&gt; Option&lt;$elem&gt; {
                //实质调用post_dec_end(1)
                self.next_back()
            }

            //其他，略
            ...
            ...
            
        }
    }
}

//判断Iterator是否为空的宏
macro_rules! is_empty {
    // 可以满足0字节元素的切片及非0字节元素的切片
    ($self: ident) =&gt; {
        //Iter::ptr == Iter::end
        $self.ptr.as_ptr() as *const T == $self.end
    };
}

//取Iterator长度的宏
macro_rules! len {
    ($self: ident) =&gt; {{
        let start = $self.ptr;
        let size = size_from_ptr(start.as_ptr());
        //判断元素是否为0字节
        if size == 0 {
            // 用end减start得到0字节元素的切片长度
            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)
        } else {
            //非0字节，用内存字节数除以单元素长度
            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };
            unsafe { exact_div(diff, size) }
        }
    }};
}


<span class="boring">}</span></code></pre></pre>
<p>对于切片，RUST的所有权，借用等规定导致其迭代器实际上是一个非常好的编码训练工具，代码粗略看一遍后值得自己将其实现一遍，可以有效提高对RUST的认识和编码水平。</p>
<h2 id="字符串iterator代码分析"><a class="header" href="#字符串iterator代码分析"><a id="str_iter">字符串Iterator代码分析</a></a></h2>
<p>字符串&amp;str本质上是一个[u8]类型，并在此类型的基础上实现了对utf-8的处理。
因此，对字符串的Iterator的设计自然想到用适配器的模式来重用[u8]切片类型的Iterator的基础设施。</p>
<p>题外话，&amp;str.len()返回字符串切片字节占用数，&amp;str.chars().count()返回字符数目。
字符串切片获取Iterator有如下3个函数
&amp;str::chars() 获得以UTF-8编码的字符串的Iterator
&amp;str::bytes() 获得一个[u8]的Iterator
&amp;str::char_indices() 获得一个元组，第一个成员是字符字节数组的序号，第二个成员是字符本身
bytes()主要用于提高在程序员确定采用ASCII字符串下的运行效率。
我们以&amp;str::chars()的Iterator来看一下具体的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Chars&lt;'a&gt; {
    //利用slice通用的iter做实例化,实际是一个adapter设计模式
    pub(super) iter: slice::Iter&lt;'a, u8&gt;,
}

pub fn chars(&amp;self) -&gt; Chars&lt;'_&gt; {
    //self.as_bytes()获得一个&amp;[u8]
    Chars { iter: self.as_bytes().iter() }
}
impl&lt;'a&gt; Iterator for Chars&lt;'a&gt; {
    type Item = char;

    fn next(&amp;mut self) -&gt; Option&lt;char&gt; {
        //next_code_point见后面代码分析
        next_code_point(&amp;mut self.iter).map(|ch| {
            unsafe { char::from_u32_unchecked(ch) }
        })
    }

    fn count(self) -&gt; usize {
        // 利用切片iterator的filter来实现
        self.iter.filter(|&amp;&amp;byte| !utf8_is_cont_byte(byte)).count()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let len = self.iter.len();
        //最少按四个字节一个字符，最多按一个字节一个字符
        ((len + 3) / 4, Some(len))
    }

    fn last(mut self) -&gt; Option&lt;char&gt; {
        self.next_back()
    }

}

pub fn next_code_point&lt;'a, I: Iterator&lt;Item = &amp;'a u8&gt;&gt;(bytes: &amp;mut I) -&gt; Option&lt;u32&gt; {
    // iterator.next 
    let x = *bytes.next()?;
    if x &lt; 128 {
        //ascii字符
        return Some(x as u32);
    }

    //因为是字符串，此时第二个字节一定会有
    let init = utf8_first_byte(x, 2); 
    //获取下一个字节，一定存在   
    let y = unwrap_or_0(bytes.next());
    let mut ch = utf8_acc_cont_byte(init, y);
    if x &gt;= 0xE0 {
        // 三个字节的UTF-8
        let z = unwrap_or_0(bytes.next());
        let y_z = utf8_acc_cont_byte((y &amp; CONT_MASK) as u32, z);
        ch = init &lt;&lt; 12 | y_z;
        if x &gt;= 0xF0 {
            //四个字节的UTF-8
            let w = unwrap_or_0(bytes.next());
            ch = (init &amp; 7) &lt;&lt; 18 | utf8_acc_cont_byte(y_z, w);
        }
    }

    Some(ch)
}
<span class="boring">}</span></code></pre></pre>
<p>&amp;str的Iterator实现是一个说明Iterator设计模式优越性的经典实例。如果直接使用循环，则&amp;str与&amp;[T]必然会有很多的重复代码，使用Iterator模式后，重复代码被抽象到了Iterator模块中。&amp;str复用了&amp;[T]的iter。</p>
<h2 id="array-的iterator实现"><a class="header" href="#array-的iterator实现">array 的Iterator实现</a></h2>
<h3 id="unsize-trait"><a class="header" href="#unsize-trait">Unsize Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Unsize&lt;T: ?Sized&gt; {
    // Empty.
}
<span class="boring">}</span></code></pre></pre>
<p>实现了Unsize Trait，可以把一个固定内存大小的变量强制转换为相关的可变大小类型， 如[T;N]实现了Unsize&lt;[T]&gt;, 因此[T;N]可以转换为[T]，一般是指针转换。</p>
<h3 id="iter所用的结构"><a class="header" href="#iter所用的结构">Iter所用的结构</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T, const N: usize&gt; {
    /// data是迭代中的数组.
    /// 这个数组中，只有data[alive]是有效的，访问其他的部分，即data[..alive.start] 及data[end..]会发生UB
    /// [MaybeUninit&lt;T&gt;;N]的用法需要体会，
    data: [MaybeUninit&lt;T&gt;; N],

    /// 表明数组中有效的成员的下标范围.
    /// 必须满足:
    /// - `alive.start &lt;= alive.end`
    /// - `alive.end &lt;= N`
    alive: Range&lt;usize&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>上面这个结构是因为需要对array内成员做消费设计的。因为数组成员不支持所有权转移，所以采用了这种设计方式。数组的Iterator实现是理解所有权的一个极佳例子。</p>
<h3 id="into_iter实现"><a class="header" href="#into_iter实现">into_iter实现</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; IntoIter&lt;T, N&gt; {
    pub fn new(array: [T; N]) -&gt; Self {
        // 
        // 因为RUST特性目前还不支持数组的transmute，所以用了内存跨类型的transmute_copy，此函数将从栈中申请一块内存。
        // 拷贝完毕后，原数组的所有权已经转移到data，data内数据事实上已经初始化，但仍然还是MaybeUninit&lt;T&gt;的类型。此时，需要对原数组调用mem::forget反应所有权已经失去。
        // mem::forget不会导致内存泄漏。
        unsafe {
            let iter = Self { data: mem::transmute_copy(&amp;array), alive: 0..N };
            mem::forget(array);
            iter
        }
    }

    pub fn as_slice(&amp;self) -&gt; &amp;[T] {
        // 仅针对有效的部分返回切片引用。已经消费的不返回。
        unsafe {
            //此处调用SliceIndex::&lt;Range&gt;::get_unchecked
            //slice是&amp;[MaybeUninit&lt;T&gt;]类型
            let slice = self.data.get_unchecked(self.alive.clone());
            MaybeUninit::slice_assume_init_ref(slice)
        }
    }

    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe {
            //此处调用SliceIndex::&lt;Range&gt;::get_unchecked_mut
            //slice 是 &amp; mut [MaybeUninit&lt;T&gt;]类型
            let slice = self.data.get_unchecked_mut(self.alive.clone());
            MaybeUninit::slice_assume_init_mut(slice)
        }
    }
}

impl&lt;T, const N: usize&gt; Iterator for IntoIter&lt;T, N&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // 下面使用Range的Iterator特性实现next. alive的start会变化，从而导致start之前的数组元素无法再被访问。因为已经被消费掉。
        // Option::map完成下标值传递。
        self.alive.next().map(|idx| {
            // SliceIndex::&lt;usize&gt;::get_unchecked, MaybeUninit::&lt;T&gt;::assume_init_read()
            // 前面有过说明，assume_init_read()从堆栈中申请了T大小的内存，然后进行内存拷贝，然后返回变量
            // 此时array元素的所有权转移到返回值。
            unsafe { self.data.get_unchecked(idx).assume_init_read() }
        })
    }
    ...
    ...
}

impl&lt;T, const N: usize&gt; Drop for IntoIter&lt;T, N&gt; {
    // 这里没有被消费掉的成员必须显示释放掉。
    fn drop(&amp;mut self) {
        // as_mut_slice()获得所有具有所有权的元素，这些元素需要调用drop来释放。这里，data变量中的元素始终封装在MaybeUninit&lt;T&gt;中
        unsafe { ptr::drop_in_place(self.as_mut_slice()) }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>数组的Iterator最关键的点就是如何将数组成员的所有权取出，这是RUST语法带来的额外的麻烦和复杂性。最终的解决办法显示了RUST编码的所有权转移的一些通用的底层技巧。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, const N: usize&gt; IntoIterator for [T; N] {
    type Item = T;
    type IntoIter = IntoIter&lt;T, N&gt;;

    /// 创建消费型的iterator, 如果T不实现`Copy`, 则调用此函数后，数组不可再被访问。
    fn into_iter(self) -&gt; Self::IntoIter {
        IntoIter::new(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上创建消费数组成员的Iterator。</p>
<h3 id="iter-iter_mut实现"><a class="header" href="#iter-iter_mut实现">iter(), iter_mut()实现</a></h3>
<p>下面的数组成员引用的Iterator实质上是将数组强制转换为切片类型，应用切片类型的迭代器。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T, const N: usize&gt; IntoIterator for &amp;'a [T; N] {
    type Item = &amp;'a T;
    type IntoIter = Iter&lt;'a, T&gt;;
    
    fn into_iter(self) -&gt; Iter&lt;'a, T&gt; {
        //点号导致self强制转换成[T], 然后调用切片类型的iter
        self.iter()
    }
}

impl&lt;'a, T, const N: usize&gt; IntoIterator for &amp;'a mut [T; N] {
    type Item = &amp;'a mut T;
    type IntoIter = IterMut&lt;'a, T&gt;;
    
    
    fn into_iter(self) -&gt; IterMut&lt;'a, T&gt; {
        //self被强制转换为切片类型
        self.iter_mut()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="iterator的适配器代码分析"><a class="header" href="#iterator的适配器代码分析">Iterator的适配器代码分析</a></h2>
<h3 id="map-适配器代码分析"><a class="header" href="#map-适配器代码分析">Map 适配器代码分析</a></h3>
<p>Map相关代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait Iterator {
    //其他内容
    ...
    ...

    //创建map Iterator
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
    where
        Self: Sized,
        F: FnMut(Self::Item) -&gt; B,
    {
        Map::new(self, f)
    }
    ...
}

//此结构是一个adapter的结构
pub struct Map&lt;I, F&gt; {
    // Map的底层Iterator
    pub(crate) iter: I,
    // Map操作闭包函数
    f: F,
}

impl&lt;I, F&gt; Map&lt;I, F&gt; {
    //由Iterator::map 函数和这个函数可以理解Iterator的lazy特性，
    //Iterator的创建实际上仅仅建立了数据结构，直到next才有操作。
    pub(in crate::iter) fn new(iter: I, f: F) -&gt; Map&lt;I, F&gt; {
        Map { iter, f }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Map适配器结构相当直接而简单。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//针对Map实现Iterator
impl&lt;B, I: Iterator, F&gt; Iterator for Map&lt;I, F&gt;
where
    F: FnMut(I::Item) -&gt; B,
{
    type Item = B;

    fn next(&amp;mut self) -&gt; Option&lt;B&gt; {
        //利用底层Iterator的next，Option::map实现next
        self.iter.next().map(&amp;mut self.f)
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.iter.size_hint()
    }

    //其他函数，其实现技巧与next类似
    ...
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="chain-适配器代码分析"><a class="header" href="#chain-适配器代码分析">Chain 适配器代码分析</a></h3>
<p>相关代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    ...
    ...
    //创建Chain Iterator
    fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, U::IntoIter&gt;
    where
        Self: Sized,
        U: IntoIterator&lt;Item = Self::Item&gt;,
    {
        Chain::new(self, other.into_iter())
    }
    ...
    ...
}


pub struct Chain&lt;A, B&gt; {
    //迭代器A
    a: Option&lt;A&gt;,
    //迭代器B
    b: Option&lt;B&gt;,
}
impl&lt;A, B&gt; Chain&lt;A, B&gt; {
    pub(in super::super) fn new(a: A, b: B) -&gt; Chain&lt;A, B&gt; {
        Chain { a: Some(a), b: Some(b) }
    }
}

macro_rules! fuse {
    ($self:ident . $iter:ident . $($call:tt)+) =&gt; {
        //$iter可能已经被置为None
        match $self.$iter {
            //若$iter不为None,则调用iter的系列函数
            Some(ref mut iter) =&gt; match iter.$($call)+ {
                //函数返回None
                None =&gt; {
                    //设置$iter为None,并返回None
                    $self.$iter = None;
                    None
                }
                //其他返回函数返回值
                item =&gt; item,
            },
            //a为None时返回None
            None =&gt; None,
        }
    };
}

//与fuse类似，略
macro_rules! maybe {
    ($self:ident . $iter:ident . $($call:tt)+) =&gt; {
        match $self.$iter {
            Some(ref mut iter) =&gt; iter.$($call)+,
            None =&gt; None,
        }
    };
}

impl&lt;A, B&gt; Iterator for Chain&lt;A, B&gt;
where
    A: Iterator,
    B: Iterator&lt;Item = A::Item&gt;,
{
    type Item = A::Item;

    fn next(&amp;mut self) -&gt; Option&lt;A::Item&gt; {
        //先执行self.a.next
        match fuse!(self.a.next()) {
            //若self.a.next返回None，则执行self.b.next
            None =&gt; maybe!(self.b.next()),
            //不为None，返回a的返回值
            item =&gt; item,
        }
    }
    ...
    ...
}

<span class="boring">}</span></code></pre></pre>
<h3 id="其他"><a class="header" href="#其他">其他</a></h3>
<p>Iterator的adapter还有很多，如StepBy, Filter, Zip, Intersperse等等。具体请参考标准库手册。基本上所有的adapter都是遵循Adapter的设计模式来实现的。且每一个适配器的结构及代码逻辑都是比较简单且易理解的。</p>
<h3 id="小结-6"><a class="header" href="#小结-6">小结</a></h3>
<p>RUST的Iterater的adapter是突出的体现RUST的语法优越性的特性，借助Trait和强大的泛型机制，与c/c++/java相比较，RUST以很少的代码在标准库就实现了最丰富的adapter。而其他语言标准库往往不存在这些适配器，需要其他库来实现。
Iterator的adapter实现了强大的基于Iterator的函数式编程基础设施。函数式编程的基础框架之一便是基于Iterator和闭包实现丰富的adapter。这也凸显了RUST在语言级别对函数式编程的良好支持。</p>
<h2 id="option的iterator实现代码分析"><a class="header" href="#option的iterator实现代码分析">Option的Iterator实现代码分析</a></h2>
<p>Option实现Iterator是比较令人疑惑的，毕竟用Iterator肯定代码更多，逻辑也复杂。主要目的应该是为了重用Iterator构建的各种adapter，及为了函数式编程的需要。仅分析IntoIterator Trait所涉及的结构及方法
相关类型结构定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//into_iter的结构
pub struct IntoIter&lt;A&gt; {
    //实际的Iterator实现结构
    inner: Item&lt;A&gt;,
}

//Item同时满足into_iter(), iter(), iter_mut()
//标准库编码者的设计方式，当然也可以用其他设计
struct Item&lt;A&gt; {
    opt: Option&lt;A&gt;,
}

impl&lt;T&gt; IntoIterator for Option&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;

    //创建Iterator的实现结构体，self所有权传入结构体
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter { inner: Item { opt: self } }
    }
}

//具体实现者
impl&lt;A&gt; Iterator for Item&lt;A&gt; {
    type Item = A;

    fn next(&amp;mut self) -&gt; Option&lt;A&gt; {
        //所有权传出，并用None替换原变量的值
        self.opt.take()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        match self.opt {
            Some(_) =&gt; (1, Some(1)),
            None =&gt; (0, Some(0)),
        }
    }
}

//消费变量的Iterator实现
impl&lt;A&gt; Iterator for IntoIter&lt;A&gt; {
    type Item = A;

    fn next(&amp;mut self) -&gt; Option&lt;A&gt; {
        self.inner.next()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.inner.size_hint()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Result&lt;T,E&gt;的 Iterator与Option<T>的Iterator非常相似，略</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust基本类型代码分析二"><a class="header" href="#rust基本类型代码分析二">RUST基本类型代码分析(二)</a></h1>
<h2 id="整形类型标准库代码分析"><a class="header" href="#整形类型标准库代码分析">整形类型标准库代码分析</a></h2>
<h3 id="nonzero数据类型"><a class="header" href="#nonzero数据类型">NonZero数据类型</a></h3>
<p><code>NonZeroU8, NonZeroU16，NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize</code>
<code>NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize</code>
以上为NonZero的类型，内存结构与相应的整形数据完全相同，可以转换。上文提过，当需要0表示特殊含义时，使用NonZero类型以保证代码安全。
重要函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//利用宏简化定义代码
macro_rules! nonzero_integers {
    ( $($Ty: ident($Int: ty); )+ ) =&gt; {
        $(
            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
            #[repr(transparent)]
            pub struct $Ty($Int);

            impl $Ty {
                pub const unsafe fn new_unchecked(n: $Int) -&gt; Self {
                    unsafe { Self(n) }
                }

                pub const fn new(n: $Int) -&gt; Option&lt;Self&gt; {
                    if n != 0 {
                        Some(unsafe { Self(n) })
                    } else {
                        None
                    }
                }

                pub const fn get(self) -&gt; $Int {
                    self.0
                }

            }
            
            //const 方式实现trait 
            impl const From&lt;$Ty&gt; for $Int {
                fn from(nonzero: $Ty) -&gt; Self {
                    nonzero.0
                }
            }
            //本类型和本类型&quot;|&quot;运算符重载
            impl const BitOr for $Ty {
                type Output = Self;
                fn bitor(self, rhs: Self) -&gt; Self::Output {
                    unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }
                }
            }
            //本类型与基础类型的&quot;|&quot;运算符重载
            impl const BitOr&lt;$Int&gt; for $Ty {
                type Output = Self;
                fn bitor(self, rhs: $Int) -&gt; Self::Output {
                    unsafe { $Ty::new_unchecked(self.get() | rhs) }
                }
            }
            //基础类型与本类型的&quot;|&quot;运算符重载
            impl const BitOr&lt;$Ty&gt; for $Int {
                type Output = $Ty;
                fn bitor(self, rhs: $Ty) -&gt; Self::Output {
                    unsafe { $Ty::new_unchecked(self | rhs.get()) }
                }
            }
            //&quot;|=&quot;运算符重载
            impl const BitOrAssign for $Ty {
                fn bitor_assign(&amp;mut self, rhs: Self) {
                    *self = *self | rhs;
                }
            }

            impl const BitOrAssign&lt;$Int&gt; for $Ty {
                fn bitor_assign(&amp;mut self, rhs: $Int) {
                    *self = *self | rhs;
                }
            }

            //其他运算符的重载,略
            ...
            ...
        )+
    }
}

nonzero_integers! {
    NonZeroU8(u8);
    NonZeroU16(u16);
    NonZeroU32(u32);
    NonZeroU64(u64);
    NonZeroU128(u128);
    NonZeroUsize(usize);
    NonZeroI8(i8);
    NonZeroI16(i16);
    NonZeroI32(i32);
    NonZeroI64(i64);
    NonZeroI128(i128);
    NonZeroIsize(isize);
}
<span class="boring">}</span></code></pre></pre>
<p>NonZero 类型典型的体现了RUST程序设计的安全原则，所有的异常应该用类型系统表示出来，以强制获得处理。不要用临时性的措施。这样可以最大限度的避免bug的产生。</p>
<h3 id="整形数据ops数学运算符位运算符重载实现代码分析"><a class="header" href="#整形数据ops数学运算符位运算符重载实现代码分析">整形数据ops数学运算符，位运算符重载实现代码分析</a></h3>
<p>以Add为例说明：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Add&lt;Rhs = Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

//利用宏简化操作
macro_rules! add_impl {
    ($($t:ty)*) =&gt; ($(
        impl const Add for $t {
            type Output = $t;
            //&quot;+&quot;号编译器默认实现是uncheckd_add
            //这里使用self，是一个消费操作。
            fn add(self, other: $t) -&gt; $t { self + other }
        }

        forward_ref_binop! { impl const Add, add for $t, $t }
    )*)
}

//利用宏实现所有整形和浮点型运算符的重载
add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
<span class="boring">}</span></code></pre></pre>
<p>其他数学运算符及位运算符与此接近，因为代码逻辑简单，请参考标准库手册，略</p>
<h2 id="bool类型方法代码分析"><a class="header" href="#bool类型方法代码分析">bool类型方法代码分析</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn then_some&lt;T&gt;(self, t: T) -&gt; Option&lt;T&gt;
    where
        //~const Destruct，没有找到确切的资料，
        //应该是如果T实现Drop，则必须是 impl const Drop
        //此处~const使得const在需要的时候非const化 
        T: ~const Destruct,
    {
        if self { Some(t) } else { None }
    }
    pub const fn then&lt;T, F&gt;(self, f: F) -&gt; Option&lt;T&gt;
    where
        F: ~const FnOnce() -&gt; T,
        F: ~const Destruct,
    {
        if self { Some(f()) } else { None }
    }
<span class="boring">}</span></code></pre></pre>
<p>利用Option对Try trait的支持，以上函数可以规避代码中的if..else.., 从而支持函数链式调用。</p>
<h2 id="rust字符char类型标准库代码分析"><a class="header" href="#rust字符char类型标准库代码分析">RUST字符(char)类型标准库代码分析</a></h2>
<p>RUST的字符标准库主要是编程中常用到的字符相关操作,本节摘录一些显示RUST编码特点的内容。</p>
<p>由字符串转换为字符类型：<br />
见如下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromStr for char {
    type Err = ParseCharError;
    
    //因为字符串用utf-8编码，而char是4字节变量，所以从字符串获取字符类型
    //不是简单的字符数组取值的关系，
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        //s.chars()请参考前文
        let mut chars = s.chars();
        //下面对字符串做判断，字符串中应该只有一个字符存在，否则为错误
        //具体完成utf-8的字符到char的转换在chars.next()中完成, 请参考前文
        match (chars.next(), chars.next()) {
            //无法得到字符
            (None, _) =&gt; Err(ParseCharError { kind: CharErrorKind::EmptyString }),
            //存在一个字符
            (Some(c), None) =&gt; Ok(c),
            //其他情况
            _ =&gt; Err(ParseCharError { kind: CharErrorKind::TooManyChars }),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>str::chars()函数请见前文<a href="06-基本类型续.html#str_iter">字符串Iterator代码分析</a><br />
u32转换为char,代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TryFrom&lt;u32&gt; for char {
    type Error = CharTryFromError;

    fn try_from(i: u32) -&gt; Result&lt;Self, Self::Error&gt; {
        if (i &gt; MAX as u32) || (i &gt;= 0xD800 &amp;&amp; i &lt;= 0xDFFF) {
            Err(CharTryFromError(()))
        } else {
            // RUST不支持as从u32转换到char，这里只能用tranmute暴力转换
            Ok(unsafe { transmute(i) })
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>从任一进制的数值转换为char,代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn from_digit(num: u32, radix: u32) -&gt; Option&lt;char&gt; {
    //不支持大于36进制的数，因为无法用英文字母表示了
    if radix &gt; 36 {
        panic!(&quot;from_digit: radix is too high (maximum 36)&quot;);
    }
    if num &lt; radix {
        //转换为u8，后面可以与Byte类型做加法, b'0'是Byte类型的字面量
        let num = num as u8;
        if num &lt; 10 { Some((b'0' + num) as char) } else { Some((b'a' + num - 10) as char) }
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>将字符转换为某一进制的数值,以下例子充分的说明了RUST的安全性，相对于只有一种加法的C，RUST显著的降低了程序Bug出现的可能性</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn to_digit(self, radix: u32) -&gt; Option&lt;u32&gt; {
        assert!(radix &lt;= 36, &quot;to_digit: radix is too high (maximum 36)&quot;);
        // 利用wrapping_sub同时处理大于及小于'0'的字符，并且规避溢出
        let mut digit = (self as u32).wrapping_sub('0' as u32);
        if radix &gt; 10 {
            if digit &lt; 10 {
                return Some(digit);
            }
            // 用saturating_add保证digit不会折返
            digit = (self as u32 | 0b10_0000).wrapping_sub('a' as u32).saturating_add(10);
        }
        //利用bool类型的方法简化了编程
        (digit &lt; radix).then_some(digit)
    }
<span class="boring">}</span></code></pre></pre>
<p>将字符转换为&quot;\u{xxxx}&quot;的形式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//escape_unicode充分的展示了函数式编程的设计思想
//即以迭代器为中心来设计问题解决方案，
//对于任何一个问题，首先就看是否能设计一个实现Iterator Trait的结构来解决问题
pub fn escape_unicode(self) -&gt; EscapeUnicode {
   let c = self as u32;

    // c|1避免有32个0出现
    let msb = 31 - (c | 1).leading_zeros();

    // 计算有多少个字符
    let ms_hex_digit = msb / 4;
    //生成结构，以便用Iterator解决问题
    EscapeUnicode {
        c: self,
        state: EscapeUnicodeState::Backslash,
        hex_digit_idx: ms_hex_digit as usize,
    }
}

pub struct EscapeUnicode {
    c: char,
    state: EscapeUnicodeState,

    // 当前还有多少个字符没有转换 
    hex_digit_idx: usize,
}

// 显示转换的当前状态 
#[derive(Clone, Debug)]
enum EscapeUnicodeState {
    //转换完成
    Done,
    //下一步应输出右括号
    RightBrace,
    //下一步应输出字母
    Value,
    //下一步应输出左括号
    LeftBrace,
    //输出Type的字符
    Type,
    //输出斜杠，第一个状态
    Backslash,
}

impl Iterator for EscapeUnicode {
    type Item = char;

    fn next(&amp;mut self) -&gt; Option&lt;char&gt; {
        match self.state {
            EscapeUnicodeState::Backslash =&gt; {
                self.state = EscapeUnicodeState::Type;
                Some('\\')
            }
            EscapeUnicodeState::Type =&gt; {
                self.state = EscapeUnicodeState::LeftBrace;
                Some('u')
            }
            EscapeUnicodeState::LeftBrace =&gt; {
                self.state = EscapeUnicodeState::Value;
                Some('{')
            }
            EscapeUnicodeState::Value =&gt; {
                let hex_digit = ((self.c as u32) &gt;&gt; (self.hex_digit_idx * 4)) &amp; 0xf;
                let c = from_digit(hex_digit, 16).unwrap();
                if self.hex_digit_idx == 0 {
                    self.state = EscapeUnicodeState::RightBrace;
                } else {
                    self.hex_digit_idx -= 1;
                }
                Some(c)
            }
            EscapeUnicodeState::RightBrace =&gt; {
                self.state = EscapeUnicodeState::Done;
                Some('}')
            }
            EscapeUnicodeState::Done =&gt; None,
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let n = self.len();
        (n, Some(n))
    }

    fn count(self) -&gt; usize {
        self.len()
    }

    fn last(self) -&gt; Option&lt;char&gt; {
        match self.state {
            EscapeUnicodeState::Done =&gt; None,

            EscapeUnicodeState::RightBrace
            | EscapeUnicodeState::Value
            | EscapeUnicodeState::LeftBrace
            | EscapeUnicodeState::Type
            | EscapeUnicodeState::Backslash =&gt; Some('}'),
        }
    }
}

impl fmt::Display for EscapeUnicode {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        //利用Iterator输出转换字符串 
        for c in self.clone() {
            f.write_char(c)?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>EscapeUnicode 实现了Display Trait。可以调用to_string来输出字符串
RUST的字符模块的其他转换函数与EscapeUnicode采用了类似的设计，下面列出这些转换函数，但代码分析省略
<code>pub fn escape_debug(self) -&gt; EscapeDebug</code> char的Debug转换输出
<code>pub fn to_lowercase(self) -&gt; ToLowercase</code> char转换为小写
<code>pub fn to_uppercase(self) -&gt; ToUppercase</code> char转换为大写</p>
<p>编码为UTF-8的字符串</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //dst应该保证有足够的空间放置utf-8字符串，&amp;mut str的地址就是dst
    pub fn encode_utf8(self, dst: &amp;mut [u8]) -&gt; &amp;mut str {
        unsafe { from_utf8_unchecked_mut(encode_utf8_raw(self as u32, dst)) }
    }

    pub unsafe fn from_utf8_unchecked_mut(v: &amp;mut [u8]) -&gt; &amp;mut str {
        //调用者保证v能被安全的转换
        unsafe { &amp;mut *(v as *mut [u8] as *mut str) 
    }

    pub fn encode_utf8_raw(code: u32, dst: &amp;mut [u8]) -&gt; &amp;mut [u8] {
        let len = len_utf8(code);
        match (len, &amp;mut dst[..]) {
            //rust语法的强大展现，逻辑很简单，分析略
            (1, [a, ..]) =&gt; {
                *a = code as u8;
            }
            (2, [a, b, ..]) =&gt; {
                *a = (code &gt;&gt; 6 &amp; 0x1F) as u8 | TAG_TWO_B;
                *b = (code &amp; 0x3F) as u8 | TAG_CONT;
            }
            (3, [a, b, c, ..]) =&gt; {
                *a = (code &gt;&gt; 12 &amp; 0x0F) as u8 | TAG_THREE_B;
                *b = (code &gt;&gt; 6 &amp; 0x3F) as u8 | TAG_CONT;
                *c = (code &amp; 0x3F) as u8 | TAG_CONT;
            }
            (4, [a, b, c, d, ..]) =&gt; {
                *a = (code &gt;&gt; 18 &amp; 0x07) as u8 | TAG_FOUR_B;
                *b = (code &gt;&gt; 12 &amp; 0x3F) as u8 | TAG_CONT;
                *c = (code &gt;&gt; 6 &amp; 0x3F) as u8 | TAG_CONT;
                *d = (code &amp; 0x3F) as u8 | TAG_CONT;
            }
            _ =&gt; panic!(
                &quot;encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}&quot;,
                len,
                code,
                dst.len(),
            ),
        };
        &amp;mut dst[..len]
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="字符串标准库代码分析"><a class="header" href="#字符串标准库代码分析">字符串标准库代码分析</a></h2>
<p>字符串模块的一个核心是Iterator，已经在Iterator章节中有过说明。<br />
除了Iterator，字符串其他的方法及函数库代码摘要分析如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn len(&amp;self) -&gt; usize {
        //字符串的len是字符串字节数目
        self.as_bytes().len()
    }
    //是否是字符的边界 
    pub fn is_char_boundary(&amp;self, index: usize) -&gt; bool {
        // 0 位置总是边界
        if index == 0 {
            return true;
        }

        match self.as_bytes().get(index) {
            
            None =&gt; index == self.len(),

            // 巧妙的对字符边界的总结: b &lt; 128 || b &gt;= 192
            Some(&amp;b) =&gt; (b as i8) &gt;= -0x40,
        }
    }
    //目前I的类型仅支持：
    // usize, ..(RangeFull), start..(RangeFrom), start..end(Range)
    // start..=end(RangeInclusive), ..end(RangeTo), ..=end(RangeToInclusive)  
    // get函数不会panic,但更习惯用str[usize],或者str[Range]来完成 
    pub fn get&lt;I: SliceIndex&lt;str&gt;&gt;(&amp;self, i: I) -&gt; Option&lt;&amp;I::Output&gt; {
        i.get(self)
    }
    //对i.get给出一个分析
    unsafe impl SliceIndex&lt;str&gt; for ops::Range&lt;usize&gt; {
        type Output = str;
        
        fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;Self::Output&gt; {
            //必须满足Range的两端都在字符边界处，否则返回None
            if self.start &lt;= self.end
                &amp;&amp; slice.is_char_boundary(self.start)
                &amp;&amp; slice.is_char_boundary(self.end)
            {
                // 重新建立了一个&amp;[str],具体见下面的函数
                Some(unsafe { &amp;*self.get_unchecked(slice) })
            } else {
                None
            }
        }
        //最终离不开内存和裸指针
        unsafe fn get_unchecked(self, slice: *const str) -&gt; *const Self::Output {
            let slice = slice as *const [u8];
            let ptr = unsafe { slice.as_ptr().add(self.start) };
            let len = self.end - self.start;
            ptr::slice_from_raw_parts(ptr, len) as *const str
        }
        ...
    }
    
    //其他可以用Index实现的get_xxx函数及split_at函数，略
    ...
<span class="boring">}</span></code></pre></pre>
<p>下面通过字符串的查找函数给出RUST良好的程序结构设计的一个例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //字符串查找函数，可以用模式匹配查找子串
    //支持如下例子中的查找    
    /// let s = &quot;Löwe 老虎 Léopard Gepardi&quot;;
    /// 字符的查找
    /// assert_eq!(s.find('L'), Some(0));
    /// assert_eq!(s.find('é'), Some(14));
    /// 
    /// 子字符串的查找
    /// assert_eq!(s.find(&quot;pard&quot;), Some(17));
    /// 
    /// 满足函数要求的字符或字符串的查找
    /// assert_eq!(s.find(char::is_lowercase), Some(1));
    /// assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));
    /// assert_eq!(s.find(|c: char| (c &lt; 'o') &amp;&amp; (c &gt; 'a')), Some(4));
    /// 
    /// 字符数组的查找，注意RUST中字符数组与字符串是不同的两个类型
    /// assert_eq!(s.find(['老', 'G']))
<span class="boring">}</span></code></pre></pre>
<p>由以上注释可以看到，rust的字符串查找函数功能强大，使用直观且易于理解。后继代码将展现RUST具备的：</p>
<ol>
<li>良好的扩展性，即使是原生类型，也可以直接在其上增加自定义Trait, 从而得到最直观的代码表现，而其他语言如C++/Java是无法在已经定义好的类型上做扩充的。只能创建新类型来实现对已有类型的功能扩展。不但在代码上不直观及冗余，也造成了额外的学习负担。</li>
<li>Trait语义的强大，即使对于闭包类型，也可以实现Trait。</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find&lt;'a, P: Pattern&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; Option&lt;usize&gt; {
        //利用Pattern Trait支持了众多类型的查找
        pat.into_searcher(self).next_match().map(|(i, _)| i)
    }
<span class="boring">}</span></code></pre></pre>
<p>要设计这样一个find方法:</p>
<ol>
<li>显然，参数需要是一个泛型，但泛型应该支持同样的接口，即Pattern trait</li>
<li>需要利用find的输入泛型参数，self来构造一个结构，并以这个结构为基础来实现方法完成查找。Pattern trait 的类型显然不可能作为这个结构(字符，字符切片，字符数组，闭包函数，字符串). 这个结构只能由Pattern trait的方法构造，事实上，Pattern trait最重要的工作就是构造这个结构。</li>
<li>2构造的结构应该支持统一的接口，真正的实现查找</li>
</ol>
<p>具体的实现定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //模式 Trait 定义及公共行为
    pub trait Pattern&lt;'a&gt;: Sized {
        /// 与具体类型相适配的搜索算法的实现类型，类型必须实现Searcher Trait
        type Searcher: Searcher&lt;'a&gt;;

        /// 创建Searcher，根据输入的str及类型自身属性
        fn into_searcher(self, haystack: &amp;'a str) -&gt; Self::Searcher;

        /// 检查str是否存在对模式匹配的内容
        fn is_contained_in(self, haystack: &amp;'a str) -&gt; bool {
            self.into_searcher(haystack).next_match().is_some()
        }

        //略
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>以下为Searcher trait定义。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //Pattern匹配搜索算法的具体实现Trait
    pub unsafe trait Searcher&lt;'a&gt; {
        /// Searcher针对的字符串
        fn haystack(&amp;self) -&gt; &amp;'a str;

        /// 执行下一次搜索， 返回搜索算法给出的:
        ///   [SearchStep::Match(a,b)] haystack[a..b]匹配了模式
        ///   [SearchStep::Reject(a,b)] haystack[a..b]不能匹配模式
        ///   [SearchStep::Done]
        /// next的返回结果应该上次放回的结果首尾相连。即如果上次返回Match(0,1), next的返回
        /// 应该是Reject(1,_)或Match(1,_)。第一个返回必须是Reject(0,_)或match(0,_), Done之前
        /// 的返回应该是Reject(_, haystack.len()-1)或Match(_, haystack.len())
        fn next(&amp;mut self) -&gt; SearchStep;

        /// 找到下一个匹配结果是Match的匹配结果
        fn next_match(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
            loop {
                match self.next() {
                    SearchStep::Match(a, b) =&gt; return Some((a, b)),
                    SearchStep::Done =&gt; return None,
                    _ =&gt; continue,
                }
            }
        }

        /// 找到下一个Reject
        fn next_reject(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
            loop {
                match self.next() {
                    SearchStep::Reject(a, b) =&gt; return Some((a, b)),
                    SearchStep::Done =&gt; return None,
                    _ =&gt; continue,
                }
            }
        }
   }

    pub enum SearchStep {
        /// 匹配时输出Match及子字符串的位置
        Match(usize, usize),
        /// 确定不匹配的子字符串的位置信息, 可以有多个不匹配的子字符串
        Reject(usize, usize),
        /// 字符串已经遍历完毕
        Done,
    }
<span class="boring">}</span></code></pre></pre>
<p>下面为单字符的Pattern trait的系列实现，仅展示一下相应的逻辑关系。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //针对char类型的Searcher Trait具现化类型
    pub struct CharSearcher&lt;'a&gt; { /*略*/ }
    //实现Searcher Trait
    unsafe impl&lt;'a&gt; Searcher&lt;'a&gt; for CharSearcher&lt;'a&gt; {
        //略
        ...
    }

    // 针对char 的Pattern实现, 支持如 &quot;abc&quot;.find('a') 的形态
    impl&lt;`a, `b&gt; Pattern&lt;`a&gt; for char { 
        type Searcher = CharSearcher
        
        //略
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>下面为多字符的Pattern trait的实现，因为是比较典型的设计，所以重点的进行分析：
首先，设计字符匹配的trait，并在闭包，字符数组及其引用，字符切片类型中实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //支持  &quot;abc&quot;.find(&amp;['a','b'])的形态
    //      &quot;abc&quot;.find(&amp;['a','b'][..]) 的形态 &amp;['a','b'][..] 实质是&amp;[char]类型，注意与&amp;str类型的区别
    //      &quot;abc&quot;.find(|ch| ch &gt; 'a' &amp;&amp; ch &lt; 'c') 的形态
    
    //利用MultiCharEq trait 综合[char; N], &amp;[char], FnMut(char)-&gt;bool 
    //字符匹配操作
    trait MultiCharEq {
        fn matches(&amp;mut self, c: char) -&gt; bool;
    }
    
    //为FnMut(char)-&gt;bool 实现MultiCharEq
    impl&lt;F&gt; MultiCharEq for F
    where
        F: FnMut(char) -&gt; bool,
    {
        fn matches(&amp;mut self, c: char) -&gt; bool {
            (*self)(c)
        }
    }
    
    //为[char;N]实现 MultiCharEq
    impl&lt;const N: usize&gt; MultiCharEq for [char; N] {
        fn matches(&amp;mut self, c: char) -&gt; bool {
            self.iter().any(|&amp;m| m == c)
        }
    }

    impl&lt;const N: usize&gt; MultiCharEq for &amp;[char; N] {
        fn matches(&amp;mut self, c: char) -&gt; bool {
            self.iter().any(|&amp;m| m == c)
        }
    }
    
    // 为&amp;[char]实现MultiCharEq
    impl MultiCharEq for &amp;[char] {
        #[inline]
        fn matches(&amp;mut self, c: char) -&gt; bool {
            self.iter().any(|&amp;m| m == c)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>然后是基于泛型的统一的Pattern trait和Searcher的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   //利用输入类型构造一个泛型结构
   struct MultiCharEqPattern&lt;C: MultiCharEq&gt;(C);

   //与MultiCharEqPattern相匹配的Searcher Trait具现的结构体
   struct MultiCharEqSearcher&lt;'a, C: MultiCharEq&gt; {
       char_eq: C,
       haystack: &amp;'a str,
       char_indices: super::CharIndices&lt;'a&gt;,
   }
   
   // 实现Pattern
   impl&lt;'a, C: MultiCharEq&gt; Pattern&lt;'a&gt; for MultiCharEqPattern&lt;C&gt; {
       type Searcher = MultiCharEqSearcher&lt;'a, C&gt;;
       
       //创建泛型Searcher结构
       fn into_searcher(self, haystack: &amp;'a str) -&gt; MultiCharEqSearcher&lt;'a, C&gt; {
           MultiCharEqSearcher { haystack, char_eq: self.0, char_indices: haystack.char_indices()}
       }
   }

   //针对泛型Searcher结构实现Searcher trait
   unsafe impl&lt;'a, C: MultiCharEq&gt; Searcher&lt;'a&gt; for MultiCharEqSearcher&lt;'a, C&gt; {
       fn haystack(&amp;self) -&gt; &amp;'a str {
           self.haystack
       }

       fn next(&amp;mut self) -&gt; SearchStep {
           let s = &amp;mut self.char_indices;
           //pre_len用来计算char在字符串中占用了几个字节
           let pre_len = s.iter.iter.len();
           if let Some((i, c)) = s.next() {
               let len = s.iter.iter.len();
               //计算当前字符占用的字节数
               let char_len = pre_len - len;
               if self.char_eq.matches(c) {
                   return SearchStep::Match(i, i + char_len);
               } else {
                   return SearchStep::Reject(i, i + char_len);
               }
           }
           SearchStep::Done
       }
   }
<span class="boring">}</span></code></pre></pre>
<p>下面是如何将MultiCharEqPattern及MultiCharEqSearcher应用在各类型的Pattern实现中。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    /////////////////////////////////////////////////////////////////////////////
    //利用宏简化代码
    macro_rules! pattern_methods {
        ($t:ty, $pmap:expr, $smap:expr) =&gt; {
            type Searcher = $t;

            fn into_searcher(self, haystack: &amp;'a str) -&gt; $t {
                //这里实际上是用self创建了MultiCharEqPattern(self)
                //随后用MutiEqPattern(self)创建MultiCharEqSearcher
                //然后封装MultiCharEqSearcher，创建一个与self类型关联的Searcher类型的Searcher
                ($smap)(($pmap)(self).into_searcher(haystack))
            }

            fn is_contained_in(self, haystack: &amp;'a str) -&gt; bool {
                ($pmap)(self).is_contained_in(haystack)
            }

            fn is_prefix_of(self, haystack: &amp;'a str) -&gt; bool {
                ($pmap)(self).is_prefix_of(haystack)
            }

            fn strip_prefix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt; {
                ($pmap)(self).strip_prefix_of(haystack)
            }

            fn is_suffix_of(self, haystack: &amp;'a str) -&gt; bool
            where
                $t: ReverseSearcher&lt;'a&gt;,
            {
                ($pmap)(self).is_suffix_of(haystack)
            }

            fn strip_suffix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;
            where
                $t: ReverseSearcher&lt;'a&gt;,
            {
                ($pmap)(self).strip_suffix_of(haystack)
            }
        };
    }

    // 利用宏简化代码
    macro_rules! searcher_methods {
        (forward) =&gt; {
            fn haystack(&amp;self) -&gt; &amp;'a str {
                self.0.haystack()
            }
            fn next(&amp;mut self) -&gt; SearchStep {
                //实质是MultiCharEqSearcher&lt;&gt;::next
                self.0.next()
            }
            fn next_match(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
                self.0.next_match()
            }
            fn next_reject(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
                self.0.next_reject()
            }
        };
        (reverse) =&gt; {
            fn next_back(&amp;mut self) -&gt; SearchStep {
                self.0.next_back()
            }
            fn next_match_back(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
                self.0.next_match_back()
            }
            fn next_reject_back(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
                self.0.next_reject_back()
            }
        };
    }

    //下面这个结构比较清晰的说明了 Pattern, MultiCharEqPattern, MultiCharEqSearcher的关系
    //使得代码更清晰
    pub struct CharArraySearcher&lt;'a, const N: usize&gt;(
        &lt;MultiCharEqPattern&lt;[char; N]&gt; as Pattern&lt;'a&gt;&gt;::Searcher,
    );

    /// 针对&amp;[char;N]的Pattern, MultiCharEqPattern, MultiCharEqSearcher的关系
    pub struct CharArrayRefSearcher&lt;'a, 'b, const N: usize&gt;(
        &lt;MultiCharEqPattern&lt;&amp;'b [char; N]&gt; as Pattern&lt;'a&gt;&gt;::Searcher,
    );
    
    // 利用上面的宏对[char;N]类型的Pattern Trait实现
    impl&lt;'a, const N: usize&gt; Pattern&lt;'a&gt; for [char; N] {
        pattern_methods!(CharArraySearcher&lt;'a, N&gt;, MultiCharEqPattern, CharArraySearcher);
    }
    // 对[char;N]的searcher关联类型的Searcher Trait实现，
    unsafe impl&lt;'a, const N: usize&gt; Searcher&lt;'a&gt; for CharArraySearcher&lt;'a, N&gt; {
        searcher_methods!(forward);
    }

    unsafe impl&lt;'a, const N: usize&gt; ReverseSearcher&lt;'a&gt; for CharArraySearcher&lt;'a, N&gt; {
        searcher_methods!(reverse);
    }

    // 针对&amp;[char;N]的Pattern Trait 实现
    impl&lt;'a, 'b, const N: usize&gt; Pattern&lt;'a&gt; for &amp;'b [char; N] {
        pattern_methods!(CharArrayRefSearcher&lt;'a, 'b, N&gt;, MultiCharEqPattern, CharArrayRefSearcher);
    }

    // 对&amp;[char;N]的searcher关联类型的Searcher Trait 实现
    unsafe impl&lt;'a, 'b, const N: usize&gt; Searcher&lt;'a&gt; for CharArrayRefSearcher&lt;'a, 'b, N&gt; {
        searcher_methods!(forward);
    }

    unsafe impl&lt;'a, 'b, const N: usize&gt; ReverseSearcher&lt;'a&gt; for CharArrayRefSearcher&lt;'a, 'b, N&gt; {
        searcher_methods!(reverse);
    }

    //针对&amp;[char]的Searcher具现化结构体
    pub struct CharSliceSearcher&lt;'a, 'b&gt;(&lt;MultiCharEqPattern&lt;&amp;'b [char]&gt; as Pattern&lt;'a&gt;&gt;::Searcher);

    //Searcher Trait 实现
    unsafe impl&lt;'a, 'b&gt; Searcher&lt;'a&gt; for CharSliceSearcher&lt;'a, 'b&gt; {
        searcher_methods!(forward);
    }

    unsafe impl&lt;'a, 'b&gt; ReverseSearcher&lt;'a&gt; for CharSliceSearcher&lt;'a, 'b&gt; {
        searcher_methods!(reverse);
    }

    impl&lt;'a, 'b&gt; DoubleEndedSearcher&lt;'a&gt; for CharSliceSearcher&lt;'a, 'b&gt; {}

    // 对&amp;[char]的Pattern Trait的实现
    impl&lt;'a, 'b&gt; Pattern&lt;'a&gt; for &amp;'b [char] {
        pattern_methods!(CharSliceSearcher&lt;'a, 'b&gt;, MultiCharEqPattern, CharSliceSearcher);
    }

    //针对FnMut(char)-&gt;bool的Searcher具现化结构体
    pub struct CharPredicateSearcher&lt;'a, F&gt;(&lt;MultiCharEqPattern&lt;F&gt; as Pattern&lt;'a&gt;&gt;::Searcher)
    where
        F: FnMut(char) -&gt; bool;

    //Searcher Trait 实现
    unsafe impl&lt;'a, F&gt; Searcher&lt;'a&gt; for CharPredicateSearcher&lt;'a, F&gt;
    where
        F: FnMut(char) -&gt; bool,
    {
        searcher_methods!(forward);
    }

    unsafe impl&lt;'a, F&gt; ReverseSearcher&lt;'a&gt; for CharPredicateSearcher&lt;'a, F&gt;
    where
        F: FnMut(char) -&gt; bool,
    {
        searcher_methods!(reverse);
    }

    impl&lt;'a, F&gt; DoubleEndedSearcher&lt;'a&gt; for CharPredicateSearcher&lt;'a, F&gt; where F: FnMut(char) -&gt; bool {}

    //针对FnMut(char)-&gt;bool的Pattern Trait 实现
    impl&lt;'a, F&gt; Pattern&lt;'a&gt; for F
    where
        F: FnMut(char) -&gt; bool,
    {
        pattern_methods!(CharPredicateSearcher&lt;'a, F&gt;, MultiCharEqPattern, CharPredicateSearcher);
    }
<span class="boring">}</span></code></pre></pre>
<p>多字符搜索代码不复杂，但结构设计则可圈可点。而且似乎是不得不这样做设计。RUST利用泛型及trait能够自然的得到比较好的设计结果。<br />
我们针对泛型做一个方法时，自然会对泛型用一个共用的trait——Pattern来约束。因为方法实现需要不同于泛型但紧密关联的另一个结构体，那这个结构体类型便自然的形成trait里的一个关联类型Searcher。而这个关联类型也自然应该用另一个trait——Searcher来约束。<br />
Searcher的变量应该在Pattern的方法被创建出来。Searcher trait应该提供查找的方法。<br />
这就是RUST语法自然导致好的设计的一个例子。</p>
<p>以下对子字符串搜索给出一些详细的解释，主要说明TwoWay算法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span> 
<span class="boring">fn main() {
</span>    //针对str实现的pattern， 支持如&quot;abc&quot;.find(&quot;ab&quot;)的形态
    impl&lt;'a, 'b&gt; Pattern&lt;'a&gt; for &amp;'b str {
        //StrSeacher见下面该结构的代码注释
        type Searcher = StrSearcher&lt;'a, 'b&gt;;

        fn into_searcher(self, haystack: &amp;'a str) -&gt; StrSearcher&lt;'a, 'b&gt; {
            StrSearcher::new(haystack, self)
        }
        
        //略
    }

    pub struct StrSearcher&lt;'a, 'b&gt; {
        // 被查找目标字符串
        haystack: &amp;'a str,
        // 查找的子字符串
        needle: &amp;'b str,
        // 查找算法实现体
        searcher: StrSearcherImpl,
    }

    enum StrSearcherImpl {
        //两种搜索算法，后继还可以根据需要再扩充其他的算法
        Empty(EmptyNeedle),
        TwoWay(TwoWaySearcher),
    }

   
    impl&lt;'a, 'b&gt; StrSearcher&lt;'a, 'b&gt; {
        fn new(haystack: &amp;'a str, needle: &amp;'b str) -&gt; StrSearcher&lt;'a, 'b&gt; {
            if needle.is_empty() {
                //略
                ...
                ...
            } else {
                StrSearcher {
                    haystack,
                    needle,
                    searcher: StrSearcherImpl::TwoWay(TwoWaySearcher::new(
                        needle.as_bytes(),
                        haystack.len(),
                    )),
                }
            }
        }
    }

    unsafe impl&lt;'a, 'b&gt; Searcher&lt;'a&gt; for StrSearcher&lt;'a, 'b&gt; {
        fn haystack(&amp;self) -&gt; &amp;'a str {
            self.haystack
        }

        fn next(&amp;mut self) -&gt; SearchStep {
            //此处隐藏StrSearcher后继不会更换算法。如果更换搜索算法，应该将StrSearcher整体做替换
            //
            match self.searcher {
                StrSearcherImpl::Empty(ref mut searcher) =&gt; {
                    //略
                    ...
                    ...
                }
                StrSearcherImpl::TwoWay(ref mut searcher) =&gt; {
                    if searcher.position == self.haystack.len() {
                        return SearchStep::Done;
                    }
                    let is_long = searcher.memory == usize::MAX;
                    match searcher.next::&lt;RejectAndMatch&gt;(
                        self.haystack.as_bytes(),
                        self.needle.as_bytes(),
                        is_long,
                    ) {
                        SearchStep::Reject(a, mut b) =&gt; {
                            // 因为searcher使用&amp;[u8]来搜索，返回可能不是字节边界
                            while !self.haystack.is_char_boundary(b) {
                                b += 1;
                            }
                            searcher.position = cmp::max(b, searcher.position);
                            SearchStep::Reject(a, b)
                        }
                        //这个表示语法注意一下
                        otherwise =&gt; otherwise,
                    }
                }
            }
        }

        fn next_match(&amp;mut self) -&gt; Option&lt;(usize, usize)&gt; {
            match self.searcher {
                StrSearcherImpl::Empty(..) =&gt; loop {
                    //略
                    ...
                },
                StrSearcherImpl::TwoWay(ref mut searcher) =&gt; {
                    let is_long = searcher.memory == usize::MAX;
                    // 如果匹配，那匹配点一定是字符边界
                    if is_long {
                        searcher.next::&lt;MatchOnly&gt;(
                            self.haystack.as_bytes(),
                            self.needle.as_bytes(),
                            true,
                        )
                    } else {
                        searcher.next::&lt;MatchOnly&gt;(
                            self.haystack.as_bytes(),
                            self.needle.as_bytes(),
                            false,
                        )
                    }
                }
            }
        }
    }
    /*  查找子字符串算法的关键问题如下：
        1. 每次比较的匹配的位置在哪里？
        2. 不匹配时应移动多少个位置开始新一次匹配？

        显然，如果子字符串不存在周期性的重复，那每次比较如果不同就只能后移一个字符然后开始新的匹配
        所以，算法主要就是在子字符串中存在周期性重复的字符的情况下来如何更好的提高效率
        TwoWay算法仅在子字符串整体有周期性时发生左右，仅是内部少量字符的周期性，TwoWay算法不考虑。
        设待比较字符串为H, 子字符串为S, 周期字符串为w, 周期为p，w的前缀为w-则S为 w(w|w-)+
        对于S，TwoWay算法找到一个crit_pos, 先从S的crit_pos的位置开始与H做比较到S的尾部，如果对应字符位置crit_pos+i
        的比较不成功，会在S上偏移i，清除记录，然后继续比较。
        如果直到尾部比较都成功，则会记录，然后开始比较头部，如果头部比较不成功，则偏移p，后继比较会考虑比较成功的记录。
        
        TwoWay不是最快的算法，但占用内存少，且也在一定程度上提高了效率。是比较适合的库方法
        */
    struct TwoWaySearcher {
        // constants
        /// 每次比较的开始位置，从此位置向尾部
        crit_pos: usize,
        /// 每次反向比较的开始位置，从此位置向前部
        crit_pos_back: usize,
        // 周期
        period: usize,
        /// 子字符串的位图，用来做一个快速甄别和判断
        byteset: u64,

        // 在待比较字符串的位置,从头部向后查找
        position: usize,
        // 待比较字符串的位置，从尾部向前查找
        end: usize,
        /// 在尾部比较成功后，记录已经比较过的字符串
        memory: usize,
        /// 同上，不过是反方向比较
        memory_back: usize,
    }

    impl TwoWaySearcher {
        fn new(needle: &amp;[u8], end: usize) -&gt; TwoWaySearcher {
            let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);
            let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);
            
            //找到更偏向尾部的位置
            let (crit_pos, period) = if crit_pos_false &gt; crit_pos_true {
                (crit_pos_false, period_false)
            } else {
                (crit_pos_true, period_true)
            };

            //这里可以看出，只有从头部开始的周期字符串获得支持
            if needle[..crit_pos] == needle[period..period + crit_pos] {
                let crit_pos_back = needle.len()
                    - cmp::max(
                        TwoWaySearcher::reverse_maximal_suffix(needle, period, false),
                        TwoWaySearcher::reverse_maximal_suffix(needle, period, true),
                    );

                TwoWaySearcher {
                    crit_pos,
                    crit_pos_back,
                    period,
                    byteset: Self::byteset_create(&amp;needle[..period]),

                    position: 0,
                    end,
                    memory: 0,
                    memory_back: needle.len(),
                }
            } else {
                // 字符串内没有周期性，及仅具备局部周期的字符串

                TwoWaySearcher {
                    crit_pos,
                    crit_pos_back: crit_pos,
                    period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,
                    byteset: Self::byteset_create(needle),

                    position: 0,
                    end,
                    memory: usize::MAX, // Dummy value to signify that the period is long
                    memory_back: usize::MAX,
                }
            }
        }

        fn byteset_create(bytes: &amp;[u8]) -&gt; u64 {
            bytes.iter().fold(0, |a, &amp;b| (1 &lt;&lt; (b &amp; 0x3f)) | a)
        }

        fn byteset_contains(&amp;self, byte: u8) -&gt; bool {
            (self.byteset &gt;&gt; ((byte &amp; 0x3f) as usize)) &amp; 1 != 0
        }

        fn next&lt;S&gt;(&amp;mut self, haystack: &amp;[u8], needle: &amp;[u8], long_period: bool) -&gt; S::Output
        where
            S: TwoWayStrategy,
        {
            // `next()` uses `self.position` as its cursor
            let old_pos = self.position;
            let needle_last = needle.len() - 1;
            'search: loop {
                // Check that we have room to search in
                // position + needle_last can not overflow if we assume slices
                // are bounded by isize's range.
                let tail_byte = match haystack.get(self.position + needle_last) {
                    Some(&amp;b) =&gt; b,
                    None =&gt; {
                        self.position = haystack.len();
                        return S::rejecting(old_pos, self.position);
                    }
                };
                
                //及早返回不匹配的信息
                if S::use_early_reject() &amp;&amp; old_pos != self.position {
                    return S::rejecting(old_pos, self.position);
                }

                // 用位图判断出tail_byte不在子字符串中，可以立刻偏移到下一个字节再比较
                if !self.byteset_contains(tail_byte) {
                    self.position += needle.len();
                    if !long_period {
                        self.memory = 0;
                    }
                    continue 'search;
                }

                // 如果memory有值且大于crip_pos, 那就从memory开始比较，memory前的已经匹配完毕
                // long_period 没有memory的逻辑，和暴力比较无差异
                let start =
                    if long_period { self.crit_pos } else { cmp::max(self.crit_pos, self.memory) };
                for i in start..needle.len() {
                    if needle[i] != haystack[self.position + i] {
                        self.position += i - self.crit_pos + 1;
                        if !long_period {
                            self.memory = 0;
                        }
                        continue 'search;
                    }
                }

                // See if the left part of the needle matches
                let start = if long_period { 0 } else { self.memory };
                for i in (start..self.crit_pos).rev() {
                    if needle[i] != haystack[self.position + i] {
                        //period后面的字符已经比较完毕，period一般大于crit_pos
                        self.position += self.period;
                        if !long_period {
                            self.memory = needle.len() - self.period;
                        }
                        continue 'search;
                    }
                }

                // 比较全部完成，
                let match_pos = self.position;

                // 为下一次比较做准备
                self.position += needle.len();
                if !long_period {
                    self.memory = 0; // set to needle.len() - self.period for overlapping matches
                }

                return S::matching(match_pos, match_pos + needle.len());
            }
        }

        // 略

    }
    // TwoWayStrategy allows the algorithm to either skip non-matches as quickly
    // as possible, or to work in a mode where it emits Rejects relatively quickly.
    trait TwoWayStrategy {
        type Output;
        fn use_early_reject() -&gt; bool;
        fn rejecting(a: usize, b: usize) -&gt; Self::Output;
        fn matching(a: usize, b: usize) -&gt; Self::Output;
    }

    /// Skip to match intervals as quickly as possible
    enum MatchOnly {}

    impl TwoWayStrategy for MatchOnly {
        type Output = Option&lt;(usize, usize)&gt;;

        fn use_early_reject() -&gt; bool {
            false
        }
        fn rejecting(_a: usize, _b: usize) -&gt; Self::Output {
            None
        }
        fn matching(a: usize, b: usize) -&gt; Self::Output {
            Some((a, b))
        }
    }

    /// Emit Rejects regularly
    enum RejectAndMatch {}

    impl TwoWayStrategy for RejectAndMatch {
        type Output = SearchStep;

        fn use_early_reject() -&gt; bool {
            true
        }
        fn rejecting(a: usize, b: usize) -&gt; Self::Output {
            SearchStep::Reject(a, b)
        }
        fn matching(a: usize, b: usize) -&gt; Self::Output {
            SearchStep::Match(a, b)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>以上对字符串查找的方法进行了分析，利用Pattern的还有以下的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //生成一个支持Iterator的结构完成split
    pub fn split&lt;'a, P: Pattern&lt;'a&gt;&gt;(&amp;'a self, pat: P) -&gt; Split&lt;'a, P&gt; {
        Split(SplitInternal {
            start: 0,
            end: self.len(),
            matcher: pat.into_searcher(self),
            allow_trailing_empty: true,
            finished: false,
        })
    }

    //略
    ...
    ...
<span class="boring">}</span></code></pre></pre>
<h2 id="切片标准库代码分析"><a class="header" href="#切片标准库代码分析">切片标准库代码分析</a></h2>
<h3 id="切片排序"><a class="header" href="#切片排序">切片排序</a></h3>
<h4 id="插入排序"><a class="header" href="#插入排序">插入排序</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 插入排序, 复杂度O(n^2).
fn insertion_sort&lt;T, F&gt;(v: &amp;mut [T], is_less: &amp;mut F)
where
    F: FnMut(&amp;T, &amp;T) -&gt; bool,
{
    //排序场景下，基本不能使用iterator
    for i in 1..v.len() {
        //利用
        shift_tail(&amp;mut v[..i + 1], is_less);
    }
}

/// 将最后的值左移到遇到更小的值.
fn shift_tail&lt;T, F&gt;(v: &amp;mut [T], is_less: &amp;mut F)
where
    F: FnMut(&amp;T, &amp;T) -&gt; bool,
{
    let len = v.len();
    
    // 因为是对泛型排序，RUST的排序算法比较复杂， 需要指出，&amp;mut [T] 保证了外界不会有对数组或数组元素的引用，而数组元素本身的内存
    // 浅拷贝等同于所有权转移，不会出现内存安全问题。
    unsafe {
        if len &gt;= 2 &amp;&amp; is_less(v.get_unchecked(len - 1), v.get_unchecked(len - 2)) {
            // ManuallyDrop把drop的权利从rust编译器接管
            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));
            // CopyOnDrop会在drop的时候做src到dest的拷贝
            let mut hole = CopyOnDrop { src: &amp;mut *tmp, dest: v.get_unchecked_mut(len - 2) };
            ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);
            
            //正常的排序内存置换操作
            for i in (0..len - 2).rev() {
                if !is_less(&amp;*tmp, v.get_unchecked(i)) {
                    break;
                }

                ptr::copy_nonoverlapping(v.get_unchecked(i), v.get_unchecked_mut(i + 1), 1);
                hole.dest = v.get_unchecked_mut(i);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>上面的排序算法最重要的是理解在元素转移的过程为什么没有影响所有权，为什么没有引发内存安全问题。这个例子充分说明了内存先关函数的重要性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内部可变类型代码分析"><a class="header" href="#内部可变类型代码分析">内部可变类型代码分析</a></h1>
<p>内部可变性类型常常让人疑惑，感觉到是&quot;xxxx,费二遍事&quot;。因为在程序中，频繁操作的变量大多属于内部可变性类型的范畴, 这就更加让人愤怒。内部可变性类型通常被RUST初学者认为是可变引用独占性的补丁特性。<br />
内部可变性类型正确的认识应该是：这是RUST的有意为之的特性，很可能是先有内部可变性，才使得可变引用的独占性成立。内部可变性设计是为了减少变量写操作的无序性，使程序员更好的去设计有可能冲突的变量写操作，减少无序写操作导致的bug。也使得程序员明确的发现变量可能冲突的写操作，产生警惕心，从而借助编译器找到更多的写冲突问题。
所以，内部可变性类型显著的提升了代码的质量。</p>
<p>内部可变性的基础是Borrow trait：</p>
<h2 id="borrow-trait-代码分析"><a class="header" href="#borrow-trait-代码分析">Borrow trait 代码分析</a></h2>
<p>代码路径如下：<br />
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\borrow.rs</p>
<p>Borrow trait实现了对变量引用的导出，一般是在封装类型上实现。通过borrow调用可以将这些类型的内部变量引用提供给外部。通常的情况下，这些类型也都实现了Deref，AsRef等trait可以获取内部变量引用，所以这些trait之间有些重复。但Borrow trait 最主要的场景是作为内部可变性类型<code>RefCell&lt;T&gt;</code>的内部变量引用导出，这是Deref, AsRef等trait无能为力的区域。本节之后将分析<code>RefCell&lt;T&gt;</code>类型时再给出进一步阐述。</p>
<p>Borrow trait代码定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Borrow&lt;Borrowed: ?Sized&gt; {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}

pub trait BorrowMut&lt;Borrowed: ?Sized&gt;: Borrow&lt;Borrowed&gt; {
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut Borrowed;
}
//每一个类型都实现了针对自身的Borrow trait
impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for T {
    fn borrow(&amp;self) -&gt; &amp;T {
        self
    }
}

//每一个类型都实现了针对自身的BorrowMut trait
impl&lt;T: ?Sized&gt; BorrowMut&lt;T&gt; for T {
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut T {
        self
    }
}

//每一个类型的引用都实现了对自身的Borrow trait
impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for &amp;T {
    fn borrow(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}
//每一个类型的可变引用都实现了针对自身的Borrow trait
impl&lt;T: ?Sized&gt; Borrow&lt;T&gt; for &amp;mut T {
    fn borrow(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}

//每一个类型的可变引用都实现了针对自身的BorrowMut
impl&lt;T: ?Sized&gt; BorrowMut&lt;T&gt; for &amp;mut T {
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut T {
        &amp;mut **self
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cell模块类型代码分析"><a class="header" href="#cell模块类型代码分析">Cell模块类型代码分析</a></h2>
<p>代码路径：
%USER%.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\cell.rs</p>
<p>Cell类型提供了内部可变性的功能。对应于以下场景：<br />
一个变量存在多个引用，希望通过这些引用都可以修改此变量。</p>
<p>RUST的可变引用与不可变引用不能同时共存，这导致了无法通过普通的引用语法完成上述场景。<br />
RUST提供的解决方案是<code>Cell&lt;T&gt;</code>封装类型。思路很简单，提供一个封装类型结构，对此类型实现一个set方法来修改内部封装的变量。set方法主要是通过unsafe RUST来实现内部变量修改。<br />
Cell模块类型的层次如下：</p>
<ol>
<li><code>UnsafeCell&lt;T&gt;</code>负责将内部封装的变量导出多个<code>* mut T</code>。其他模块只要基于<code>*mut T</code>生成可变引用，即可修改内部变量。这显然是违反RUST的可变引用的语法的，也是不安全的。</li>
<li><code>Cell&lt;T&gt;</code>基于<code>UnsafeCell&lt;T&gt;</code>导出的<code>*mut T</code>实现了set方法改变内部的T类型变量。只要拥有<code>Cell&lt;T&gt;</code>的引用，即可以用set方法修改<code>Cell&lt;T&gt;</code>内部的变量。显然，直接用<code>Cell&lt;T&gt;</code>引用对变量进行修改会引发修改冲突，安全隐患很大。</li>
<li><code>RefCell&lt;T&gt;</code>基于<code>Cell&lt;T&gt;</code>及<code>UnsafeCell&lt;T&gt;</code>，并实现Borrow Trait 及 BorrowMut Trait，可以实现在生命周期不重合的情况下的多个可变引用，且可变引用与不可变引用不可以同时存在。显然，<code>RefCell&lt;T&gt;</code>是与RUST内存安全理念相契合的内部可变性实现方案。</li>
</ol>
<h3 id="unsafecellt代码分析"><a class="header" href="#unsafecellt代码分析"><code>UnsafeCell&lt;T&gt;</code>代码分析</a></h3>
<p>UnsafeCell是RUST的内部可变结构的最底层基础设施，Cell结构和RefCell结构都是用UnsafeCell来实现内部可变性的。 </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UnsafeCell&lt;T: ?Sized&gt; {
    value: T,
}
impl&lt;T&gt; UnsafeCell&lt;T&gt; {
    //创建封装结构
    pub const fn new(value: T) -&gt; UnsafeCell&lt;T&gt; {
        UnsafeCell { value }
    }

    //解封装
    pub const fn into_inner(self) -&gt; T {
        self.value
    }
}
//对任意T的类型，可以为T.into() 创建UnsafeCell类型变量
impl&lt;T&gt; const From&lt;T&gt; for UnsafeCell&lt;T&gt; {
    fn from(t: T) -&gt; UnsafeCell&lt;T&gt; {
        UnsafeCell::new(t)
    }
}

impl&lt;T: ?Sized&gt; UnsafeCell&lt;T&gt; {
    pub const fn get(&amp;self) -&gt; *mut T {
        // 将裸指针导出，这是为什么起名是UnsafeCell的原因
        // 此裸指针的安全性由调用代码保证,调用代码可以使用此裸指针改变内部封装的变量
        self as *const UnsafeCell&lt;T&gt; as *const T as *mut T
    }

    //给出一个正常的可变引用, 此引用存在期间，get及raw_get调用会编译器告警
    pub const fn get_mut(&amp;mut self) -&gt; &amp;mut T {
        &amp;mut self.value
    }
    
    //参数与get有区别，是关联函数
    pub const fn raw_get(this: *const Self) -&gt; *mut T {
        this as *const T as *mut T
    }
}

//显然，UnsafeCell不支持Sync，即使内部变量支持Sync，这与RUST的默认规则不一致，需要显式声明
impl &lt;T:?Sized&gt; !Sync for UnsafeCell&lt;T&gt; {} 

<span class="boring">}</span></code></pre></pre>
<p>可以看到，UnsafeCell的get函数返回了裸指针，UnsafeCell逃脱RUST对引用安全检查的方法实际上就是个通常的unsafe 的裸指针操作，没有任何神秘性可言。</p>
<h3 id="cellt代码分析"><a class="header" href="#cellt代码分析"><code>Cell&lt;T&gt;</code>代码分析</a></h3>
<p>Cell<T> 内部包装UnsafeCell<T>， 利用UnsafeCell<T>的方法获得裸指针后，用unsafe代码对内部变量进行赋值，从而绕开了RUST语言编译器对引用的约束。Cell<T>的赋值实际上和直接使用裸指针赋值是等同的，但因为提供了方法，没有直接暴露裸指针，所以保证了安全性。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct Cell&lt;T: ?Sized&gt; {
    value: UnsafeCell&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Cell<T>创建方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; const From&lt;T&gt; for Cell&lt;T&gt; {
    fn from(t: T) -&gt; Cell&lt;T&gt; {
        Cell::new(t)
    }
}

impl&lt;T&gt; Cell&lt;T&gt; {
    pub const fn new(value: T) -&gt; Cell&lt;T&gt; {
        Cell { value: UnsafeCell::new(value) }
    }
<span class="boring">}</span></code></pre></pre>
<p><code>Cell&lt;T&gt;</code> 改变内部变量的方法:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>    
<span class="boring">fn main() {
</span>    pub fn set(&amp;self, val: T) {
        //实际调用mem::replace
        let old = self.replace(val);
        //这里不调用drop, old也应该因为生命周期终结被释放。
        //此处调用drop以确保万无一失
        drop(old);
    }

    pub fn swap(&amp;self, other: &amp;Self) {
        //此处注意，ptr::eq不仅仅比较地址，也比较元数据
        if ptr::eq(self, other) {
            return;
        }
        //此段不会出现在跨线程的场景下
        unsafe {
            ptr::swap(self.value.get(), other.value.get());
        }
    }

    //此函数也会将原有的值及所有权返回
    pub fn replace(&amp;self, val: T) -&gt; T {
        // 利用unsafe粗暴将指针转变为可变引用，然后赋值，此处必须用
        // replace，原有值的所有权需要有交代。
        mem::replace(unsafe { &amp;mut *self.value.get() }, val)
    }
<span class="boring">}</span></code></pre></pre>
<p>获取内部值的解封装方法:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub const fn into_inner(self) -&gt; T {
        //解封装
        self.value.into_inner()
    }
}

impl&lt;T: Default&gt; Cell&lt;T&gt; {
    //take后，变量所有权已经转移出来
    pub fn take(&amp;self) -&gt; T {
        self.replace(Default::default())
    }
}

impl&lt;T: Copy&gt; Cell&lt;T&gt; {
    pub fn get(&amp;self) -&gt; T {
        //只适合于Copy Trait类型，否则会导致所有权转移，引发UB
        unsafe { *self.value.get() }
    }
<span class="boring">}</span></code></pre></pre>
<p>对函数式编程支持的方法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //函数式编程，因为T支持Copy，所以没有所有权问题 
    pub fn update&lt;F&gt;(&amp;self, f: F) -&gt; T
    where
        F: FnOnce(T) -&gt; T,
    {
        let old = self.get();
        let new = f(old);
        self.set(new);
        new
    }
}

<span class="boring">}</span></code></pre></pre>
<p>获取内部变量指针的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Cell&lt;T&gt; {
    //通常应该不使用这个机制，安全隐患非常大
    pub const fn as_ptr(&amp;self) -&gt; *mut T {
        self.value.get()
    }
    //获取内部的可变引用，调用这个函数会占用&amp;mut self，
    //需要等到返回值生命周期结束才能释放。
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut T {
        self.value.get_mut()
    }

    pub fn from_mut(t: &amp;mut T) -&gt; &amp;Cell&lt;T&gt; {
        // 利用repr[transparent]直接做转换
        unsafe { &amp;*(t as *mut T as *const Cell&lt;T&gt;) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>切片类型相关方法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Unsized Trait实现
impl&lt;T: CoerceUnsized&lt;U&gt;, U&gt; CoerceUnsized&lt;Cell&lt;U&gt;&gt; for Cell&lt;T&gt; {}

impl&lt;T&gt; Cell&lt;[T]&gt; {
    pub fn as_slice_of_cells(&amp;self) -&gt; &amp;[Cell&lt;T&gt;] {
        // 粗暴的直接转换
        unsafe { &amp;*(self as *const Cell&lt;[T]&gt; as *const [Cell&lt;T&gt;]) }
    }
}

impl&lt;T, const N: usize&gt; Cell&lt;[T; N]&gt; {
    pub fn as_array_of_cells(&amp;self) -&gt; &amp;[Cell&lt;T&gt;; N] {
        // 粗暴的直接转换
        unsafe { &amp;*(self as *const Cell&lt;[T; N]&gt; as *const [Cell&lt;T&gt;; N]) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Cell&lt;T&gt;</code>仅对支持Send的T支持Send trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//按规则，此处代码可以不写，但估计可以减轻编译器负担或编译器有额外要求。
unsafe impl&lt;T: ?Sized&gt; Send for Cell&lt;T&gt; where T: Send {}

//按规则也可以不写，但估计可以减轻编译器负担或编译器有额外要求
unsafe impl&lt;T:?Sized&gt; !Sync for Cell&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<h3 id="refcellt-代码分析"><a class="header" href="#refcellt-代码分析"><code>RefCell&lt;T&gt;</code> 代码分析</a></h3>
<p><code>RefCell&lt;T&gt;</code>设计的思路：</p>
<ol>
<li>基本类型RefCell，负责存储内部可变的变量及计数器</li>
<li>Ref类型, 作为执行borrow()后生成的返回结果，通过解引用可以直接获得内部变量的引用，drop调用时会减少计数器不可变引用计数</li>
<li>RefMut类型, 作为执行borrow_mut()后生成的返回结构，通过解引用可以直接获得内部变量的可变引用，对内部变量进行修改。drop调用时会减少计数器可变引用计数</li>
<li>不采用在Ref及RefMut中包含&amp;RefCell的方式来实现对RefCell内部计数器的操作，这样在逻辑上有些混乱</li>
<li>单独设计BorrowRef作为Ref计数器的借用类型，目的是利用此类型的drop函数完成对RefCell中计数器的不可变借用计数操作</li>
<li>单独设计BorrowRefMut作为RefMut计数器的借用类型，目的是利用此类型的drop函数完成对RefCell中计数器的可变借用计数器操作</li>
</ol>
<p>以下为RefCell<T>类型相关的结构， 删除了一些和debug相关的内容，使代码简化及理解简单</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RefCell&lt;T: ?Sized&gt; {
    //用以标识对外是否有可变引用，是否有不可变引用，有多少个不可变引用
    //是引用计数的实现体
    borrow: Cell&lt;BorrowFlag&gt;,
    //包装内部的变量
    value: UnsafeCell&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>引用计数类型BorrowFlag的定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 正整数表示RefCell执行borrow()调用
// 生成的不可变引用&quot;Ref&quot;的数目
//
// 负整数表示RefCell执行borrow_mut()调用
// 生成的可变引用&quot;RefMut&quot;的数目
//
// 多个RefMut存在的条件是在多个RefMut指向
// 同一个&quot;RefCell&quot;的不同部分的情况，如多个
// RefMut指向一个slice的不重合的部分。
type BorrowFlag = isize;
// 0表示没有执行过borrow()或borrow_mut()调用
const UNUSED: BorrowFlag = 0;

//有borrow_mut()被执行且生命周期没有终结
fn is_writing(x: BorrowFlag) -&gt; bool {
    x &lt; UNUSED
}

//有borrow()被执行且生命周期没有终结
fn is_reading(x: BorrowFlag) -&gt; bool {
    x &gt; UNUSED
}
<span class="boring">}</span></code></pre></pre>
<p><code>RefCell&lt;T&gt;</code>创建方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; RefCell&lt;T&gt; {
    pub const fn new(value: T) -&gt; RefCell&lt;T&gt; {
        RefCell {
            value: UnsafeCell::new(value),
            //初始化一定是UNUSED
            borrow: Cell::new(UNUSED),
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>解封装方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    //实际会消费RefCell，并将内部变量返回，因为Ref及RefMut有PhantomData
    //所以，存在borrow及borrow_mut时，调用此方法会编译出错，没有安全问题。
    pub const fn into_inner(self) -&gt; T {
        self.value.into_inner()
    }
<span class="boring">}</span></code></pre></pre>
<h4 id="borrow相关的结构及代码"><a class="header" href="#borrow相关的结构及代码">borrow()相关的结构及代码</a></h4>
<p><code>RefCell&lt;T&gt;</code>borrow()的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; RefCell&lt;T&gt; {
    //Borrow Trait实现, 返回Ref&lt;`a, T&gt;类型变量，见下面分析
    pub fn borrow(&amp;self) -&gt; Ref&lt;'_, T&gt; {
        //真正是try_borrow()
        self.try_borrow().expect(&quot;already mutably borrowed&quot;)
    }
    //不可变引用 borrow真正实现
    pub fn try_borrow(&amp;self) -&gt; Result&lt;Ref&lt;'_, T&gt;, BorrowError&gt; {
        match BorrowRef::new(&amp;self.borrow) {
            Some(b) =&gt; {
                // 保证了self.borrow一定是is_reading()为真，直接从裸指针
                //转换，对RUST来讲，转换后的引用与原变量没有内存安全的联系。
                // 从这个函数看，RefCell&lt;T&gt;应该尽量使用RefCell的方法操作，除非绝对把握
                // 不要直接将内部变量的正常引用导出，否则安全隐患巨大。
                // 这里返回的Ref变量的生命周期不能长于self，*self.value.get()本身没有生命周期
                // &amp;*self.value.get()加入了生命周期，而这个生命周期受到函数生命周期语法的限制
                // 从而返回值的生命周期小于了self的生命周期。这是RUST生命周期的一个重要规则。不安全
                // 由此进入安全
                Ok(Ref { value: unsafe { &amp;*self.value.get() }, borrow: b })
            }
            None =&gt; Err(BorrowError {
                
            }),
        }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p><code>Ref&lt;'b, T&gt;</code>相关类型结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//RefCell&lt;T&gt; borrow()调用获取的类型
pub struct Ref&lt;'b, T: ?Sized + 'b&gt; {
    //对RefCell&lt;T&gt;中value的引用
    value: &amp;'b T,
    //对RefCell&lt;T&gt;中borrow引用的封装
    borrow: BorrowRef&lt;'b&gt;,
}

//Deref将获得内部value
impl&lt;T: ?Sized&gt; Deref for Ref&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        self.value
    }
}

<span class="boring">}</span></code></pre></pre>
<p>针对不可变借用的计数逻辑实现类型</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//对RefCell&lt;T&gt;中成员变量borrow的引用封装类型
struct BorrowRef&lt;'b&gt; {
    borrow: &amp;'b Cell&lt;BorrowFlag&gt;,
}

impl&lt;'b&gt; BorrowRef&lt;'b&gt; {
    //每次new，代表对RefCell&lt;T&gt;产生了borrow()调用，需增加不可变引用计数
    fn new(borrow: &amp;'b Cell&lt;BorrowFlag&gt;) -&gt; Option&lt;BorrowRef&lt;'b&gt;&gt; {
        // 引用计数加1，
        let b = borrow.get().wrapping_add(1);
        if !is_reading(b) {
            // 1.如果有borrow_mut()调用且生命周期没有终结
            // 2.如果到达isize::MAX
            None
        } else {
            // 增加一个不可变借用计数:
            borrow.set(b);
            Some(BorrowRef { borrow })
        }
    }
}

// Drop，代表对RefCell&lt;T&gt;的borrow()调用的返回变量生命周期结束，需减少不可变引用计数
impl Drop for BorrowRef&lt;'_&gt; {
    fn drop(&amp;mut self) {
        let borrow = self.borrow.get();
        //一定应该是正整数
        debug_assert!(is_reading(borrow));
        //不可变引用计数减一
        self.borrow.set(borrow - 1);
    }
}
impl Clone for BorrowRef&lt;'_&gt; {
    //每次clone实际上增加了一次RefCell&lt;T&gt;的不可变引用，
    fn clone(&amp;self) -&gt; Self {
        //不可变引用计数加1
        let borrow = self.borrow.get();
        debug_assert!(is_reading(borrow));
        assert!(borrow != isize::MAX);
        self.borrow.set(borrow + 1);
        BorrowRef { borrow: self.borrow }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对Ref结构的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'b, T: ?Sized&gt; Ref&lt;'b, T&gt; {
    /// 与再执行RefCell&lt;T&gt;::borrow等价。但用clone可以在不必有RefCell&lt;T&gt;的情况下增加引用
    /// 不选择实现Clone Trait，是因为要用RefCell&lt;T&gt;.borrow().clone()来复制
    /// RefCell&lt;T&gt;
    pub fn clone(orig: &amp;Ref&lt;'b, T&gt;) -&gt; Ref&lt;'b, T&gt; {
        Ref { value: orig.value, borrow: orig.borrow.clone() }
    }

    //通常的情况下，F的返回引用与Ref中的引用是强相关的，即获得返回引用等同于获得Ref中value的引用
    pub fn map&lt;U: ?Sized, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; Ref&lt;'b, U&gt;
    where
        F: FnOnce(&amp;T) -&gt; &amp;U,
    {
        Ref { value: f(orig.value), borrow: orig.borrow }
    }

    //同上，例如value是一个切片引用，filter后获得切片的一部分
    pub fn filter_map&lt;U: ?Sized, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; Result&lt;Ref&lt;'b, U&gt;, Self&gt;
    where
        F: FnOnce(&amp;T) -&gt; Option&lt;&amp;U&gt;,
    {
        match f(orig.value) {
            Some(value) =&gt; Ok(Ref { value, borrow: orig.borrow }),
            None =&gt; Err(orig),
        }
    }

    /// leak调用后，此Ref不再调用drop，从而导致RefCell中的计数器无法恢复原状，也会导致可变引用无法再被创建 
    pub fn leak(orig: Ref&lt;'b, T&gt;) -&gt; &amp;'b T {
        mem::forget(orig.borrow);
        orig.value
    }
}

impl&lt;'b, T: ?Sized + Unsize&lt;U&gt;, U: ?Sized&gt; CoerceUnsized&lt;Ref&lt;'b, U&gt;&gt; for Ref&lt;'b, T&gt; {}
<span class="boring">}</span></code></pre></pre>
<h4 id="borrow_mut-相关结构及代码"><a class="header" href="#borrow_mut-相关结构及代码">borrow_mut() 相关结构及代码</a></h4>
<p><code>RefCell&lt;T&gt;</code>的borrow_mut()代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; RefCell&lt;T&gt; {
    //BorrowMut Trait实现,返回RefMut&lt;`a, T&gt;类型变量
    pub fn borrow_mut(&amp;self) -&gt; RefMut&lt;'_, T&gt; {
        self.try_borrow_mut().expect(&quot;already borrowed&quot;)
    }

    pub fn try_borrow_mut(&amp;self) -&gt; Result&lt;RefMut&lt;'_, T&gt;, BorrowMutError&gt; {
        match BorrowRefMut::new(&amp;self.borrow) {
            Some(b) =&gt; {
                // 一定不存在非可变引用，也仅有本次的可变引用，这个可变引用直接从
                // 裸指针转换，对RUST编译器，转换后的可变引用与原变量没有内存安全的联系。
                Ok(RefMut { value: unsafe { &amp;mut *self.value.get() }, borrow: b })
            }
            None =&gt; Err(BorrowMutError {
                
            }),
        }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>从RefCell<T> borrow_mut返回的结构体<br />
<code>RefMut&lt;'b, T&gt;</code>结构代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RefMut&lt;'b, T: ?Sized + 'b&gt; {
    //可变引用
    value: &amp;'b mut T,
    //计数器
    borrow: BorrowRefMut&lt;'b&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>BorrowRefMut&lt;T&gt;</code>结构及逻辑:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//作用与BorrowRef相同
struct BorrowRefMut&lt;'b&gt; {
    borrow: &amp;'b Cell&lt;BorrowFlag&gt;,
}

//RefMut生命周期终止时调用
impl Drop for BorrowRefMut&lt;'_&gt; {
    fn drop(&amp;mut self) {
        //可变引用计数减一(数学运算为加)
        let borrow = self.borrow.get();
        debug_assert!(is_writing(borrow));
        self.borrow.set(borrow + 1);
    }
}

impl&lt;'b&gt; BorrowRefMut&lt;'b&gt; {
    fn new(borrow: &amp;'b Cell&lt;BorrowFlag&gt;) -&gt; Option&lt;BorrowRefMut&lt;'b&gt;&gt; {
        //初始的borrow_mut，引用计数必须是0，不存在其他可变引用
        match borrow.get() {
            UNUSED =&gt; {
                borrow.set(UNUSED - 1);
                Some(BorrowRefMut { borrow })
            }
            _ =&gt; None,
        }
    }

    // 不通过RefCell获取新的RefMut的方法，对于新的RefMut，
    // 必须是一个整体的可变引用分为几个组成部分的可变引用，
    // 如结构体成员，或数组成员。且可变引用之间互相不重合，
    // 不允许两个可变引用能修改同一块内存
    fn clone(&amp;self) -&gt; BorrowRefMut&lt;'b&gt; {
        //不可变引用计数增加(算数减)
        let borrow = self.borrow.get();
        debug_assert!(is_writing(borrow));
        // Prevent the borrow counter from underflowing.
        assert!(borrow != isize::MIN);
        self.borrow.set(borrow - 1);
        BorrowRefMut { borrow: self.borrow }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RefMut的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Deref后返回内部变量的引用
impl&lt;T: ?Sized&gt; Deref for RefMut&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        self.value
    }
}
//DerefMut返回内部变量可变引用
impl&lt;T: ?Sized&gt; DerefMut for RefMut&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="refcellt-其他方法"><a class="header" href="#refcellt-其他方法"><code>RefCell&lt;T&gt;</code> 其他方法</a></h4>
<p>改变内部值的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; RefCell&lt;T&gt; {
    //将原有内部变量替换为新值，既然是RefCell, 通常应使用borrow_mut
    //获得可变引用，再对值做修改，下面函数实际也是用borrow_mut完成，
    //但更多应该是用在泛型中
    pub fn replace(&amp;self, t: T) -&gt; T {
        mem::replace(&amp;mut *self.borrow_mut(), t)
    }

    //同上，只是用函数获取新值
    pub fn replace_with&lt;F: FnOnce(&amp;mut T) -&gt; T&gt;(&amp;self, f: F) -&gt; T {
        let mut_borrow = &amp;mut *self.borrow_mut();
        let replacement = f(mut_borrow);
        mem::replace(mut_borrow, replacement)
    }

    //两个引用交换值，也交换了值的所有权
    pub fn swap(&amp;self, other: &amp;Self) {
        mem::swap(&amp;mut *self.borrow_mut(), &amp;mut *other.borrow_mut())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>直接获取内部变量指针：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //此函数如果没有绝对的安全把握，不要用
    pub fn as_ptr(&amp;self) -&gt; *mut T {
        self.value.get()
    }

    //此函数如果没有绝对的安全把握，不要用
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut T {
        self.value.get_mut()
    }
<span class="boring">}</span></code></pre></pre>
<p>其他方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //在leak操作后，做leak的逆操作，实际上对计数器进行了恢复，
    pub fn undo_leak(&amp;mut self) -&gt; &amp;mut T {
        *self.borrow.get_mut() = UNUSED;
        self.get_mut()
    }

    //规避计数器计数的方法，与borrow操作近似
    pub unsafe fn try_borrow_unguarded(&amp;self) -&gt; Result&lt;&amp;T, BorrowError&gt; {
        //如果没有borrow_mut(),则返回引用
        if !is_writing(self.borrow.get()) {
            Ok(unsafe { &amp;*self.value.get() })
        } else {
            Err(BorrowError {
            })
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>内部值获取方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Default&gt; RefCell&lt;T&gt; {
    //对RefCell&lt;T&gt;应该不使用这个函数，尤其是在有borrow()/borrow_mut()
    //且生命周期没有终结时
    pub fn take(&amp;self) -&gt; T {
        self.replace(Default::default())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>系统编译器内嵌trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//支持线程间转移
unsafe impl&lt;T: ?Sized&gt; Send for RefCell&lt;T&gt; where T: Send {}
//不支持线程间共享
impl&lt;T: ?Sized&gt; !Sync for RefCell&lt;T&gt; {}

impl&lt;T: Clone&gt; Clone for RefCell&lt;T&gt; {
    //clone实际上仅仅是增加计数
    fn clone(&amp;self) -&gt; RefCell&lt;T&gt; {
        //self.borrow().clone 实质是((*self.borrow()).clone)
        //连续解引用后做clone的调用
        //Ref&lt;T&gt;不支持Clone，所以解引用的到&amp;T        
        RefCell::new(self.borrow().clone())
    }

    fn clone_from(&amp;mut self, other: &amp;Self) {
        //self.get_mut().clone_from 实质是
        // (*self.get_mut()).clone_from()
        // &amp;mut T不支持Clone，所以解引用到T
        self.get_mut().clone_from(&amp;other.borrow())
    }
}

impl&lt;T: Default&gt; Default for RefCell&lt;T&gt; {
    fn default() -&gt; RefCell&lt;T&gt; {
        RefCell::new(Default::default())
    }
}

impl&lt;T: ?Sized + PartialEq&gt; PartialEq for RefCell&lt;T&gt; {
    fn eq(&amp;self, other: &amp;RefCell&lt;T&gt;) -&gt; bool {
        *self.borrow() == *other.borrow()
    }
}

impl&lt;T&gt; const From&lt;T&gt; for RefCell&lt;T&gt; {
    fn from(t: T) -&gt; RefCell&lt;T&gt; {
        RefCell::new(t)
    }
}

impl&lt;T: CoerceUnsized&lt;U&gt;, U&gt; CoerceUnsized&lt;RefCell&lt;U&gt;&gt; for RefCell&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>RefCell<T>的代码实现，是理解RUST解决问题的思维的好例子。 编程中，RefCell的计数器是针对RUST语法的一个精巧的设计，利用drop的自动调用，编程只需要关注new，这就节省了程序员极大的精力，也规避了错误的发生。borrow_mut()机制则解决了多个可修改借用。
利用RUST的非安全个性和自动drop的机制，可以自行设计出RefCell<T>这样的标准库解决方案，而不是借助于编译器。这是RUST的一个突出特点，也是其能与C一样成为系统级语言的原因。</p>
<h2 id="pin及unpin"><a class="header" href="#pin及unpin">Pin及UnPin</a></h2>
<p>Pin<T>主要解决需要程序员在编程时要时刻注意处理可能的变量地址改变的情况。利用Pin<T>，程序员只需要在初始的时候注意到这个场景并定义好。后继就可以不必再关心。
Pin是一个对指针&amp;mut T的包装结构，包装后因为&amp;mut T的独占性。封装结构外，不可能再存在变量的引用及不可变引用。所有的引用都只能使用Pin<T>来完成，导致RUST的需要引用的一些内存操作无法进行，如实质上是指针交换的调用mem::swap，从而保证了指针指向的变量在代码中会被固定在某个内存位置。当然，编译器也不会再做优化。</p>
<p>实现Unpin Trait的类型不受Pin的约束，RUST中实现Copy trait的类型基本上都实现了Unpin Trait。
结构定义</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
#[derive(Copy, Clone)]
pub struct Pin&lt;P&gt; {
    pointer: P,
}
<span class="boring">}</span></code></pre></pre>
<p>Pin变量创建：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; {
    // 支持Unpin类型可以用new创建Pin&lt;T&gt;
    pub const fn new(pointer: P) -&gt; Pin&lt;P&gt; {
        unsafe { Pin::new_unchecked(pointer) }
    }
    ...
}

impl&lt;P: Deref&gt; Pin&lt;P&gt; {
    //实现Deref的类型，用下面的行为创建Pin&lt;T&gt;, 调用者应该保证P可以被Pin，
    pub const unsafe fn new_unchecked(pointer: P) -&gt; Pin&lt;P&gt; {
        Pin { pointer }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Pin自身的new方法仅针对Pin实际上不起作用的Unpin类型。对于其他不支持Unpin的类型，通常使用智能指针提供的Pin创建方法，如Boxed::pin。
new_unchecked则提供给其他智能指针的安全的创建方法内部使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; {
    ...
    /// 解封装，取消内存pin操作
    pub const fn into_inner(pin: Pin&lt;P&gt;) -&gt; P {
        pin.pointer
    }
}

impl &lt;P:Deref&gt; Pin&lt;P&gt; {
    ...
    
    //对应于new_unchecked
    pub const unsafe fn into_inner_unchecked(pin: Pin&lt;P&gt;) -&gt; P {
        pin.pointer
    }
}
<span class="boring">}</span></code></pre></pre>
<p>指针转换</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;P: Deref&gt; Pin&lt;P&gt; {
    ...
    /// 需要返回一个Pin的引用，以为P自身就是指针，返回P是
    /// 不合理及不安全的，所以此函数被用来返回Pin住的解引
    /// 用的指针类型
    pub fn as_ref(&amp;self) -&gt; Pin&lt;&amp;P::Target&gt; {
        // SAFETY: see documentation on this function
        unsafe { Pin::new_unchecked(&amp;*self.pointer) }
    }
}
impl &lt;P:DerefMut&gt; Pin&lt;P&gt; { 
    ...  
    /// 需要返回一个Pin的可变引用，以为P自身就是指针，
    /// 所以此函数被用来返回Pin住的解引用的指针类型
    pub fn as_mut(&amp;mut self) -&gt; Pin&lt;&amp;mut P::Target&gt; {
        unsafe { Pin::new_unchecked(&amp;mut *self.pointer) }
    }
}
impl &lt;'a, T:?Sized&gt; Pin&lt;&amp;'a T&gt; {
    //&amp;T 不会导致在安全RUST领域的类如mem::replace之类的地址改变操作
    pub const fn get_ref(self) -&gt; &amp;'a T {
        self.pointer
    }
}

impl&lt;'a, T: ?Sized&gt; Pin&lt;&amp;'a mut T&gt; {
    //不可变引用可以随意返回，不会影响Pin的语义
    pub const fn into_ref(self) -&gt; Pin&lt;&amp;'a T&gt; {
        Pin { pointer: self.pointer }
    }

    //Unpin的可变引用可以返回，Pin对Unpin类型无作用
    pub const fn get_mut(self) -&gt; &amp;'a mut T
    where
        T: Unpin,
    {
        self.pointer
    }

    //后门，要确定安全，会导致Pin失效
    pub const unsafe fn get_unchecked_mut(self) -&gt; &amp;'a mut T {
        self.pointer
    }
    ...
}

impl&lt;T: ?Sized&gt; Pin&lt;&amp;'static T&gt; {
    pub const fn static_ref(r: &amp;'static T) -&gt; Pin&lt;&amp;'static T&gt; {
        unsafe { Pin::new_unchecked(r) }
    }
}

impl&lt;'a, P: DerefMut&gt; Pin&lt;&amp;'a mut Pin&lt;P&gt;&gt; {
    pub fn as_deref_mut(self) -&gt; Pin&lt;&amp;'a mut P::Target&gt; {
        unsafe { self.get_unchecked_mut() }.as_mut()
    }
}

impl&lt;T: ?Sized&gt; Pin&lt;&amp;'static mut T&gt; {
    pub const fn static_mut(r: &amp;'static mut T) -&gt; Pin&lt;&amp;'static mut T&gt; {
        // SAFETY: The 'static borrow guarantees the data will not be
        // moved/invalidated until it gets dropped (which is never).
        unsafe { Pin::new_unchecked(r) }
    }
}

impl&lt;P: Deref&gt; Deref for Pin&lt;P&gt; {
    type Target = P::Target;
    fn deref(&amp;self) -&gt; &amp;P::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}
//只有Unpin才支持对mut的DerefMut trait，不支持Unpin的，
//不能用DerefMut，以保证Pin
impl&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; DerefMut for Pin&lt;P&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}

<span class="boring">}</span></code></pre></pre>
<p>内部可变性函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;P:DerefMut&gt; Pin&lt;P&gt; {
    //修改值，实质也提供了内部可变性
    pub fn set(&amp;mut self, value: P::Target)
    where
        P::Target: Sized,
    {
        *(self.pointer) = value;
    }
}

impl&lt;'a, T: ?Sized&gt; Pin&lt;&amp;'a T&gt; {
    //函数式编程，func返回的pointer与self.pointer应该强相关，如结构中
    //某一变量的引用，或slice中某一元素的引用
    pub unsafe fn map_unchecked&lt;U, F&gt;(self, func: F) -&gt; Pin&lt;&amp;'a U&gt;
    where
        U: ?Sized,
        F: FnOnce(&amp;T) -&gt; &amp;U,
    {
        let pointer = &amp;*self.pointer;
        let new_pointer = func(pointer);

        // SAFETY: the safety contract for `new_unchecked` must be
        // upheld by the caller.
        unsafe { Pin::new_unchecked(new_pointer) }
    }

}

impl&lt;'a, T: ?Sized&gt; Pin&lt;&amp;'a mut T&gt; {
    
    pub unsafe fn map_unchecked_mut&lt;U, F&gt;(self, func: F) -&gt; Pin&lt;&amp;'a mut U&gt;
    where
        U: ?Sized,
        F: FnOnce(&amp;mut T) -&gt; &amp;mut U,
    {
        // 这个可能导致Pin住的内容移动，调用者要保证不出问题
        let pointer = unsafe { Pin::get_unchecked_mut(self) };
        let new_pointer = func(pointer);
        unsafe { Pin::new_unchecked(new_pointer) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>利用Pin的封装及基于trait约束的方法实现，使得指针pin在内存中的需求得以实现。是RUST利用封装语义完成语言需求的又一经典案例</p>
<h2 id="lazy分析"><a class="header" href="#lazy分析">Lazy<T>分析</a></h2>
<p>OnceCell是一种内部可变的类型，其用于初始化没有初始值，仅支持赋值一次的类型。
Once一般用于支持全局静态变量。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OnceCell&lt;T&gt; {
    // Option&lt;T&gt;支持None作为初始化的值
    inner: UnsafeCell&lt;Option&lt;T&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>OnceCell封装UnsafeCell以支持内部可变性。
创建方法:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; const From&lt;T&gt; for OnceCell&lt;T&gt; {
    fn from(value: T) -&gt; Self {
        OnceCell { inner: UnsafeCell::new(Some(value)) }
    }
}
impl&lt;T&gt; OnceCell&lt;T&gt; {
    /// 初始化为空，支持静态全局变量初始化
    pub const fn new() -&gt; OnceCell&lt;T&gt; {
        //注意，此时给UnsafeCell分配T类型的地址空间
        OnceCell { inner: UnsafeCell::new(None) }
    }
<span class="boring">}</span></code></pre></pre>
<p>获取内部引用</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn get(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        // 生成一个内部变量的引用，
        unsafe { &amp;*self.inner.get() }.as_ref()
    }

    /// 直接用返回结果取可以&amp;mut T，然后再解封装后用可变引用即
    /// 可改变内部封装变量的值，会突破只赋值一次的既定语义，
    /// 此函数最好不使用
    pub fn get_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe { &amp;mut *self.inner.get() }.as_mut()
    }
<span class="boring">}</span></code></pre></pre>
<p>对内部值进行修改方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// 通过此函数仅能给OnceCell内部变量做一次赋值
    pub fn set(&amp;self, value: T) -&gt; Result&lt;(), T&gt; {
        // SAFETY: Safe because we cannot have overlapping mutable borrows
        let slot = unsafe { &amp;*self.inner.get() };
        if slot.is_some() {
            return Err(value);
        }

        let slot = unsafe { &amp;mut *self.inner.get() };
        *slot = Some(value);
        Ok(())
    }

    //见下面函数
    pub fn get_or_init&lt;F&gt;(&amp;self, f: F) -&gt; &amp;T
    where
        F: FnOnce() -&gt; T,
    {
        //Ok::&lt;T,!&gt;(f()) 即Result类型初始化，例如Ok::&lt;i32,!&gt;(3)
        match self.get_or_try_init(|| Ok::&lt;T, !&gt;(f())) {
            Ok(val) =&gt; val,
        }
    }

    //有值就返回值，没有值用f生成值
    pub fn get_or_try_init&lt;F, E&gt;(&amp;self, f: F) -&gt; Result&lt;&amp;T, E&gt;
    where
        F: FnOnce() -&gt; Result&lt;T, E&gt;,
    {
        if let Some(val) = self.get() {
            return Ok(val);
        }
        /// 下面代码关键是cold, 防止优化后的代码出现意外，因为此函数会被多次调用
        /// 这是一个较冷门的知识点
        #[cold]
        fn outlined_call&lt;F, T, E&gt;(f: F) -&gt; Result&lt;T, E&gt;
        where
            F: FnOnce() -&gt; Result&lt;T, E&gt;,
        {
            f()
        }
        let val = outlined_call(f)?;
        assert!(self.set(val).is_ok(), &quot;reentrant init&quot;);
        Ok(self.get().unwrap())
    }
<span class="boring">}</span></code></pre></pre>
<p>解封装方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //消费了OnceCell,并且返回内部变量
    pub fn into_inner(self) -&gt; Option&lt;T&gt; {
        self.inner.into_inner()
    }

    //替换OnceCell，并将替换的OnceCell消费掉，并且返回内部变量
    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt; {
        mem::take(self).into_inner()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>OnceCell<T>对trait的实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Default for OnceCell&lt;T&gt; {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl&lt;T: Clone&gt; Clone for OnceCell&lt;T&gt; {
    fn clone(&amp;self) -&gt; OnceCell&lt;T&gt; {
        let res = OnceCell::new();
        if let Some(value) = self.get() {
            match res.set(value.clone()) {
                Ok(()) =&gt; (),
                Err(_) =&gt; unreachable!(),
            }
        }
        res
    }
}

impl&lt;T: PartialEq&gt; PartialEq for OnceCell&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.get() == other.get()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>基于OnceCell<T>实现惰性结构Lazy<T>,惰性结构在第一次调用解引用的时候被赋值，随后使用这个值。
此结构强迫代码区分初始化必须有值及不必赋值的情况。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 惰性类型，在第一次使用时进行赋值和初始化
pub struct Lazy&lt;T, F = fn() -&gt; T&gt; {
    //初始化可以为空
    cell: OnceCell&lt;T&gt;,
    //对cell做初始化赋值的函数
    init: Cell&lt;Option&lt;F&gt;&gt;,
}

impl&lt;T, F&gt; Lazy&lt;T, F&gt; {
    /// 函数作为变量被保存
    pub const fn new(init: F) -&gt; Lazy&lt;T, F&gt; {
        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }
    }
}

impl&lt;T, F: FnOnce() -&gt; T&gt; Lazy&lt;T, F&gt; {
    //完成赋值操作
    pub fn force(this: &amp;Lazy&lt;T, F&gt;) -&gt; &amp;T {
        //如果cell为空，则用init作初始化赋值，注意这里init的take调用已经将init替换成None，
        this.cell.get_or_init(|| match this.init.take() {
            Some(f) =&gt; f(),
            None =&gt; panic!(&quot;`Lazy` instance has previously been poisoned&quot;),
        })
    }
}

//在对Lazy解引用时才进行赋值操作
impl&lt;T, F: FnOnce() -&gt; T&gt; Deref for Lazy&lt;T, F&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        Lazy::force(self)
    }
}

impl&lt;T: Default&gt; Default for Lazy&lt;T&gt; {
    /// Creates a new lazy value using `Default` as the initializing function.
    fn default() -&gt; Lazy&lt;T&gt; {
        Lazy::new(T::default)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="小结-7"><a class="header" href="#小结-7">小结</a></h2>
<p>从内部可变类型，以及前面的NonNull<T>, Unique<T>, NonZeroSize<T>,都是典型的由不安全类型到安全类型的实现例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<h2 id="box代码分析"><a class="header" href="#box代码分析">Box<T>代码分析</a></h2>
<p>除了数组外的智能指针的堆内存申请，一般都先由Box<T>来完成，然后再将申请到的内存转移到智能指针自身的结构中。</p>
<p>以下为Box<T>结构定义及创建方法相关内容：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Box结构
pub struct Box&lt;
    T: ?Sized,
    //默认的堆内存申请为Global单元结构体，可修改为其他
    A: Allocator = Global,
  //用Unique&lt;T&gt;表示对申请的堆内存拥有所有权  
&gt;(Unique&lt;T&gt;, A);
<span class="boring">}</span></code></pre></pre>
<p>Box<T>的创建方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//以Global作为默认的堆内存分配器的实现
impl&lt;T&gt; Box&lt;T&gt; {
    pub fn new(x: T) -&gt; Self {
        //box 是关键字，就是实现从堆内存申请内存，写入内容然后形成Box&lt;T&gt;
        //这个关键字的功能可以从后继的方法中分析出来, 此方法实际等同与new_in(x, Global);
        box x
    }
    ...
}

//不限定堆内存分配器的更加通用的方法实现
impl&lt;T, A: Allocator&gt; Box&lt;T, A&gt; {

    //Box::new(x) 实际上的逻辑等同与 Box::new_in(x, Global)
    pub fn new_in(x: T, alloc: A) -&gt; Self {
        //new_uninit_in见后面代码分析
        let mut boxed = Self::new_uninit_in(alloc);
        unsafe {
            //实际是MaybeUninit&lt;T&gt;::as_mut_ptr()得到*mut T，::write将x写入申请的堆内存中
            boxed.as_mut_ptr().write(x);
            //从Box&lt;MaybeUninit&lt;T&gt;,A&gt;转换为Box&lt;T,A&gt;
            boxed.assume_init()
        }
    }

    //内存部分章节有过分析
    pub fn new_uninit_in(alloc: A) -&gt; Box&lt;mem::MaybeUninit&lt;T&gt;, A&gt; {
        //获取Layout以便申请堆内存
        let layout = Layout::new::&lt;mem::MaybeUninit&lt;T&gt;&gt;();
        //见后面的代码分析
        match Box::try_new_uninit_in(alloc) {
            Ok(m) =&gt; m,
            Err(_) =&gt; handle_alloc_error(layout),
        }
    }

    //内存申请的真正执行函数
    pub fn try_new_uninit_in(alloc: A) -&gt; Result&lt;Box&lt;mem::MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt; {
        //申请内存需要的内存Layout
        let layout = Layout::new::&lt;mem::MaybeUninit&lt;T&gt;&gt;();
        //申请内存并完成错误处理，cast将NonNull&lt;[u8]&gt;转换为NonNull&lt;MaybeUninit&lt;T&gt;&gt;
        //NonNull&lt;MaybeUninit&lt;T&gt;&gt;.as_ptr为 *mut &lt;MaybeUninit&lt;T&gt;&gt;
        //后继Box的drop会释放此处的内存
        //from_raw_in即将ptr转换为Unique&lt;T&gt;并形成Box结构变量
        let ptr = alloc.allocate(layout)?.cast();
        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
    }

    ...
}

impl&lt;T, A: Allocator&gt; Box&lt;mem::MaybeUninit&lt;T&gt;, A&gt; {
    //申请的未初始化内存，初始化后，应该调用这个函数将
    //Box&lt;MaybeUninit&lt;T&gt;&gt;转换为Box&lt;T&gt;，
    pub unsafe fn assume_init(self) -&gt; Box&lt;T, A&gt; {
        //因为类型不匹配，且无法强制转换，所以先将self消费掉并获得
        //堆内存的裸指针，再用裸指针生成新的Box，完成类型转换V
        let (raw, alloc) = Box::into_raw_with_allocator(self);
        unsafe { Box::from_raw_in(raw as *mut T, alloc) }
    }
}
impl&lt;T: ?Sized, A: Allocator&gt; Box&lt;T, A&gt; {
    //从裸指针构建Box类型，裸指针应该是申请堆内存返回的指针
    //用这个方法生成Box，当Box被drop时，会引发对裸指针的释放操作
    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -&gt; Self {
        //由裸指针生成Unique，再生成Box
        Box(unsafe { Unique::new_unchecked(raw) }, alloc)
    }
    
    //此函数会将传入的b:Box消费掉，并将内部的Unique也消费掉，
    //返回裸指针，此时裸指针指向的内存已经不会再被drop.
    pub fn into_raw_with_allocator(b: Self) -&gt; (*mut T, A) {
        let (leaked, alloc) = Box::into_unique(b);
        (leaked.as_ptr(), alloc)
    }
    pub fn into_unique(b: Self) -&gt; (Unique&lt;T&gt;, A) {
        //对b的alloc做了一份拷贝
        let alloc = unsafe { ptr::read(&amp;b.1) };
        //Box::leak(b)返回&amp;mut T可变引用，具体分析见下文
        //leak(b)生成的&amp;mut T实质上已经不会有Drop调用释放
        (Unique::from(Box::leak(b)), alloc)
    }

    //将b消费掉，并将b内的变量取出来返回
    pub fn leak&lt;'a&gt;(b: Self) -&gt; &amp;'a mut T
    where
        A: 'a,
    {
        //生成ManuallyDrop&lt;Box&lt;T&gt;&gt;, 消费掉了b，此时不会再对b做Drop调用，导致了一个内存leak
        //ManuallyDrop&lt;Box&lt;T&gt;&gt;.0 是Box&lt;T&gt;，ManuallyDrop&lt;T&gt;没有.0的语法，因此会先做解引用，是&amp;Box&lt;T&gt;
        //&amp;Box&lt;T&gt;.0即Unique&lt;T&gt;，Unique&lt;T&gt;.as_ptr获得裸指针，然后利用unsafe代码生成可变引用
        unsafe { &amp;mut *mem::ManuallyDrop::new(b).0.as_ptr() }
    }
    ...
}

unsafe impl&lt; T: ?Sized, A: Allocator&gt; Drop for Box&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        // FIXME: Do nothing, drop is currently performed by compiler.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上是Box的最常用的创建方法的代码。对于所有的堆申请，申请后的内存变量类型是MaybeUninit<T>，然后对MaybeUninit<T>用ptr::write完成初始化，随后再assume_init进入正常变量状态，这是rust的基本套路。</p>
<p>Box<T>的Pin方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Box&lt;T&gt; {
    //如果T没有实现Unpin Trait, 则内存不会移动
    pub fn pin(x: T) -&gt; Pin&lt;Box&lt;T&gt;&gt; {
        //任意的指针可以Into到Pin,因为Pin实现了任意类型的可变引用的From trait
        (box x).into()
    }
    ...
}
impl&lt;T:?Sized&gt; Box&lt;T&gt; {}
    pub fn into_pin(boxed: Self) -&gt; Pin&lt;Self&gt;
    where
        A: 'static,
    {
        unsafe { Pin::new_unchecked(boxed) }
    }
    ...
}
//不限定堆内存分配器的更加通用的方法实现
impl&lt;T, A: Allocator&gt; Box&lt;T, A&gt; {
    //生成Box&lt;T&gt;后，在用Into&lt;Pin&gt; Trait生成Pin&lt;Box&gt;
    pub fn pin_in(x: T, alloc: A) -&gt; Pin&lt;Self&gt;
    where
        A: 'static,
    {
        Self::new_in(x, alloc).into()
    }

    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Box&lt;[T]&gt;的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T,A:Allocator&gt; Box&lt;T, A&gt; {
    //切片
    pub fn into_boxed_slice(boxed: Self) -&gt; Box&lt;[T], A&gt; {
        //要转换指针类型，需要先得到裸指针
        let (raw, alloc) = Box::into_raw_with_allocator(boxed);
        //将裸指针转换为切片裸指针，再生成Box, 此处因为不知道长度，
        //只能转换成长度为1的切片指针
        unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }
    }
    ...
}

impl&lt;T, A: Allocator&gt; Box&lt;[T], A&gt; {
    //使用RawVec作为底层堆内存管理结构，并转换为Box
    pub fn new_uninit_slice_in(len: usize, alloc: A) -&gt; Box&lt;[mem::MaybeUninit&lt;T&gt;], A&gt; {
        unsafe { RawVec::with_capacity_in(len, alloc).into_box(len) }
    }

    //内存清零
    pub fn new_zeroed_slice_in(len: usize, alloc: A) -&gt; Box&lt;[mem::MaybeUninit&lt;T&gt;], A&gt; {
        unsafe { RawVec::with_capacity_zeroed_in(len, alloc).into_box(len) }
    }
}
impl&lt;T, A: Allocator&gt; Box&lt;[mem::MaybeUninit&lt;T&gt;], A&gt; {
    //初始化完毕， 
    pub unsafe fn assume_init(self) -&gt; Box&lt;[T], A&gt; {
        let (raw, alloc) = Box::into_raw_with_allocator(self);
        unsafe { Box::from_raw_in(raw as *mut [T], alloc) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>其他方法及trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Default&gt; Default for Box&lt;T&gt; {
    /// Creates a `Box&lt;T&gt;`, with the `Default` value for T.
    fn default() -&gt; Self {
        box T::default()
    }
}

impl&lt;T,A:Allocator&gt; Box&lt;T, A&gt; {
    //消费掉Box，获取内部变量
    pub fn into_inner(boxed: Self) -&gt; T {
        //对Box的*操作就是完成Box接口从堆内存到栈内存拷贝
        //然后调用Box的drop, 返回栈内存。编译器内置的操作
        *boxed
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>以上即为Box<T>创建及析构的所有相关代码，其中较难理解的是leak方法。在RUST中，惯例对内存申请一般会使用Box<T>来实现，如果需要将申请的内存以另外的智能指针结构做封装，则调用Box::leak将堆指针传递出来</p>
<h2 id="rawvec代码分析"><a class="header" href="#rawvec代码分析">RawVec<T>代码分析</a></h2>
<p>RawVec<T>用于指向一块从堆内存申请出来的某一类型数据的数组buffer，可以未初始化或初始化为零。与数组有关的智能指针底层的内存申请基本上都采用了RawVec<T>
RawVec<T>的结构体，创建及Drop相关方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum AllocInit {
    /// 内存块没有初始化
    Uninitialized,
    /// 内存块被初始化为0
    Zeroed,
}
pub(crate) struct RawVec&lt;T, A: Allocator = Global&gt; {
    //指向堆内存地址
    ptr: Unique&lt;T&gt;,
    //内存块中含有T类型变量的数目
    cap: usize,
    //Allocator 变量
    alloc: A,
}

impl&lt;T&gt; RawVec&lt;T, Global&gt; {
    //语法上的要求，一些const fn 只能调用const fn，所以这里设定了一个const 变量
    pub const NEW: Self = Self::new();

    // 一些创建方法，但仅仅是对其他函数调用，代码略
    pub const fn new() -&gt; Self;
    pub fn with_capacity(capacity: usize) -&gt; Self;
    pub fn with_capacity_zeroed(capacity: usize) -&gt; Self;
}

impl&lt;T, A: Allocator&gt; RawVec&lt;T, A&gt; {
    // 最少申请的容量大小
    const MIN_NON_ZERO_CAP: usize = if mem::size_of::&lt;T&gt;() == 1 {
        8
    } else if mem::size_of::&lt;T&gt;() &lt;= 1024 {
        4
    } else {
        1
    };

    //设置一个内存块大小为0的变量
    pub const fn new_in(alloc: A) -&gt; Self {
        // `cap: 0` means &quot;unallocated&quot;. zero-sized types are ignored.
        Self { ptr: Unique::dangling(), cap: 0, alloc }
    }

    //申请给定容量的内存块，内存块未初始化
    pub fn with_capacity_in(capacity: usize, alloc: A) -&gt; Self {
        //见后继说明
        Self::allocate_in(capacity, AllocInit::Uninitialized, alloc)
    }

    //申请给定容量的内存块，内存块初始化为全零
    pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -&gt; Self {
        Self::allocate_in(capacity, AllocInit::Zeroed, alloc)
    }

    //堆内存申请函数
    fn allocate_in(capacity: usize, init: AllocInit, alloc: A) -&gt; Self {
        //ZST的类型不用申请
        if mem::size_of::&lt;T&gt;() == 0 {
            Self::new_in(alloc)
        } else {
            //获取T类型的layout,注意是用array类型来获取整个size
            let layout = match Layout::array::&lt;T&gt;(capacity) {
                Ok(layout) =&gt; layout,
                Err(_) =&gt; capacity_overflow(),
            };
            //看堆内存是否有足够的空间
            match alloc_guard(layout.size()) {
                Ok(_) =&gt; {}
                Err(_) =&gt; capacity_overflow(),
            }
            //申请内存返回是NonNull&lt;[u8]&gt;，NonNull&lt;[u8]&gt;包含了长度信息
            let result = match init {
                AllocInit::Uninitialized =&gt; alloc.allocate(layout),
                AllocInit::Zeroed =&gt; alloc.allocate_zeroed(layout),
            };
            //处理可能的错误
            let ptr = match result {
                Ok(ptr) =&gt; ptr,
                Err(_) =&gt; handle_alloc_error(layout),
            };

            Self {
                //直接将NonNull&lt;[u8]&gt;转化为NonNull&lt;T&gt;,再转换为 *mut T
                //再生成Unique&lt;T&gt;, 注意*mut T此时没有长度信息
                ptr: unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) },
                //用申请的字节数，ptr不要和上面一行的ptr搞混掉。
                //NonNull&lt;[u8]&gt;附带有长度信息
                cap: Self::capacity_from_bytes(ptr.len()),
                alloc,
            }
        }
    }

    //由元数据直接生成，调用代码需要保证输入参数是正确的
    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, alloc: A) -&gt; Self {
        Self { ptr: unsafe { Unique::new_unchecked(ptr) }, cap: capacity, alloc }
    }

    //返回与allocator申请到的一致的内存变量
    fn current_memory(&amp;self) -&gt; Option&lt;(NonNull&lt;u8&gt;, Layout)&gt; {
        if mem::size_of::&lt;T&gt;() == 0 || self.cap == 0 {
            None
        } else {
            // We have an allocated chunk of memory, so we can bypass runtime
            // checks to get our current layout.
            unsafe {
                let align = mem::align_of::&lt;T&gt;();
                let size = mem::size_of::&lt;T&gt;() * self.cap;
                let layout = Layout::from_size_align_unchecked(size, align);
                Some((self.ptr.cast().into(), layout))
            }
        }
    }
    ...
}
//may_dangle指明T中在释放的时候有可能会出现悬垂指针，但保证不会对悬垂指针做访问，编译器可以放宽strictly alive的规则，
//PhantomData&lt;T&gt;会针对T类型取消掉may_dangle的作用
unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for RawVec&lt;T, A&gt; {
    /// .
    fn drop(&amp;mut self) {
        if let Some((ptr, layout)) = self.current_memory() {
            //释放内存
            unsafe { self.alloc.deallocate(ptr, layout) }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RawVec转换为Box&lt;[T],A&gt;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, A: Allocator&gt; RawVec&lt;T, A&gt; {
    //将内存块中0到len-1之间的内存块，转换为Box&lt;[MaybeUninit&lt;T&gt;]&gt;类型，len应该小于self.capacity,
    //由调用者保证
    pub unsafe fn into_box(self, len: usize) -&gt; Box&lt;[MaybeUninit&lt;T&gt;], A&gt; {
        debug_assert!(
            len &lt;= self.capacity(),
            &quot;`len` must be smaller than or equal to `self.capacity()`&quot;
        );
        
        //RUST不再对self做drop调用
        let me = ManuallyDrop::new(self);
        unsafe {
            //me作为解引用，获取ptr, 然后直接将裸指针强制转换为MaybeUninit&lt;T&gt;，
            //生成slice的可变引用
            let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit&lt;T&gt;, len);
            //用Box::from_raw_in生成Box&lt;[MaybeUninit&lt;T&gt;]&gt;, 注意这里需要对me.alloc做个拷贝
            //因为me已经被forget，所以不能再用原先的alloc.
            Box::from_raw_in(slice, ptr::read(&amp;me.alloc))
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>RawVec<T>内部成员获取方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn ptr(&amp;self) -&gt; *mut T {
        self.ptr.as_ptr()
    }

    pub fn capacity(&amp;self) -&gt; usize {
        if mem::size_of::&lt;T&gt;() == 0 { usize::MAX } else { self.cap }
    }

    pub fn allocator(&amp;self) -&gt; &amp;A {
        &amp;self.alloc
    }
<span class="boring">}</span></code></pre></pre>
<p>RawVec内存空间预留，扩充，收缩相关方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>    //保留空间，确保申请的内存大小满足输入参数的规定，否则的话，扩充内存
    pub fn reserve(&amp;mut self, len: usize, additional: usize) {
        #[cold]
        fn do_reserve_and_handle&lt;T, A: Allocator&gt;(
            slf: &amp;mut RawVec&lt;T, A&gt;,
            len: usize,
            additional: usize,
        ) {
            handle_reserve(slf.grow_amortized(len, additional));
        }

        if self.needs_to_grow(len, additional) {
            do_reserve_and_handle(self, len, additional);
        }
    }

    /// The same as `reserve`, but returns on errors instead of panicking or aborting.
    pub fn try_reserve(&amp;mut self, len: usize, additional: usize) -&gt; Result&lt;(), TryReserveError&gt; {
        if self.needs_to_grow(len, additional) {
            self.grow_amortized(len, additional)
        } else {
            Ok(())
        }
    }

    pub fn reserve_exact(&amp;mut self, len: usize, additional: usize) {
        handle_reserve(self.try_reserve_exact(len, additional));
    }

    pub fn try_reserve_exact(
        &amp;mut self,
        len: usize,
        additional: usize,
    ) -&gt; Result&lt;(), TryReserveError&gt; {
        if self.needs_to_grow(len, additional) { self.grow_exact(len, additional) } else { Ok(()) }
    }

    //收缩空间置给定大小
    pub fn shrink_to_fit(&amp;mut self, amount: usize) {
        handle_reserve(self.shrink(amount));
    }
}

impl&lt;T, A: Allocator&gt; RawVec&lt;T, A&gt; {
    //判断内存块空间是否足够
    fn needs_to_grow(&amp;self, len: usize, additional: usize) -&gt; bool {
        //wrapping_sub防止溢出
        additional &gt; self.capacity().wrapping_sub(len)
    }
    
    //从字节数得出内存块数目
    fn capacity_from_bytes(excess: usize) -&gt; usize {
        debug_assert_ne!(mem::size_of::&lt;T&gt;(), 0);
        excess / mem::size_of::&lt;T&gt;()
    }
    
    //根据NonNull来设置结构体ptr及容量
    fn set_ptr(&amp;mut self, ptr: NonNull&lt;[u8]&gt;) {
        //ptr.cast会转换NonNull&lt;[u8]&gt;到NonNull&lt;T&gt;
        self.ptr = unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) };
        //由字节数获得内存块数目
        self.cap = Self::capacity_from_bytes(ptr.len());
    }

    // 增长到满足len+additional的空间，
    fn grow_amortized(&amp;mut self, len: usize, additional: usize) -&gt; Result&lt;(), TryReserveError&gt; {
        // This is ensured by the calling contexts.
        debug_assert!(additional &gt; 0);

        if mem::size_of::&lt;T&gt;() == 0 {
            return Err(CapacityOverflow.into());
        }

        // 计算需要的容量值，不能超过usize::MAX.
        let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;

        // 每次以2的指数递增，且不能小于最小内存容量
        //  `cap &lt;= isize::MAX` and the type of `cap` is `usize`.
        let cap = cmp::max(self.cap * 2, required_cap);
        let cap = cmp::max(Self::MIN_NON_ZERO_CAP, cap);

        //重新计算内存大小
        let new_layout = Layout::array::&lt;T&gt;(cap);

        // 见后文.
        let ptr = finish_grow(new_layout, self.current_memory(), &amp;mut self.alloc)?;
        //更新ptr及cap
        self.set_ptr(ptr);
        Ok(())
    }

    // 与`grow_amortized`基本一致。只是要正好是len+additional的大小
    fn grow_exact(&amp;mut self, len: usize, additional: usize) -&gt; Result&lt;(), TryReserveError&gt; {
        if mem::size_of::&lt;T&gt;() == 0 {
            // Since we return a capacity of `usize::MAX` when the type size is
            // 0, getting to here necessarily means the `RawVec` is overfull.
            return Err(CapacityOverflow.into());
        }

        let cap = len.checked_add(additional).ok_or(CapacityOverflow)?;
        let new_layout = Layout::array::&lt;T&gt;(cap);

        // `finish_grow` is non-generic over `T`.
        let ptr = finish_grow(new_layout, self.current_memory(), &amp;mut self.alloc)?;
        self.set_ptr(ptr);
        Ok(())
    }
    
    //收缩内存到amount长度
    fn shrink(&amp;mut self, amount: usize) -&gt; Result&lt;(), TryReserveError&gt; {
        assert!(amount &lt;= self.capacity(), &quot;Tried to shrink to a larger capacity&quot;);

        let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };
        let new_size = amount * mem::size_of::&lt;T&gt;();

        let ptr = unsafe {
            let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());
            //利用Allcator的函数完成内存申请，拷贝原有内容，并释放原内存
            self.alloc
                .shrink(ptr, layout, new_layout)
                .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?
        };
        //更换指针和容量，这里虽然更换了self的内容，但没有改变编译器对self的所有权的认识
        self.set_ptr(ptr);
        Ok(())
    }
}
//内存增长具体实现
fn finish_grow&lt;A&gt;(
    new_layout: Result&lt;Layout, LayoutError&gt;,
    current_memory: Option&lt;(NonNull&lt;u8&gt;, Layout)&gt;,
    alloc: &amp;mut A,
) -&gt; Result&lt;NonNull&lt;[u8]&gt;, TryReserveError&gt;
where
    A: Allocator,
{
    // 检查new_layout是否为错误
    let new_layout = new_layout.map_err(|_| CapacityOverflow)?;
    //确保新的Layout的大小不引发异常
    alloc_guard(new_layout.size())?;

    let memory = if let Some((ptr, old_layout)) = current_memory {
        //原先已经申请过内存
        debug_assert_eq!(old_layout.align(), new_layout.align());
        unsafe
            // The allocator checks for alignment equality
            intrinsics::assume(old_layout.align() == new_layout.align());
            //调用Allocator的grow函数增长内存
            alloc.grow(ptr, old_layout, new_layout)
        }
    } else {
        //原先未申请过内存
        alloc.allocate(new_layout)
    };

    memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())
}

fn handle_reserve(result: Result&lt;(), TryReserveError&gt;) {
    match result.map_err(|e| e.kind()) {
        Err(CapacityOverflow) =&gt; capacity_overflow(),
        Err(AllocError { layout, .. }) =&gt; handle_alloc_error(layout),
        Ok(()) =&gt; { /* yay */ }
    }
}

fn alloc_guard(alloc_size: usize) -&gt; Result&lt;(), TryReserveError&gt; {
    if usize::BITS &lt; 64 &amp;&amp; alloc_size &gt; isize::MAX as usize {
        Err(CapacityOverflow.into())
    } else {
        Ok(())
    }
}

fn capacity_overflow() -&gt; ! {
    panic!(&quot;capacity overflow&quot;);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cow写时复制结构解析"><a class="header" href="#cow写时复制结构解析">Cow写时复制结构解析</a></h2>
<p>与Borrow Trait互为逆的ToOwned trait。 一般满足 T.borrow() 返回 &amp;U，  U.to_owned()返回T</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ToOwned {
    // 必须实现Borrow&lt;Self&gt; trait， Owned.borrow()-&gt;&amp;Self
    type Owned: Borrow&lt;Self&gt;;

    // 从本类型生成Owned类型，一般由指针生成原始变量
    fn to_owned(&amp;self) -&gt; Self::Owned;
    
    //替换target的内容，原内容会被drop掉
    fn clone_into(&amp;self, target: &amp;mut Self::Owned) {
        *target = self.to_owned();
    }
}

impl&lt;T&gt; ToOwned for T
//实现了Clone的类型自然实现ToOwned
where
    T: Clone
{
    type Owned = T;
    fn to_owned(&amp;self) -&gt; T {
        //创建一个新的T类型的变量
        self.clone()
    }

    fn clone_into(&amp;self, target: &amp;mut T) {
        target.clone_from(self);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Cow解决一类复制问题: 在与原有变量没有变化时使用原有变量的引用来访问变量，当发生变化时，完成对变量的复制生成新的变量。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B: ?Sized + 'a&gt;
where
    B: ToOwned,
{
    /// 用Borrowed封装原有变量的引用
    Borrowed( &amp;'a B),

    ///当需要对原有变量做修改，会对原油变量调用to_owned得到新变量，然后用Owned进行封装
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}</span></code></pre></pre>
<p>Cow的创建一般用`let a = Cow::Borrowed(&amp;T)这种方式直接完成，因为是写时复制，所以需要用Borrowed()来得到初始值，否则不符合语义要求。</p>
<p>典型的trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//解引用，会返回&amp;B
impl&lt;B: ?Sized + ToOwned&gt; const Deref for Cow&lt;'_, B&gt;
where
    B::Owned: ~const Borrow&lt;B&gt;,
{
    type Target = B;

    fn deref(&amp;self) -&gt; &amp;B {
        match *self {
            //如果是原有的变量，则返回原有变量引用
            Borrowed(borrowed) =&gt; borrowed,
            //如果值已经被修改，则返回新变量的borrow()
            Owned(ref owned) =&gt; owned.borrow(),
        }
    }
}

//实现Borrow Trait
impl&lt;'a, B: ?Sized&gt; Borrow&lt;B&gt; for Cow&lt;'a, B&gt;
where
    B: ToOwned,
    &lt;B as ToOwned&gt;::Owned: 'a,
{
    fn borrow(&amp;self) -&gt; &amp;B {
        //利用deref来返回
        &amp;**self
    }
}

// Clone的实现，需要满足写时复制的要求。
impl&lt;B: ?Sized + ToOwned&gt; Clone for Cow&lt;'_, B&gt; {
    fn clone(&amp;self) -&gt; Self {
        match *self {
            //如果是原变量的引用，因为没有写，所以只需要复制一个引用即可
            Borrowed(b) =&gt; Borrowed(b),
            //如果已经对原变量做了复制，那需要再次复制x现有变量。
            //根据已知条件，只能先得到o的borrow()，即一个B的变量，然后调用B的to_owned获得O的拷贝
            Owned(ref o) =&gt; {
                let b: &amp;B = o.borrow();
                Owned(b.to_owned())
            }
        }
    }

    fn clone_from(&amp;mut self, source: &amp;Self) {
        match (self, source) {
            //仅在双方都为Owned的情况下要先borrow后再复制，注意，此时self的原dest生命周期终止
            (&amp;mut Owned(ref mut dest), &amp;Owned(ref o)) =&gt; o.borrow().clone_into(dest),
            (t, s) =&gt; *t = s.clone(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Cow&lt;'a, T&gt;的一些方法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: ?Sized + ToOwned&gt; Cow&lt;'_, B&gt; {
    pub const fn is_borrowed(&amp;self) -&gt; bool {
        match *self {
            Borrowed(_) =&gt; true,
            Owned(_) =&gt; false,
        }
    }

    pub const fn is_owned(&amp;self) -&gt; bool {
        !self.is_borrowed()
    }

    //这个函数说明要对变量进行改变，因此，如果还是原变量的引用，则需要做复制操作
    pub fn to_mut(&amp;mut self) -&gt; &amp;mut &lt;B as ToOwned&gt;::Owned {
        match *self {
            Borrowed(borrowed) =&gt; {
                //复制操作，复制原变量后，然后用Owned包装
                *self = Owned(borrowed.to_owned());
                match *self {
                    Borrowed(..) =&gt; unreachable!(),
                    Owned(ref mut owned) =&gt; owned,
                }
            }
            Owned(ref mut owned) =&gt; owned,
        }
    }

    //此函数也说明后继要对Cow进行修改，所以先消费Cow
    pub fn into_owned(self) -&gt; &lt;B as ToOwned&gt;::Owned {
        match self {
            Borrowed(borrowed) =&gt; borrowed.to_owned(),
            Owned(owned) =&gt; owned,
        }
    }
}

//由slice生成Cow的代码例
impl&lt;'a, T: Clone&gt; From&lt;&amp;'a [T]&gt; for Cow&lt;'a, [T]&gt; {
    fn from(s: &amp;'a [T]) -&gt; Cow&lt;'a, [T]&gt; {
        //先生成Borrowed
        Cow::Borrowed(s)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>从Cow&lt;'a, T&gt;可以看到RUST基础语法的强大能力，大家可以思考一下如何用其他语言来实现这一写时复制的类型，会发现很难实现。</p>
<h2 id="vec-分析"><a class="header" href="#vec-分析">Vec 分析</a></h2>
<p>动态数组，结构体及创建，析构方法相关：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vec&lt;T, A: Allocator = Global&gt; {
    //RawVec作为堆内存结构，RawVec的容量可能大于Vec的有效长度
    buf: RawVec&lt;T, A&gt;,
    //Vec中真正的成员数目，一般小于RawVec的容量
    len: usize,
}

macro_rules! vec {
    () =&gt; (
        $crate::vec::Vec::new()
    );
    ($elem:expr; $n:expr) =&gt; (
        $crate::vec::from_elem($elem, $n)
    );
    ($($x:expr),*) =&gt; (
        //首先生成Box&lt;[T;N]&gt;，然后利用slice的into_vec生成`Vec&lt;T&gt;`
        $crate::slice::into_vec(box [$($x),*])
    );
    //这里实际上就是完成($x,)=&gt;$x。去掉了','号。 
    ($($x:expr,)*) =&gt; (vec![$($x),*])
}

impl&lt;T, A: Allocator&gt; ops::Deref for Vec&lt;T, A&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;[T] {
        //用裸指针类型变换方式形成切片的裸指针，再转换为切片引用
        //返回的&amp;[T]拥有与返回作用域匹配的生命周期
        //这个返回值是有隐含的生命周期类型的，不应长于self的生命周期
        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }
    }
}

impl&lt;T, A: Allocator&gt; ops::DerefMut for Vec&lt;T, A&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [T] {
        //返回值中有隐含的生命周期类型，不应长于self的生命周期
        unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }
    }
}
//Vec&lt;T&gt;的Index下标实现,实际上就是切片Index实现
impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; for Vec&lt;T, A&gt; {
    type Output = I::Output;

    fn index(&amp;self, index: I) -&gt; &amp;Self::Output {
        //&amp;**self会将Vec转换为&amp;[T]
        Index::index(&amp;**self, index)
    }
}

impl&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; IndexMut&lt;I&gt; for Vec&lt;T, A&gt; {
    fn index_mut(&amp;mut self, index: I) -&gt; &amp;mut Self::Output {
        IndexMut::index_mut(&amp;mut **self, index)
    }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    pub const fn new() -&gt; Self {
        //初始化buf为空
        Vec { buf: RawVec::NEW, len: 0 }
    }
    //其他创建函数，因为仅仅是对其他函数的封装调用，代码略
    pub fn with_capacity(capacity: usize) -&gt; Self;
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self;
}

//由Box转换为Vec，这是RUST的最令人无语的地方，内存安全导致必须对类型做各种其他语言不需要的复杂的变换
pub fn into_vec&lt;T, A: Allocator&gt;(b: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt; {
    unsafe {
        let len = b.len();
        let (b, alloc) = Box::into_raw_with_allocator(b);
        Vec::from_raw_parts_in(b as *mut T, len, len, alloc)
    }
}

//所有支持SpecFromElem trait的类型可以直接转换生成n个初始值为elem的Vec动态数组
pub fn from_elem_in&lt;T: Clone, A: Allocator&gt;(elem: T, n: usize, alloc: A) -&gt; Vec&lt;T, A&gt; {
    &lt;T as SpecFromElem&gt;::from_elem(elem, n, alloc)
}

pub(super) trait SpecFromElem: Sized {
    fn from_elem&lt;A: Allocator&gt;(elem: Self, n: usize, alloc: A) -&gt; Vec&lt;Self, A&gt;;
}
//所有实现了Clone的类型自然支持SpecFromElem trait
impl&lt;T: Clone&gt; SpecFromElem for T {
    default fn from_elem&lt;A: Allocator&gt;(elem: Self, n: usize, alloc: A) -&gt; Vec&lt;Self, A&gt; {
        //见下文分析
        let mut v = Vec::with_capacity_in(n, alloc);
        v.extend_with(n, ExtendElement(elem));
        v
    }
}
//drop方法
unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for Vec&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            //这里的drop_in_place调用会引发Vec&lt;T&gt;内部的成员变量自身的drop，所以只drop有意义的值
            //成员变量有些可能已经被释放过，会出现悬垂指针，所以用may_dangle来通知编译器
            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
        }
        //会自动调用RawVec的drop释放堆内存
    }
}

impl&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {
    //对RawVec做初始化，实际是空值
    pub const fn new_in(alloc: A) -&gt; Self {
        Vec { buf: RawVec::new_in(alloc), len: 0 }
    }

    //具体见RawVec的函数说明，这里创建了一个容量为输入参数的RawVec,
    //但Vec本身的长度为0，标示成员都还没有初始化
    pub fn with_capacity_in(capacity: usize, alloc: A) -&gt; Self {
        Vec { buf: RawVec::with_capacity_in(capacity, alloc), len: 0 }
    }

    //利用原始数据生成Vec，调用代码应该保证安全性：
    // *mut T应该是从堆申请的，符合RawVec&lt;T&gt;申请规则的大小和对齐，并且是用alloc来做的申请 
    pub unsafe fn from_raw_parts_in(ptr: *mut T, length: usize, capacity: usize, alloc: A) -&gt; Self {
        unsafe { Vec { buf: RawVec::from_raw_parts_in(ptr, capacity, alloc), len: length } }
    }

    //生成原始数据，此处首先要使得self被禁止drop，
    //一般后继利用这些原始数据生成新的RawVec，重新启用新RawVec的Drop
    pub fn into_raw_parts(self) -&gt; (*mut T, usize, usize) {
        let mut me = ManuallyDrop::new(self);
        //me自动解引用后得到Vec
        (me.as_mut_ptr(), me.len(), me.capacity())
    }

    //生成原始数据，包括alloc的变量
    pub fn into_raw_parts_with_alloc(self) -&gt; (*mut T, usize, usize, A) {
        let mut me = ManuallyDrop::new(self);
        let len = me.len();
        let capacity = me.capacity();
        let ptr = me.as_mut_ptr();
        let alloc = unsafe { ptr::read(me.allocator()) };
        (ptr, len, capacity, alloc)
    }

    pub fn capacity(&amp;self) -&gt; usize {
        //RawVec的capacity
        self.buf.capacity()
    }
    pub fn allocator(&amp;self) -&gt; &amp;A {
        self.buf.allocator()
    }

    pub fn len(&amp;self) -&gt; usize {
        self.len
    }
    //极度不安全，最好不要用这个函数改变len
    pub unsafe fn set_len(&amp;mut self, new_len: usize) {
        debug_assert!(new_len &lt;= self.capacity());
        //没有做任何处理就改变了len，可能造成内存泄漏，或者调用未初始化内存造成UB
        self.len = new_len;
    }
    pub fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }
<span class="boring">}</span></code></pre></pre>
<p>Vec容量相关方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //在当前的len的基础上扩张输入的参数的内存容量
    //不一定会出发对内存的重新申请，因为RawVec的容量可能是够的
    //容量不能超出usize::MAX
    pub fn reserve(&amp;mut self, additional: usize) {
        self.buf.reserve(self.len, additional);
    }

    //精确的扩张容量
    pub fn reserve_exact(&amp;mut self, additional: usize) {
        self.buf.reserve_exact(self.len, additional);
    }

    //如果reserve不成功，返回错误类型
    pub fn try_reserve(&amp;mut self, additional: usize) -&gt; Result&lt;(), TryReserveError&gt; {
        self.buf.try_reserve(self.len, additional)
    }

    //精确的容量
    pub fn try_reserve_exact(&amp;mut self, additional: usize) -&gt; Result&lt;(), TryReserveError&gt; {
        self.buf.try_reserve_exact(self.len, additional)
    }

    //收缩内部buf容量到正好是Vec长度
    pub fn shrink_to_fit(&amp;mut self) {
        if self.capacity() &gt; self.len {
            self.buf.shrink_to_fit(self.len);
        }
    }

    //收缩容量
    pub fn shrink_to(&amp;mut self, min_capacity: usize) {
        if self.capacity() &gt; min_capacity {
            self.buf.shrink_to_fit(cmp::max(self.len, min_capacity));
        }
    }
    //在有变量存在的情况下做收缩
    pub fn truncate(&amp;mut self, len: usize) {
        unsafe {
            if len &gt; self.len {
                return;
            }
            //计算需要删除的容量
            let remaining_len = self.len - len;
            //形成需要删除的部分的切片类型
            let s = ptr::slice_from_raw_parts_mut(self.as_mut_ptr().add(len), remaining_len);
            //修改Vec的长度。
            self.len = len;
            //调用drop_in_place，使得切片能够对内部的成员调用drop以完成删除
            //注意，此时不涉及Vec内部的buf删除，仅仅是删除Vec的成员
            ptr::drop_in_place(s);
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>将<code>Vec&lt;T&gt;</code>转换成其他类型</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //转换为Box&lt;[T], A&gt;类型。
    pub fn into_boxed_slice(mut self) -&gt; Box&lt;[T], A&gt; {
        unsafe {
            //此处重要，进入Box后，堆内存的容量必须是切片长度的内存，否则释放会引发问题
            self.shrink_to_fit();
            //本Vec的Drop需要禁止，由Box负责内存释放
            let me = ManuallyDrop::new(self);
            //这里将RawVec做了一个拷贝，实际上是将RawVec所有权转移出来，必须的
            //拷贝是效率高的做法
            let buf = ptr::read(&amp;me.buf);
            let len = me.len();
            //用RawVec生成Box
            buf.into_box(len).assume_init()
        }
    }

    pub fn as_slice(&amp;self) -&gt; &amp;[T] {
        //会自动解引用
        self
    }

    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        self
    }

    pub fn as_ptr(&amp;self) -&gt; *const T {
        let ptr = self.buf.ptr();
        unsafe {
            assume(!ptr.is_null());
        }
        ptr
    }

    pub fn as_mut_ptr(&amp;mut self) -&gt; *mut T {
        let ptr = self.buf.ptr();
        unsafe {
            assume(!ptr.is_null());
        }
        ptr
    }
<span class="boring">}</span></code></pre></pre>
<p>插入与删除方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //在index的位置插入一个变量
    pub fn insert(&amp;mut self, index: usize, element: T) {
        #[cold]
        #[inline(never)]
        fn assert_failed(index: usize, len: usize) -&gt; ! {
            panic!(&quot;insertion index (is {}) should be &lt;= len (is {})&quot;, index, len);
        }
        //如果index大于len，出错
        let len = self.len();
        if index &gt; len {
            assert_failed(index, len);
        }

        //如果预留的空间不够，则至少扩充1个成员空间
        if len == self.buf.capacity() {
            self.reserve(1);
        }

        unsafe {
            {
                //获得index的成员内存地址
                let p = self.as_mut_ptr().add(index);
                //此处将index之后所有成员内存向后偏移一个地址，最高的效率
                ptr::copy(p, p.offset(1), len - index);
                //将变量写入index的成员地址
                ptr::write(p, element);
            }
            //修改长度
            self.set_len(len + 1);
        }
    }

    pub fn remove(&amp;mut self, index: usize) -&gt; T {
        #[cold]
        #[inline(never)]
        #[track_caller]
        fn assert_failed(index: usize, len: usize) -&gt; ! {
            panic!(&quot;removal index (is {}) should be &lt; len (is {})&quot;, index, len);
        }

        //如果index大于Vec的长度，出错
        let len = self.len();
        if index &gt;= len {
            assert_failed(index, len);
        }
        unsafe {
            let ret;
            {
                // 得到index的成员地址
                let ptr = self.as_mut_ptr().add(index);
                // 将成员变量拷贝出来，并转移了所有权
                ret = ptr::read(ptr);

                // 将index+1后的所有成员内存拷贝到前面一个地址
                ptr::copy(ptr.offset(1), ptr, len - index - 1);
            }
            //改变长度
            self.set_len(len - 1);
            //将删除的变量及所有权返回。
            ret
        }
    }

    //在尾部插入一个元素
    pub fn push(&amp;mut self, value: T) {
        //如果预留空间不够，则扩充一个空间
        if self.len == self.buf.capacity() {
            self.reserve(1);
        }
        unsafe {
            //获取当前尾部成员后面的内存地址
            let end = self.as_mut_ptr().add(self.len);
            //将变量写入内存地址
            ptr::write(end, value);
            //长度加1
            self.len += 1;
        }
    }
     
    //取出尾部成员
    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.len == 0 {
            None
        } else {
            unsafe {
                self.len -= 1;
                //将尾部成员变量读出并连同所有权共同返回，此处因为self.len已经减1，后继drop时不会再对
                //原尾部成员drop。所以尾部成员的所有权已经被处理掉了
                Some(ptr::read(self.as_ptr().add(self.len())))
            }
        }
    }

    //删除所有成员
    pub fn clear(&amp;mut self) {
        //重用
        self.truncate(0)
    }

    //将另一个Vec加到本身
    pub fn append(&amp;mut self, other: &amp;mut Self) {
        unsafe {
            self.append_elements(other.as_slice() as _);
            //此时other中成员的所有权都已经转移到self
            //直接set_len(0)来完成forget操作
            other.set_len(0);
        }
    }

    unsafe fn append_elements(&amp;mut self, other: *const [T]) {
        //处理self的长度
        let count = unsafe { (*other).len() };
        self.reserve(count);
        let len = self.len();
        //一次性将other的成员拷贝到self，效率最高的方法，拷贝后所有权均已转移到self
        unsafe { ptr::copy_nonoverlapping(other as *const T, self.as_mut_ptr().add(len), count) };
        //完成长度改动
        self.len += count;
    }
   
    //leak方法，此方法后，需要再次将返回值转换到RavVec，否则会内存泄漏
    pub fn leak&lt;'a&gt;(self) -&gt; &amp;'a mut [T]
    where
        A: 'a,
    {
        //本Vec变量不再被drop
        let mut me = ManuallyDrop::new(self);
        //生成可变切片引用，此引用没有后继处理的话会造成内存泄漏
        unsafe { slice::from_raw_parts_mut(me.as_mut_ptr(), me.len) }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>slice转换为<code>Vec&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //从slice转换为Vec的trait定义
    pub trait ConvertVec {
        fn to_vec&lt;A: Allocator&gt;(s: &amp;[Self], alloc: A) -&gt; Vec&lt;Self, A&gt;
        where
            Self: Sized;
    }

    //所有支持Clone的类型都支持slce到Vec的转换
    impl&lt;T: Clone&gt; ConvertVec for T {
        default fn to_vec&lt;A: Allocator&gt;(s: &amp;[Self], alloc: A) -&gt; Vec&lt;Self, A&gt; {
            //用来做如果出现panic的时候，保证vec的正确性
            struct DropGuard&lt;'a, T, A: Allocator&gt; {
                vec: &amp;'a mut Vec&lt;T, A&gt;,
                num_init: usize,
            }
            impl&lt;'a, T, A: Allocator&gt; Drop for DropGuard&lt;'a, T, A&gt; {
                fn drop(&amp;mut self) {
                    unsafe {
                        //非正常退出，vec中只有self.num_init被正常初始化
                        self.vec.set_len(self.num_init);
                    }
                }
            }
            //创建具备足够空间的Vec&lt;T&gt;变量
            let mut vec = Vec::with_capacity_in(s.len(), alloc);
            let mut guard = DropGuard { vec: &amp;mut vec, num_init: 0 };
            //将vec中没有初始化的以[MaybeUninit&lt;T&gt;]返回
            let slots = guard.vec.spare_capacity_mut();
            
            //对s做迭代，取出下标及成员
            for (i, b) in s.iter().enumerate().take(slots.len()) {
                //guard中初始化的数目，如果panic，则要drop掉
                guard.num_init = i;
                //对b做clone并写入slots[i]，这里要注意所有权，b.clone()新创建了一个所有权
                //并将所有权转移到了slots[i]中
                slots[i].write(b.clone());
            }
            //循环结束，guard任务已经完成，drop不应再被调用
            core::mem::forget(guard);
            //设置vec的len
            unsafe {
                vec.set_len(s.len());
            }
            vec
        }
    }

    impl&lt;T: Copy&gt; ConvertVec for T {
        fn to_vec&lt;A: Allocator&gt;(s: &amp;[Self], alloc: A) -&gt; Vec&lt;Self, A&gt; {
            let mut v = Vec::with_capacity_in(s.len(), alloc);
            unsafe {
                //对于支持Copy的变量，直接做块的拷贝效率最高。
                s.as_ptr().copy_to_nonoverlapping(v.as_mut_ptr(), s.len());
                v.set_len(s.len());
            }
            v
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>ToOwned trait 代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl&lt;T: Clone&gt; ToOwned for [T] {
    type Owned = Vec&lt;T&gt;;
    
    fn to_owned(&amp;self) -&gt; Vec&lt;T&gt; {
        //[T].to_vec的调用，T:Clone，见上面代码
        self.to_vec()
    }

   fn clone_into(&amp;self, target: &amp;mut Vec&lt;T&gt;) {
        //略，请读者自行分析
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Clone trait实现代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Clone, A: Allocator + Clone&gt; Clone for Vec&lt;T, A&gt; {
    fn clone(&amp;self) -&gt; Self {
        let alloc = self.allocator().clone();
        //实质上是对[T]::to_vec()调用，见上面的代码
        &lt;[T]&gt;::to_vec_in(&amp;**self, alloc)
    }

    fn clone_from(&amp;mut self, other: &amp;Self) {
        //略，会导致太长的篇幅，留给读者自己分析
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="vect-iterator分析"><a class="header" href="#vect-iterator分析"><code>Vec&lt;T&gt;</code> Iterator分析</a></h3>
<p>into_iter() 相关结构及代码分析：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T, A: Allocator = Global,&gt; {
    pub(super) buf: NonNull&lt;T&gt;,
    pub(super) phantom: PhantomData&lt;T&gt;,
    pub(super) cap: usize,
    pub(super) alloc: A,
    pub(super) ptr: *const T,
    pub(super) end: *const T,
}

impl&lt;T, A: Allocator&gt; IntoIterator for Vec&lt;T, A&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T, A&gt;;

    fn into_iter(self) -&gt; IntoIter&lt;T, A&gt; {
        unsafe {
            //将Vec的所有成员所有权转入IntoIter，Vec自身不再做drop操作
            let mut me = ManuallyDrop::new(self);
            let alloc = ptr::read(me.allocator());
            //以下的处理与slice的Iterator非常类似
            let begin = me.as_mut_ptr();
            let end = if mem::size_of::&lt;T&gt;() == 0 {
                //0长度(ZST)类型处理方式
                arith_offset(begin as *const i8, me.len() as isize) as *const T
            } else {
                begin.add(me.len()) as *const T
            };
            let cap = me.buf.capacity();
            IntoIter {
                buf: NonNull::new_unchecked(begin),
                phantom: PhantomData,
                cap,
                alloc,
                ptr: begin,
                end,
            }
        }
    }
}

impl&lt;T, A: Allocator&gt; Iterator for IntoIter&lt;T, A&gt; {
    type Item = T;

    //以下与slice的Iterator相关方法非常类似
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.ptr as *const _ == self.end {
            None
        } else if mem::size_of::&lt;T&gt;() == 0 {
            // 这里不同，slice的库是end前移，这里是ptr后移
            self.ptr = unsafe { arith_offset(self.ptr as *const i8, 1) as *mut T };
            //如果T:Default，应该返回&lt;T as Default&gt;::default。
            //不能返回None，下面的代码应该是最好的表达方式。
            Some(unsafe { mem::zeroed() })
        } else {
            //更改头指针，保证不再访问头指针之前的变量
            let old = self.ptr;
            self.ptr = unsafe { self.ptr.offset(1) };
            //ptr::read将成员变量读到栈中并转移了所有权。
            //原有变量此时已经不会再被访问，IntoIter生命周期
            //终止的时候会释放RawVec堆内存
            Some(unsafe { ptr::read(old) })
        }
    }

    //其他函数略
    ...  
}
//其他辅助函数
impl&lt;T, A: Allocator&gt; IntoIter&lt;T, A&gt; {
    //由Iterator生成slice引用
    pub fn as_slice(&amp;self) -&gt; &amp;[T] {
        unsafe { slice::from_raw_parts(self.ptr, self.len()) }
    }
    //生成slice可变引用
    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe { &amp;mut *self.as_raw_mut_slice() }
    }

    //返回Allocator trait
    pub fn allocator(&amp;self) -&gt; &amp;A {
        &amp;self.alloc
    }

    //返回裸指针
    fn as_raw_mut_slice(&amp;mut self) -&gt; *mut [T] {
        ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())
    }

}

//drop函数
unsafe impl&lt;#[may_dangle] T, A: Allocator&gt; Drop for IntoIter&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        struct DropGuard&lt;'a, T, A: Allocator&gt;(&amp;'a mut IntoIter&lt;T, A&gt;);

        impl&lt;T, A: Allocator&gt; Drop for DropGuard&lt;'_, T, A&gt; {
            fn drop(&amp;mut self) {
                unsafe {
                    // 
                    let alloc = ptr::read(&amp;self.0.alloc);
                    // 恢复RawVec
                    let _ = RawVec::from_raw_parts_in(self.0.buf.as_ptr(), self.0.cap, alloc);
                    // RawVec生命周期终结，堆内存被释放
                }
            }
        }

        let guard = DropGuard(self);
        
        unsafe {
            //self.ptr之前的成员变量已经被消费,这里是一个slice的drop调用，会递归调用slice内的所有成员的drop
            ptr::drop_in_place(guard.0.as_raw_mut_slice());
        }
        // guard生命周期终止，drop被调用
    }
}

<span class="boring">}</span></code></pre></pre>
<p>以上代码要尤其注意next()时对成员的所有权处理，以及drop时的处理。
iter();iter_mut()相关的代码分析略。</p>
<p>Iterator与Vec的转换：
从一个Iterator增加成员：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, A: Allocator&gt; Extend&lt;T&gt; for Vec&lt;T, A&gt; {
    fn extend&lt;I: IntoIterator&lt;Item = T&gt;&gt;(&amp;mut self, iter: I) {
        //见下面的分析
        &lt;Self as SpecExtend&lt;T, I::IntoIter&gt;&gt;::spec_extend(self, iter.into_iter())
    }

    fn extend_one(&amp;mut self, item: T) {
        self.push(item);
    }

    fn extend_reserve(&amp;mut self, additional: usize) {
        self.reserve(additional);
    }
}
pub(super) trait SpecExtend&lt;T, I&gt; {
    fn spec_extend(&amp;mut self, iter: I);
}

impl&lt;T, A: Allocator&gt; SpecExtend&lt;T, IntoIter&lt;T&gt;&gt; for Vec&lt;T, A&gt; {
    fn spec_extend(&amp;mut self, mut iterator: IntoIter&lt;T&gt;) {
        unsafe {
            self.append_elements(iterator.as_slice() as _);
        }
        //以下方式是最快的清理方式。
        iterator.ptr = iterator.end;
    }
}
impl&lt;T: Clone, A: Allocator&gt; Vec&lt;T, A&gt; {
    pub fn extend_from_slice(&amp;mut self, other: &amp;[T]) {
        self.spec_extend(other.iter())
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p><code>Vec&lt;T&gt;</code>整体上具备极高的效率，的所有难于理解的内容点基本都是各种类型转换时的所有权相关处理。这也是所有的RUST的数据结构基础类型实现上相对比其他语言需要额外理解的复杂之处。 对<code>Vec&lt;T&gt;</code>的代码熟悉是提高所有权认识的有效途径。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-分析"><a class="header" href="#rct-分析"><code>Rc&lt;T&gt;</code> 分析</a></h2>
<p><code>Rc&lt;T&gt;</code>主要解决堆内存多份借用的情况，相比于<code>&amp;Box&lt;T&gt;</code>的解决方案，<code>Rc&lt;T&gt;</code>可以基本上不用考虑生命周期导致的编码负担。同时利用伴生的<code>Weak&lt;T&gt;</code>解决了变量相互之间的循环引用问题。
相比与<code>Box&lt;T&gt;</code>,<code>Rc&lt;T&gt;</code>是更常用的堆内存智能指针类型。</p>
<p><code>Rc&lt;T&gt;</code>解决了两个数据结构互指的情况，这在结构体组合，循环链表，树，图的数据结构中都有大量的应用。
<code>Rc&lt;T&gt;</code>的结构定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//在堆内存申请的结构体
//注意，这里使用了C语言的内存布局，在内存中的成员的顺序必须按照声明的顺序排列
#[repr(C)]
struct RcBox&lt;T: ?Sized&gt; {
    //拥有所有权的智能指针Rc&lt;T&gt;的计数
    strong: Cell&lt;usize&gt;,
    //不拥有所有权的智能指针Weak&lt;T&gt;的计数
    weak: Cell&lt;usize&gt;,
    value: T,
}

//和Unique&lt;T&gt;类似
pub struct Rc&lt;T: ?Sized&gt; {
    //堆内存块的指针
    ptr: NonNull&lt;RcBox&lt;T&gt;&gt;,
    //表示拥有内存块的所有权，内存块由本结构释放
    phantom: PhantomData&lt;RcBox&lt;T&gt;&gt;,
}
//没有堆内存块的所有权
pub struct Weak&lt;T: ?Sized&gt; {
   ptr: NonNull&lt;RcBox&lt;T&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>在创建两个结构体变量互指的指针时，会遇到生命周期陷阱，无论先释放那个结构变量，都会导致另外那个结构变量出现悬垂指针。但如果在代码中时刻关注这种情况，那就太不RUST。<br />
为此， <code>Rc&lt;T&gt;</code>提供了weak和strong两种堆内存指针的方式，<code>Rc&lt;T&gt;</code>申请的堆内存可以没有初始化，未初始化的堆内存可以生成<code>WeakT&gt;</code>用于给其他结构访问堆内存。同时堆内存用strong的方式来保护<code>Rc&lt;T&gt;</code>在未初始化时不被读写。且weak和strong可以相互之间转换，这就以RUST方式解决了生命周期陷阱问题。<br />
对<code>Rc&lt;T&gt;</code>建议的使用方式是各需要访问堆内存的类型仅使用<code>Weak&lt;T&gt;</code>作为平时的成员指针。当需要对<code>Rc&lt;T&gt;</code>做操作时，将<code>Weak&lt;T&gt;</code> upgrade为<code>Rc&lt;T&gt;</code>,操作完成后，将<code>Rc&lt;T&gt;</code> 生命周期终结。</p>
<p><code>Rc&lt;T&gt;</code>的创建方法及析构方法代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//由结构体成员生成结构的辅助方法
impl&lt;T: ?Sized&gt; Rc&lt;T&gt; {
    //获取内部的RcBox
    fn inner(&amp;self) -&gt; &amp;RcBox&lt;T&gt; {
        unsafe { self.ptr.as_ref() }
    }

    //由成员创建结构体，注意，这里没有对strong做计数增操作
    //因此，此处的内部ptr应是被别的Rc&lt;T&gt;解封装出来的
    fn from_inner(ptr: NonNull&lt;RcBox&lt;T&gt;&gt;) -&gt; Self {
        Self { ptr, phantom: PhantomData }
    }
    //由裸指针创建结构体，注意，这里没有对strong做计数增操作
    //因此，此处的内部ptr应是被别的Rc&lt;T&gt;解封装出来的
    unsafe fn from_ptr(ptr: *mut RcBox&lt;T&gt;) -&gt; Self {
        Self::from_inner(unsafe { NonNull::new_unchecked(ptr) })
    }
}

impl&lt;T&gt; Rc&lt;T&gt; {
    //由已初始化变量创建Rc&lt;T&gt;
    pub fn new(value: T) -&gt; Rc&lt;T&gt; {
        //首先创建RcBox&lt;T&gt;，然后生成Box&lt;RcBox&lt;T&gt;&gt;, 随后用leak得到RcBox&lt;T&gt;的堆内存指针，
        //用堆内存指针创建Rc&lt;T&gt;，内存申请由Box&lt;T&gt;实际执行
        Self::from_inner(
            Box::leak(box RcBox { strong: Cell::new(1), weak: Cell::new(1), value }).into(),
        )
    }

    //用于创建一个互相引用场景的Rc&lt;T&gt;
    pub fn new_cyclic(data_fn: impl FnOnce(&amp;Weak&lt;T&gt;) -&gt; T) -&gt; Rc&lt;T&gt; {
        // 下面与new函数代码类似，只是value没有初始化。
        // 因为value没有初始化，strong赋值为0，但可以支持Weak&lt;T&gt;的引用
        let uninit_ptr: NonNull&lt;_&gt; = Box::leak(box RcBox {
            strong: Cell::new(0),
            weak: Cell::new(1),
            value: mem::MaybeUninit::&lt;T&gt;::uninit(),
        })
        .into();
        
        //init_ptr后继会被初始化，但此时还没有
        let init_ptr: NonNull&lt;RcBox&lt;T&gt;&gt; = uninit_ptr.cast();

        //生成Weak
        let weak = Weak { ptr: init_ptr };

        // 利用回调闭包获得value的值，将weak传递出去是因为cyclic默认结构体初始化需要使用weak.
        // 用回调函数的处理可以让初始化一次完成，以免初始化以后还要修改结构体的指针。
        let data = data_fn(&amp;weak);

        unsafe {
            let inner = init_ptr.as_ptr();
            //addr_of_mut!可以万无一失，写入值后，初始化已经完成
            ptr::write(ptr::addr_of_mut!((*inner).value), data);
            
            //可以更新strong的值为1了
            let prev_value = (*inner).strong.get();
            debug_assert_eq!(prev_value, 0, &quot;No prior strong references should exist&quot;);
            (*inner).strong.set(1);
        }

        //strong登场
        let strong = Rc::from_inner(init_ptr);

        // 这里是因为strong整体拥有一个weak计数，所以此处不对wek做drop处理以维持weak计数。前面的回调函数中应该使用weak.clone增加weak的计数。
        mem::forget(weak);
        strong
    }

    //生成一个未初始化的Rc&lt;T&gt;，选择了直接做内存申请
    pub fn new_uninit() -&gt; Rc&lt;mem::MaybeUninit&lt;T&gt;&gt; {
        unsafe {
            //Rc自身的内存申请函数，见下文的分析
            Rc::from_ptr(Rc::allocate_for_layout(
                Layout::new::&lt;T&gt;(),
                |layout| Global.allocate(layout),
                |mem| mem as *mut RcBox&lt;mem::MaybeUninit&lt;T&gt;&gt;,
            ))
        }
    }

    //防止内存不足的创建函数
    pub fn try_new(value: T) -&gt; Result&lt;Rc&lt;T&gt;, AllocError&gt; {
        // 就是用Box::try_new来完成try的工作
        Ok(Self::from_inner(
            Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)
                .into(),
        ))
    }

    //对未初始化的Rc的try new
    pub fn try_new_uninit() -&gt; Result&lt;Rc&lt;mem::MaybeUninit&lt;T&gt;&gt;, AllocError&gt; {
        unsafe {
            //内存申请函数需要考虑申请不到的情况
            Ok(Rc::from_ptr(Rc::try_allocate_for_layout(
                Layout::new::&lt;T&gt;(),
                //就用Global Allocator，没有考虑其他的Allocator
                |layout| Global.allocate(layout),
                |mem| mem as *mut RcBox&lt;mem::MaybeUninit&lt;T&gt;&gt;,
            )?))
        }
    }
    ...
}

//堆内存申请函数
impl&lt;T: ?Sized&gt; Rc&lt;T&gt; {
   unsafe fn allocate_for_layout(
       value_layout: Layout,
       allocate: impl FnOnce(Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt;,
       mem_to_rcbox: impl FnOnce(*mut u8) -&gt; *mut RcBox&lt;T&gt;,
   ) -&gt; *mut RcBox&lt;T&gt; {
       // 根据T计算RcBox需要的内存块布局，注意用RcBox&lt;()&gt;获取仅包含strong及weak两个成员的RcBox的layout这个技巧
       //首先计算strong及weak两个成员的layout,然后对内部T类型的layout加以扩充，再做对齐的补充。
       let layout = Layout::new::&lt;RcBox&lt;()&gt;&gt;().extend(value_layout).unwrap().0.pad_to_align();
       unsafe {
           //要考虑不成功的可能性
           Rc::try_allocate_for_layout(value_layout, allocate, mem_to_rcbox)
               .unwrap_or_else(|_| handle_alloc_error(layout))
       }
   }

   unsafe fn try_allocate_for_layout(
       value_layout: Layout,
       allocate: impl FnOnce(Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt;,
       mem_to_rcbox: impl FnOnce(*mut u8) -&gt; *mut RcBox&lt;T&gt;,
   ) -&gt; Result&lt;*mut RcBox&lt;T&gt;, AllocError&gt; {
       //计算需要的内存块布局layout
       let layout = Layout::new::&lt;RcBox&lt;()&gt;&gt;().extend(value_layout).unwrap().0.pad_to_align();

       // 申请内存，有可能不成功
       let ptr = allocate(layout)?;

       // 将裸指针类型内存类型转换成*mut RcBox&lt;xxx&gt;类型，xxx有可能是MaybeUninit&lt;T&gt;，但也可能是初始化完毕的类型。总之，调用代码会保证初始化，所以此处正常的设置strong及weak，
       let inner = mem_to_rcbox(ptr.as_non_null_ptr().as_ptr());
       unsafe {
           debug_assert_eq!(Layout::for_value(&amp;*inner), layout);

           ptr::write(&amp;mut (*inner).strong, Cell::new(1));
           ptr::write(&amp;mut (*inner).weak, Cell::new(1));
       }

       Ok(inner)
   }
   
   //根据一个裸指针来创建RcBox&lt;T&gt;，返回裸指针，这个函数完成时堆内存没有初始化，后继需要写入值
   unsafe fn allocate_for_ptr(ptr: *const T) -&gt; *mut RcBox&lt;T&gt; {
       unsafe {
           Self::allocate_for_layout(
               // 用*const T获取Layout
               Layout::for_value(&amp;*ptr),
               |layout| Global.allocate(layout),
               //此处应该也可以用mem as *mut RcBox&lt;T&gt;，
               |mem| (ptr as *mut RcBox&lt;T&gt;).set_ptr_value(mem),
           )
       }
   }

   //从Box&lt;T&gt;转换成RcBox&lt;T&gt;
   fn from_box(v: Box&lt;T&gt;) -&gt; Rc&lt;T&gt; {
       unsafe {
           //解封装Box，获取堆内存指针
           let (box_unique, alloc) = Box::into_unique(v);
           let bptr = box_unique.as_ptr();

           let value_size = size_of_val(&amp;*bptr);
           //获得* mut RcBox&lt;T&gt;
           let ptr = Self::allocate_for_ptr(bptr);

           // 将T的内容拷贝入RcBox的value
           ptr::copy_nonoverlapping(
               bptr as *const T as *const u8,
               &amp;mut (*ptr).value as *mut _ as *mut u8,
               value_size,
           );

           // 重要，这里仅仅释放堆内存，但是如果堆内存中的T类型变量还有其他需要释放的内存，则没有处理，即没有调用drop(T)，drop(T)由新生成的RcBox&lt;T&gt;再释放的时候负责
           box_free(box_unique, alloc);
           
           // 生成Rc&lt;T&gt;
           Self::from_ptr(ptr)
       }
   }
}

//析构
unsafe impl&lt;#[may_dangle] T: ?Sized&gt; Drop for Rc&lt;T&gt; {
   //只要strong计数为零，就drop掉堆内存变量
   //Weak可以不依赖于内存初始化。
   fn drop(&amp;mut self) {
       unsafe {
           //strong计数减1
           self.inner().dec_strong();
           if self.inner().strong() == 0 {
               // 触发堆内存变量的drop()操作
               ptr::drop_in_place(Self::get_mut_unchecked(self));

               // 对于strong整体会有一个weak计数，需要减掉
               // 这里实际上与C语言一样容易出错。
               self.inner().dec_weak();

               if self.inner().weak() == 0 {
                   //只有weak为0的时候才能够释放堆内存
                   Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));
               }
           }
       }
   }
}

impl&lt;T: ?Sized&gt; Deref for Rc&lt;T&gt; {
   type Target = T;

   fn deref(&amp;self) -&gt; &amp;T {
       &amp;self.inner().value
   }
}

<span class="boring">}</span></code></pre></pre>
<p><code>Weak&lt;T&gt;</code>的结构体及创建，析构方法：
在RC方法内部，Weak可以由<code>Weak{ptr:self_ptr}</code>直接创建，可见前面代码的例子，但要注意weak计数和Weak变量需要匹配</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;T&gt; Weak&lt;T&gt; {
   //创建一个空的Weak
   pub fn new() -&gt; Weak&lt;T&gt; {
       Weak { ptr: NonNull::new(usize::MAX as *mut RcBox&lt;T&gt;).expect(&quot;MAX is not 0&quot;) }
   }
}
//判断Weak是否为空的关联函数
pub(crate) fn is_dangling&lt;T: ?Sized&gt;(ptr: *mut T) -&gt; bool {
   let address = ptr as *mut () as usize;
   address == usize::MAX
}
impl &lt;T:?Sized&gt; Weak&lt;T&gt; {
   //从Weak中获得堆内存中T类型的变量指针
   pub fn as_ptr(&amp;self) -&gt; *const T {
       let ptr: *mut RcBox&lt;T&gt; = NonNull::as_ptr(self.ptr);

       if is_dangling(ptr) {
           ptr as *const T
       } else {
           //返回T类型变量的指针
           unsafe { ptr::addr_of_mut!((*ptr).value) }
       }
   }
   //会消费掉Weak，获取T类型变量指针，此指针以后需要重新组建Weak&lt;T&gt;,否则
   //堆内存中的RcBox的weak会出现计数错误
   pub fn into_raw(self) -&gt; *const T {
       let result = self.as_ptr();
       mem::forget(self);
       result
   }
   
   //ptr是从into_raw得到的返回值
   pub unsafe fn from_raw(ptr: *const T) -&gt; Self {
       let ptr = if is_dangling(ptr as *mut T) {
           ptr as *mut RcBox&lt;T&gt;
       } else {
           //需要从T类型的指针恢复RcBox的指针
           let offset = unsafe { data_offset(ptr) };
           unsafe { (ptr as *mut RcBox&lt;T&gt;).set_ptr_value((ptr as *mut u8).offset(-offset)) }
       };
       //RcBox的weak的计数已经有了这个计数
       Weak { ptr: unsafe { NonNull::new_unchecked(ptr) } }
   }

   //创建WeakInner
   fn inner(&amp;self) -&gt; Option&lt;WeakInner&lt;'_&gt;&gt; {
       if is_dangling(self.ptr.as_ptr()) {
           None
       } else {
           Some(unsafe {
               let ptr = self.ptr.as_ptr();
               WeakInner { strong: &amp;(*ptr).strong, weak: &amp;(*ptr).weak }
           })
       }
   }

   //从Weak得到Rc, 如前所述，对Rc正确的打开方式应该是仅用Weak，然后适当的时候升级到Rc&lt;T&gt;，
   //并且在使用完毕后就将Rc&lt;T&gt;生命周期终止掉，即这个函数返回的Rc&lt;T&gt;生命周期最好仅在一个函数中。
   pub fn upgrade(&amp;self) -&gt; Option&lt;Rc&lt;T&gt;&gt; {
       //获取内部的RcBox
       let inner = self.inner()?;
       if inner.strong() == 0 {
           None
       } else {
           //对RcBox&lt;T&gt;的strong增加计数
           inner.inc_strong();
           //利用RcBox生成新的Rc&lt;T&gt;
           Some(Rc::from_inner(self.ptr))
       }
   }
}
impl &lt;T:?Sized&gt; Rc&lt;T&gt; {
   ...

   //生成新的Weak&lt;T&gt;
   pub fn downgrade(this: &amp;Self) -&gt; Weak&lt;T&gt; {
       //增加weak计数
       this.inner().inc_weak();
       // 确保不出错
       debug_assert!(!is_dangling(this.ptr.as_ptr()));
       // 生成Weak&lt;T&gt;
       Weak { ptr: this.ptr }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Rc&lt;T&gt;</code>的其他方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> impl&lt;T: Clone&gt; Rc&lt;T&gt; {
    //Rc&lt;T&gt; 实际上是需要配合RefCell&lt;T&gt;来完成对堆内存的修改需求
    //下面的函数用了类似写时复制的方式，仅能在某些场景下使用
    pub fn make_mut(this: &amp;mut Self) -&gt; &amp;mut T {
        if Rc::strong_count(this) != 1 {
            // 如果Rc多于一个，则创建一个拷贝的变量
            // 申请一个未初始化的Rc
            let mut rc = Self::new_uninit();
            unsafe {
                //将self中的value值写入新创建的变量
                let data = Rc::get_mut_unchecked(&amp;mut rc);
                (**this).write_clone_into_raw(data.as_mut_ptr());
                //这里把this代表的Rc释放掉，并赋以新值。
                //make_mut的本意是从this中生成一个mut，因此将this代表的Rc&lt;T&gt;释放掉是合乎
                //函数的意义的
                *this = rc.assume_init();
            }
        } else if Rc::weak_count(this) != 0 {
            // 如果Rc&lt;T&gt;仅有一个strong引用，但有其他的weak引用
            // 同样需要新建一个Rc&lt;T&gt;
            let mut rc = Self::new_uninit();
            unsafe {
                //下面用了与strong !=1 的情况的不同写法，但应该完成了同样的工作
                let data = Rc::get_mut_unchecked(&amp;mut rc);
                data.as_mut_ptr().copy_from_nonoverlapping(&amp;**this, 1);
                
                //将strong引用减去，堆内存不再存在strong引用
                this.inner().dec_strong();
                // strong已经为0，所以将strong的weak计数减掉
                this.inner().dec_weak();
                //不能用*this = 的表达，因为会导致对堆内存变量的释放，这不符合语义。
                ptr::write(this, rc.assume_init());
            }
        }
        //已经确保了只有一个Rc&lt;T&gt;，且没有Weak&lt;T&gt;，可以任意对堆变量做修改了
        unsafe { &amp;mut this.ptr.as_mut().value }
    }
 }
<span class="boring">}</span></code></pre></pre>
<p>Clone trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Clone for Rc&lt;T&gt; {
   //clone就是增加一个strong的计数
   fn clone(&amp;self) -&gt; Rc&lt;T&gt; {
       self.inner().inc_strong();
       Self::from_inner(self.ptr)
   }
}

impl&lt;T: ?Sized&gt; Clone for Weak&lt;T&gt; {
   fn clone(&amp;self) -&gt; Weak&lt;T&gt; {
       if let Some(inner) = self.inner() {
           inner.inc_weak()
       }
       Weak { ptr: self.ptr }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>对<code>Rc&lt;MaybeUninit&lt;T&gt;&gt;</code>初始化后assume_init实现方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Rc&lt;mem::MaybeUninit&lt;T&gt;&gt; {
    pub unsafe fn assume_init(self) -&gt; Rc&lt;T&gt; {
        //先用ManuallyDrop将self封装以便不对self做drop操作
        //然后取出内部的堆指针形成新的Rc&lt;T&gt;。
        Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Rc&lt;T&gt;</code>其他方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Rc&lt;T&gt; {
    //相当于Rc&lt;T&gt;的leak函数
    pub fn into_raw(this: Self) -&gt; *const T {
        let ptr = Self::as_ptr(&amp;this);
        //把堆内存指针取出后，由调用代码负责释放，
        //本结构体要规避后继的释放操作
        mem::forget(this);
        ptr
    }

    //获得堆内存变量的指针，不会涉及安全问题,注意，这里ptr不是堆内存块的首地址，而是向后有偏移
    //因为RcBox&lt;T&gt;采用C语言的内存布局，所以value在最后
    pub fn as_ptr(this: &amp;Self) -&gt; *const T {
        let ptr: *mut RcBox&lt;T&gt; = NonNull::as_ptr(this.ptr);

        unsafe { ptr::addr_of_mut!((*ptr).value) }
    }

    //从堆内存T类型变量的指针重建Rc&lt;T&gt;，注意，这里的ptr一般是调用Rc&lt;T&gt;::into_raw()获得的裸指针
    //ptr不是堆内存块首地址，需要减去strong和weak的内存大小
    pub unsafe fn from_raw(ptr: *const T) -&gt; Self {
        let offset = unsafe { data_offset(ptr) };

        // 减去偏移量，得到正确的RcBox堆内存的首地址
        let rc_ptr =
            unsafe { (ptr as *mut RcBox&lt;T&gt;).set_ptr_value((ptr as *mut u8).offset(-offset)) };

        unsafe { Self::from_ptr(rc_ptr) }
    }
<span class="boring">}</span></code></pre></pre>
<p>into_raw, from_raw要成对使用，否则就必须对这两个方法的内存由清晰的认知。否则极易出现问题。
<code>Rc&lt;T&gt;</code> 转换为<code>Weak&lt;T&gt;</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn get_mut(this: &amp;mut Self) -&gt; Option&lt;&amp;mut T&gt; {
        if Rc::is_unique(this) { unsafe { Some(Rc::get_mut_unchecked(this)) } } else { None }
    }

    pub unsafe fn get_mut_unchecked(this: &amp;mut Self) -&gt; &amp;mut T {
        unsafe { &amp;mut (*this.ptr.as_ptr()).value }
    }

}
<span class="boring">}</span></code></pre></pre>
<h2 id="arct的代码实现"><a class="header" href="#arct的代码实现"><code>Arc&lt;T&gt;</code>的代码实现</a></h2>
<p><code>Arc&lt;T&gt;</code> 是<code>Rc&lt;T&gt;</code>的多线程版本，实际上，就连代码都基本类似，只是把计数值的类型换成了原子变量
<code>Arc&lt;T&gt;</code>类型结构定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//在堆内存分配的结构体
#[repr(C)]
struct ArcInner&lt;T: ?Sized&gt; {
    //用原子变量实现计数，使得计数修改不会因多线程竞争而出错
    //AtomicUsize 如下：
    // pub struct AtomicUsize { v: UnsafeCell&lt;usize&gt;}
    strong: atomic::AtomicUsize,
    weak: atomic::AtomicUsize,
    data: T,
}

//支持Send
unsafe impl&lt;T: ?Sized + Sync + Send&gt; Send for ArcInner&lt;T&gt; {}
//支持Sync
unsafe impl&lt;T: ?Sized + Sync + Send&gt; Sync for ArcInner&lt;T&gt; {}

//Arc&lt;T&gt;的结构
pub struct Arc&lt;T: ?Sized&gt; {
    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,
    phantom: PhantomData&lt;ArcInner&lt;T&gt;&gt;,
}
//对Send支持
unsafe impl&lt;T: ?Sized + Sync + Send&gt; Send for Arc&lt;T&gt; {}
//对Sync支持
unsafe impl&lt;T: ?Sized + Sync + Send&gt; Sync for Arc&lt;T&gt; {}

//Weak&lt;T&gt;的结构
pub struct Weak&lt;T: ?Sized&gt; {
    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,
}

unsafe impl&lt;T: ?Sized + Sync + Send&gt; Send for Weak&lt;T&gt; {}
unsafe impl&lt;T: ?Sized + Sync + Send&gt; Sync for Weak&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p><code>ArcInner&lt;T&gt;</code>对应<code>RcBox&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>对应<code>Rc&lt;T&gt;</code>, <code>sync::Weak&lt;T&gt;</code>对应<code>rc::Weak&lt;T&gt;</code>。逻辑与<code>Rc&lt;T&gt;</code>模块的逻辑都基本相同。 <code>Arc&lt;T&gt;</code>除了<code>ArcInner&lt;T&gt;</code>与<code>RcBox&lt;T&gt;</code>有区别，计数器用原子变量实现，使得计数器的加减操作不会受多线程数据竞争的影响，从而使得<code>Arc&lt;T&gt;</code>能够在多线程环境下使用。这里需要注意<code>Rc&lt;T&gt;</code>及<code>Arc&lt;T&gt;</code>实际上仅仅是不可变引用的多线程替代(多于两个以上)，因此<code>Arc&lt;T&gt;</code>的实现中仅仅关注<code>Arc&lt;T&gt;</code>类型本身的多线程共享的保护机制。至于内部的泛型类型变量data，仍然需要泛型类型自身对多线程共享的实现。</p>
<p>与 <code>Rc&lt;T&gt;</code>相同，<code>Arc&lt;T&gt;</code>也提供了weak和strong两种堆内存指针的方式，<code>Arc&lt;T&gt;</code>申请的堆内存可以没有初始化，未初始化的堆内存可以生成<code>WeakT&gt;</code>用于给其他结构访问堆内存。同时堆内存用strong的方式来保护<code>Arc&lt;T&gt;</code>在未初始化时不被读写。且weak和strong可以相互之间转换，这就以rust方式解决了生命周期陷阱问题。
利用<code>Weak&lt;T&gt;</code>做指针的结构体，在需要访问堆内存时，可以从<code>Weak&lt;T&gt;</code>另外创建<code>Arc&lt;T&gt;</code>, 完成访问后即可让创建的<code>Arc&lt;T&gt;</code>生命周期终结。实际上，各需要访问堆内存的类型仅使用<code>Weak&lt;T&gt;</code>应该是一个非常好的做法。</p>
<p><code>Arc&lt;T&gt;</code>的创建方法及析构方法代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//已经存在堆内存，从堆内存来创建Arc&lt;T&gt;
impl&lt;T:?Sized&gt; Arc&lt;T&gt; {
   //注意这里没有增加strong计数，
   fn from_inner(ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;) -&gt; Self {
       Self { ptr, phantom: PhantomData }
   }

   //注意这里没有增加strong的计数
   unsafe fn from_ptr(ptr: *mut ArcInner&lt;T&gt;) -&gt; Self {
       unsafe { Self::from_inner(NonNull::new_unchecked(ptr)) }
   }
}

impl&lt;T&gt; Arc&lt;T&gt; {
    //由已初始化变量创建Arc&lt;T&gt;
    pub fn new(data: T) -&gt; Arc&lt;T&gt; {
        //首先创建ArcInner&lt;T&gt;，然后生成Box&lt;ArcInner&lt;T&gt;&gt;, 随后用leak得到ArcInner&lt;T&gt;的堆内存指针，
        //用堆内存指针创建Rc&lt;T&gt;，内存申请由Box&lt;T&gt;实际执行
       let x: Box&lt;_&gt; = box ArcInner {
           strong: atomic::AtomicUsize::new(1),
           weak: atomic::AtomicUsize::new(1),
           data,
       };
       Self::from_inner(Box::leak(x).into())
   }
    //用于创建一个互相引用场景的Arc&lt;T&gt;
   pub fn new_cyclic(data_fn: impl FnOnce(&amp;Weak&lt;T&gt;) -&gt; T) -&gt; Arc&lt;T&gt; {
        // 下面与new函数代码类似，只是value没有初始化。
        // 因为value没有初始化，strong赋值为0，但可以支持Weak&lt;T&gt;的引用
       let uninit_ptr: NonNull&lt;_&gt; = Box::leak(box ArcInner {
           strong: atomic::AtomicUsize::new(0),
           weak: atomic::AtomicUsize::new(1),
           data: mem::MaybeUninit::&lt;T&gt;::uninit(),
       })
       .into();

        //init_ptr后继会被初始化，但此时还没有
       let init_ptr: NonNull&lt;ArcInner&lt;T&gt;&gt; = uninit_ptr.cast();

        //生成Weak
       let weak = Weak { ptr: init_ptr };

        // 利用回调闭包获得value的值，将weak传递出去是因为cyclic默认结构体初始化需要使用weak.
        // 用回调函数的处理可以让初始化一次完成，以免初始化以后还要修改结构体的指针。
       let data = data_fn(&amp;weak);

       // 完成对值的初始化.并转化Weak为Strong.
       unsafe {
           let inner = init_ptr.as_ptr();
            //addr_of_mut!可以万无一失，写入值后，初始化已经完成
           ptr::write(ptr::addr_of_mut!((*inner).data), data);

            //可以更新strong的值为1了,注意这里的原子函数，这个函数不会被其他线程打断导致更新失败
           let prev_value = (*inner).strong.fetch_add(1, Release);
           debug_assert_eq!(prev_value, 0, &quot;No prior strong references should exist&quot;);
       }

        //strong登场
       let strong = Arc::from_inner(init_ptr);

        // 这里是因为strong整体拥有一个weak计数，所以此处不对weak做drop处理以维持weak计数。前面的回调函数中应该使用weak.clone增加weak的计数。
       mem::forget(weak);
       strong
   }

    //生成一个未初始化的Arc&lt;T&gt;，选择直接做内存申请
   pub fn new_uninit() -&gt; Arc&lt;mem::MaybeUninit&lt;T&gt;&gt; {
       unsafe {
            //Arc自身的内存申请函数，后继有分析
           Arc::from_ptr(Arc::allocate_for_layout(
               Layout::new::&lt;T&gt;(),
               |layout| Global.allocate(layout),
               |mem| mem as *mut ArcInner&lt;mem::MaybeUninit&lt;T&gt;&gt;,
           ))
       }
   }
    //防止内存不足的创建函数
   pub fn try_new(data: T) -&gt; Result&lt;Arc&lt;T&gt;, AllocError&gt; {
        // 就是用Box::try_new来完成try的工作
       let x: Box&lt;_&gt; = Box::try_new(ArcInner {
           strong: atomic::AtomicUsize::new(1),
           weak: atomic::AtomicUsize::new(1),
           data,
       })?;
       Ok(Self::from_inner(Box::leak(x).into()))
   }

    //对未初始化的Rc的try new
   pub fn try_new_uninit() -&gt; Result&lt;Arc&lt;mem::MaybeUninit&lt;T&gt;&gt;, AllocError&gt; {
       unsafe {
            //内存申请函数需要考虑申请不到的情况
           Ok(Arc::from_ptr(Arc::try_allocate_for_layout(
               Layout::new::&lt;T&gt;(),
                //就用Global Allocator，没有考虑其他Allocator
               |layout| Global.allocate(layout),
               |mem| mem as *mut ArcInner&lt;mem::MaybeUninit&lt;T&gt;&gt;,
           )?))
       }
   }
    ...
}

//堆内存申请函数
impl&lt;T: ?Sized&gt; Arc&lt;T&gt; {
   unsafe fn allocate_for_layout(
       value_layout: Layout,
       allocate: impl FnOnce(Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt;,
       mem_to_arcinner: impl FnOnce(*mut u8) -&gt; *mut ArcInner&lt;T&gt;,
   ) -&gt; *mut ArcInner&lt;T&gt; {
       // 根据T计算ArcInner需要的内存块布局，与Rc&lt;T&gt;的同名函数基本相同，请参考
       let layout = Layout::new::&lt;ArcInner&lt;()&gt;&gt;().extend(value_layout).unwrap().0.pad_to_align();
       unsafe {
           //要考虑不成功的可能性
           Arc::try_allocate_for_layout(value_layout, allocate, mem_to_arcinner)
               .unwrap_or_else(|_| handle_alloc_error(layout))
       }
   }

   unsafe fn try_allocate_for_layout(
       value_layout: Layout,
       allocate: impl FnOnce(Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt;,
       mem_to_arcinner: impl FnOnce(*mut u8) -&gt; *mut ArcInner&lt;T&gt;,
   ) -&gt; Result&lt;*mut ArcInner&lt;T&gt;, AllocError&gt; {
       //计算需要的内存块布局layout
       let layout = Layout::new::&lt;ArcInner&lt;()&gt;&gt;().extend(value_layout).unwrap().0.pad_to_align();

       // 申请内存，有可能不成功
       let ptr = allocate(layout)?;

       // 将裸指针类型内存类型转换成*mut ArcInner&lt;xxx&gt;类型，xxx有可能是MaybeUninit&lt;T&gt;，但也可能是初始化完毕的类型。总之，调用代码会保证初始化，所以此处正常的设置strong及weak，
       let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());
       debug_assert_eq!(unsafe { Layout::for_value(&amp;*inner) }, layout);

       unsafe {
           ptr::write(&amp;mut (*inner).strong, atomic::AtomicUsize::new(1));
           ptr::write(&amp;mut (*inner).weak, atomic::AtomicUsize::new(1));
       }

       Ok(inner)
   }

   //根据一个裸指针来创建ArcInner&lt;T&gt;，返回裸指针，这个函数完成时堆内存没有初始化，后继需要写入值
   unsafe fn allocate_for_ptr(ptr: *const T) -&gt; *mut ArcInner&lt;T&gt; {
       unsafe {
           Self::allocate_for_layout(
               // 用*const T获取Layout
               Layout::for_value(&amp;*ptr),
               |layout| Global.allocate(layout),
               //此处应该也可以用mem as *mut ArcInner&lt;T&gt;，
               |mem| (ptr as *mut ArcInner&lt;T&gt;).set_ptr_value(mem) as *mut ArcInner&lt;T&gt;,
           )
       }
   }

   //从Box&lt;T&gt;转换成Arc&lt;T&gt;
    fn from_box(v: Box&lt;T&gt;) -&gt; Arc&lt;T&gt; {
       unsafe {
           //解封装Box，获取堆内存指针
           let (box_unique, alloc) = Box::into_unique(v);
           let bptr = box_unique.as_ptr();

           let value_size = size_of_val(&amp;*bptr);
           //获得* mut ArcInner&lt;T&gt;
           let ptr = Self::allocate_for_ptr(bptr);

           // 将T的内容拷贝入ArcInner的value
           ptr::copy_nonoverlapping(
               bptr as *const T as *const u8,
               &amp;mut (*ptr).data as *mut _ as *mut u8,
               value_size,
           );

           // 重要，这里仅仅释放堆内存，但是如果堆内存中的T类型变量还有其他需要释放的内存，则没有处理，即没有调用drop(T)，drop(T)由新生成的ArcInner&lt;T&gt;再释放的时候负责
           box_free(box_unique, alloc);

           // 生成Arc&lt;T&gt;
           Self::from_ptr(ptr)
       }
   }
}

//析构
unsafe impl&lt;#[may_dangle] T: ?Sized&gt; Drop for Arc&lt;T&gt; {
   fn drop(&amp;mut self) {
       //如果当前的strong不是1,则返回，fetch_xxx函数返回之前的值
       if self.inner().strong.fetch_sub(1, Release) != 1 {
           return;
       }

       acquire!(self.inner().strong);

       unsafe {
           //见下面代码的分析
           self.drop_slow();
       }
   }
}
impl &lt;T:?Sized&gt; Arc&lt;T&gt; {
   ...
   unsafe fn drop_slow(&amp;mut self) {
       // 对堆内存的变量做drop操作，注意，这里不释放堆内存，只是释放变量所有权
       unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };

       // 所有的strong会创建一个Weak，对这个Weak做drop操作
       drop(Weak { ptr: self.ptr });
   }
   ...
}

impl&lt;T: ?Sized&gt; Deref for Arc&lt;T&gt; {
   type Target = T;

   fn deref(&amp;self) -&gt; &amp;T {
       &amp;self.inner().data
   }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Weak&lt;T&gt;</code>的结构体及创建，析构方法：
在RC方法内部，Weak可以由<code>Weak{ptr:self_ptr}</code>直接创建，可见前面代码的例子，但要注意weak计数和Weak变量需要匹配</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl&lt;T&gt; Weak&lt;T&gt; {
   //创建一个空的Weak
   pub fn new() -&gt; Weak&lt;T&gt; {
       Weak { ptr: NonNull::new(usize::MAX as *mut ArcInner&lt;T&gt;).expect(&quot;MAX is not 0&quot;) }
   }
}

struct WeakInner&lt;'a&gt; {
   weak: &amp;'a atomic::AtomicUsize,
   strong: &amp;'a atomic::AtomicUsize,
}
//判断Weak是否为空的关联函数
pub(crate) fn is_dangling&lt;T: ?Sized&gt;(ptr: *mut T) -&gt; bool {
   let address = ptr as *mut () as usize;
   address == usize::MAX
}

impl &lt;T:?Sized&gt; Weak&lt;T&gt; {
   pub fn as_ptr(&amp;self) -&gt; *const T {
       let ptr: *mut ArcInner&lt;T&gt; = NonNull::as_ptr(self.ptr);

       if is_dangling(ptr) {
           ptr as *const T
       } else {
           //返回T类型变量的指针
           unsafe { ptr::addr_of_mut!((*ptr).data) }
       }
   }
   //会消费掉Weak，获取T类型变量指针，此指针以后需要重新组建Weak&lt;T&gt;,否则
   //堆内存中的ArcInner的weak会出现计数错误
   pub fn into_raw(self) -&gt; *const T {
       let result = self.as_ptr();
       mem::forget(self);
       result
   }
   
   //ptr是从into_raw得到的返回值
   pub unsafe fn from_raw(ptr: *const T) -&gt; Self {
       let ptr = if is_dangling(ptr as *mut T) {
           ptr as *mut ArcInner&lt;T&gt;
       } else {
           //需要从T类型的指针恢复ArcInner的指针
           let offset = unsafe { data_offset(ptr) };
           unsafe { (ptr as *mut ArcInner&lt;T&gt;).set_ptr_value((ptr as *mut u8).offset(-offset)) }
       };
       //ArcInner的weak的计数已经有了这个计数
       Weak { ptr: unsafe { NonNull::new_unchecked(ptr) } }
   }
   
   //创建一个WeakInner
   fn inner(&amp;self) -&gt; Option&lt;WeakInner&lt;'_&gt;&gt; {
       if is_dangling(self.ptr.as_ptr()) {
           None
       } else {
           //获取ArcInner&lt;T&gt;中strong和weak的引用
           Some(unsafe {
               let ptr = self.ptr.as_ptr();
               WeakInner { strong: &amp;(*ptr).strong, weak: &amp;(*ptr).weak }
           })
       }
   }
   //从Weak得到Arc, 如前所述，对Arc正确的打开方式应该是仅用Weak，然后适当的时候升级到Arc&lt;T&gt;
   //并且在使用完毕后就将Arc&lt;T&gt;生命周期终止掉，即这个函数返回Arc&lt;T&gt;生命周期最好仅在一个函数中。
   pub fn upgrade(&amp;self) -&gt; Option&lt;Arc&lt;T&gt;&gt; {
       //获取内部的ArcInner
       let inner = self.inner()?;
       //原子操作获得strong的值
       let mut n = inner.strong.load(Relaxed);
       
       //因为是多线程操作，所以此时n已经可能被改写，所以用loop
       //来确保n在已经改写的情况下正确
       loop {
           //如果strong是0，那堆内存已经被释放掉，不能再使用
           if n == 0 {
               return None;
           }

           // 不能多于最大的引用数目
           if n &gt; MAX_REFCOUNT {
               abort();
           }

           //以下确保在strong当前值是n的时候做加1操作
           match inner.strong.compare_exchange_weak(n, n + 1, Acquire, Relaxed) {
               //当前值为1且已经加1，生成Arc&lt;T&gt;
               Ok(_) =&gt; return Some(Arc::from_inner(self.ptr)), // null checked above
               //如果当前值不为n，则将n设置为当前值，进入下一轮循环。
               Err(old) =&gt; n = old,
           }
       }
   }
}

impl &lt;T:?Sized&gt; Arc&lt;T&gt; {
   ...

   //生成新的Weak&lt;T&gt;
   pub fn downgrade(this: &amp;Self) -&gt; Weak&lt;T&gt; {
       // 获取weak count.
       let mut cur = this.inner().weak.load(Relaxed);

       //要确定当前的weak count与上面取得一致
       loop {
           // 如果是usize::MAX，证明在创建过程中，等创建完毕后
           // 再获取一次
           if cur == usize::MAX {
               hint::spin_loop();
               cur = this.inner().weak.load(Relaxed);
               continue;
           }
           
           //确保在weak与当前值一致的情况下做原子操作，将weak加1
           match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {
               Ok(_) =&gt; {
                   // 确保不创建对不存在的变量的Weak
                   debug_assert!(!is_dangling(this.ptr.as_ptr()));
                   //创建Weak
                   return Weak { ptr: this.ptr };
               }
               //如果当前的值与取值不一致，将取值更换为当前值，再做一次循环
               Err(old) =&gt; cur = old,
           }
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>以上代码中，对于多线程的处理需要额外注意并理解。这是原子变量处理多线程的典型用法</p>
<p><code>Arc&lt;T&gt;</code>的其他方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> impl&lt;T: Clone&gt; Arc&lt;T&gt; {
    //Rc&lt;T&gt; 实际上是需要配合RefCell&lt;T&gt;来完成对堆内存的修改需求
    //下面的函数用了类似写时复制的方式，仅能在某些场景下使用
    pub fn make_mut(this: &amp;mut Self) -&gt; &amp;mut T {
        //判断strong的值是否为1，如果为1，则设置为0，以防止其他线程做修改 
        if this.inner().strong.compare_exchange(1, 0, Acquire, Relaxed).is_err() {
            // strong不为1，需要创建一个复制的Arc&lt;T&gt;变量
            let mut arc = Self::new_uninit();
            unsafe {
                let data = Arc::get_mut_unchecked(&amp;mut arc);
                (**this).write_clone_into_raw(data.as_mut_ptr());
                *this = arc.assume_init();
            }
        } else if this.inner().weak.load(Relaxed) != 1 {
            //当前为原strong为1且已经strong已经做了减1操作为0
            //那此时weak如果为1，证明没有多余的Weak&lt;T&gt;被派生
            //如果weak不为1，则证明有其他的Weak&lt;T&gt;存在，需要创建一个复制的Arc&lt;T&gt;

            //这里因为strong已经被减1，所以本线程已经没有Arc&lt;T&gt;，所以创建一个
            //Weak并由此变量的drop完成对weak计数的处理
            let _weak = Weak { ptr: this.ptr };

            // 创建一个新的复制的Arc&lt;T&gt;
            let mut arc = Self::new_uninit();
            unsafe {
                let data = Arc::get_mut_unchecked(&amp;mut arc);
                data.as_mut_ptr().copy_from_nonoverlapping(&amp;**this, 1);
                ptr::write(this, arc.assume_init());
            }
        } else {
            // strong及weak都是1，则恢复strong为1，直接使用当前的Arc&lt;T&gt;
            this.inner().strong.store(1, Release);
        }

        //返回&amp;mut T
        unsafe { Self::get_mut_unchecked(this) }
       
    }
 }
<span class="boring">}</span></code></pre></pre>
<p>上面的函数与<code>Rc&lt;T&gt;::make_mut()</code>有所不同，是因为原子变量的原因带来的，可以对比学习，更深刻的了解原子变量。 
Clone trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Clone for Arc&lt;T&gt; {
   fn clone(&amp;self) -&gt; Arc&lt;T&gt; {
       //增加一个strong计数
       let old_size = self.inner().strong.fetch_add(1, Relaxed);

       if old_size &gt; MAX_REFCOUNT {
           abort();
       }
       //从内部创建一个新的ARC&lt;T&gt;
       Self::from_inner(self.ptr)
   }
}

impl&lt;T: ?Sized&gt; Clone for Weak&lt;T&gt; {
   fn clone(&amp;self) -&gt; Weak&lt;T&gt; {
       if let Some(inner) = self.inner() {
           inner.inc_weak()
       }
       Weak { ptr: self.ptr }
   }
   fn clone(&amp;self) -&gt; Weak&lt;T&gt; {
       let inner = if let Some(inner) = self.inner() {
           inner
       } else {
           //inner不存在，直接创建一个Weak&lt;T&gt;
           return Weak { ptr: self.ptr };
       };
       //对weak计数加1
       let old_size = inner.weak.fetch_add(1, Relaxed);

       if old_size &gt; MAX_REFCOUNT {
           abort();
       }
       //创建Weak&lt;T&gt;
       Weak { ptr: self.ptr }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>对<code>Arc&lt;MaybeUninit&lt;T&gt;&gt;</code>初始化后assume_init实现方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Arc&lt;mem::MaybeUninit&lt;T&gt;&gt; {
    pub unsafe fn assume_init(self) -&gt; Arc&lt;T&gt; {
        //先用ManuallyDrop将self封装以便不对self做drop操作
        //然后取出内部的堆指针形成新的Arc&lt;T&gt;。
        Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Arc&lt;T&gt;</code>其他方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized&gt; Arc&lt;T&gt; {
    //相当于Arc&lt;T&gt;的leak函数
    pub fn into_raw(this: Self) -&gt; *const T {
        let ptr = Self::as_ptr(&amp;this);
        //把堆内存指针取出后，由调用代码负责释放，
        //本结构体要规避后继的释放操作
        mem::forget(this);
        ptr
    }

    //获得堆内存变量的指针，不会涉及安全问题,注意，这里ptr不是堆内存块的首地址，而是向后有偏移
    //因为ArcInner&lt;T&gt;采用C语言的内存布局，所以value在最后
    pub fn as_ptr(this: &amp;Self) -&gt; *const T {
        let ptr: *mut ArcInner&lt;T&gt; = NonNull::as_ptr(this.ptr);

        unsafe { ptr::addr_of_mut!((*ptr).value) }
    }

    //从堆内存T类型变量的指针重建Arc&lt;T&gt;，注意，这里的ptr一般是调用`Arc&lt;T&gt;::into_raw()获得的裸指针
    //ptr不是堆内存块首地址，需要减去strong和weak的内存大小
    pub unsafe fn from_raw(ptr: *const T) -&gt; Self {
        let offset = unsafe { data_offset(ptr) };

        // 减去偏移量，得到正确的ArcInner堆内存的首地址
        let rc_ptr =
            unsafe { (ptr as *mut ArcInner&lt;T&gt;).set_ptr_value((ptr as *mut u8).offset(-offset)) };

        unsafe { Self::from_ptr(rc_ptr) }
    }
<span class="boring">}</span></code></pre></pre>
<p>into_raw, from_raw要成对使用，否则就必须对这两个方法的内存有清晰的认知。否则极易出现问题。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span> 
<span class="boring">fn main() {
</span>    pub fn get_mut(this: &amp;mut Self) -&gt; Option&lt;&amp;mut T&gt; {
        if this.is_unique() { unsafe { Some(Arc::get_mut_unchecked(this)) } } else { None }
    }

    pub unsafe fn get_mut_unchecked(this: &amp;mut Self) -&gt; &amp;mut T {
        unsafe { &amp;mut (*this.ptr.as_ptr()).data }
    }

}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="linkedlistt代码分析"><a class="header" href="#linkedlistt代码分析"><code>LinkedList&lt;T&gt;</code>代码分析</a></h2>
<p>双向链表及其他数据结构的代码实现都是经典的实用性及训练性上佳的项目。本书对这些经典数据结构将只分析LinkedList<T>，重点分析RUST与其他语言的不同的部分。如果对LinkedList<T>彻底理解了，那其他数据结构也就不成为问题:
<code>LinkedList&lt;T&gt;</code>类型结构定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//这个定义表示LinkedList只支持固定长度的T类型
pub struct LinkedList&lt;T&gt; {
    //等同于直接用裸指针，使得代码最方便及简化，但需要对安全性额外投入精力
    //这个实际上与C语言相同，只是用Option增加了安全措施
    head: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    tail: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    len: usize,
    //marker说明本结构有一个Box&lt;Node&lt;T&gt;&gt;的所有权，并会负责调用其的drop
    //编译器应做好drop check, 检查与本结构相关的Box&lt;Node&lt;T&gt;&gt;的生命周期及drop
    //marker体现了RUST的独特点
    marker: PhantomData&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,
}

struct Node&lt;T&gt; {
    next: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    prev: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    element: T,
}
<span class="boring">}</span></code></pre></pre>
<p>Node方法代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Node&lt;T&gt; {
    fn new(element: T) -&gt; Self {
        Node { next: None, prev: None, element }
    }

    fn into_element(self: Box&lt;Self&gt;) -&gt; T {
        //消费了Box，堆内存被释放并将element拷贝到栈
        self.element
    }
}
<span class="boring">}</span></code></pre></pre>
<p>LinkedList的创建及简单的增减方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; LinkedList&lt;T&gt; {
    //创建一个空的LinkedList
    pub const fn new() -&gt; Self {
        LinkedList { head: None, tail: None, len: 0, marker: PhantomData }
    }
<span class="boring">}</span></code></pre></pre>
<p>在头部增加一个成员及删除一个成员：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //在首部增加一个节点
    pub fn push_front(&amp;mut self, elt: T) {
        //用box从堆内存申请一个节点，push_front_node见后面函数
        self.push_front_node(box Node::new(elt));
    }
    fn push_front_node(&amp;mut self, mut node: Box&lt;Node&lt;T&gt;&gt;) {
        // 整体全是不安全代码
        unsafe {
            node.next = self.head;
            node.prev = None;
            //需要将Box的堆内存leak出来使用。此块内存后继如果还在链表，需要由LinkedList负责drop.后面可以看到LinkedList的drop函数的处理。
            //如果pop出链表，那会重新用这里leak出来的NonNull&lt;Node&lt;T&gt;&gt;生成Box,再由Box释放
            let node = Some(Box::leak(node).into());

            match self.head {
                //空链表
                None =&gt; self.tail = node,
                // 目前采用NonNull&lt;Node&lt;T&gt;&gt;的方案，此处代码就很自然
                // 如果换成Box&lt;Node&lt;T&gt;&gt;的方案，这里就要类似如下:
                // 先用take将head复制到栈中创建的新变量，
                // 新变量的prev置为node
                // 用replace将新变量再复制回head。
                // 也注意，此处很容易也采用先take, 修改，然后replace的方案
                // 要注意规避Option导致的这个习惯,会造成两次内存拷贝，效率太低
                Some(head) =&gt; (*head.as_ptr()).prev = node,
            }
            
            self.head = node;
            self.len += 1;
        }
    }

    //从链表头部删除一个节点
    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        //Option&lt;T&gt;::map，此函数后，节点的堆内存已经被释放
        //变量被拷贝到栈内存
        self.pop_front_node().map(Node::into_element)
    }
    fn pop_front_node(&amp;mut self) -&gt; Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt; {
        //整体是unsafe
        self.head.map(|node| unsafe {
            //重新生成Box，以便后继可以释放堆内存
            let node = Box::from_raw(node.as_ptr());
            //更换head指针
            self.head = node.next;

            match self.head {
                None =&gt; self.tail = None,
                // push_front_node() 已经分析过
                Some(head) =&gt; (*head.as_ptr()).prev = None,
            }

            self.len -= 1;
            node
        })
    }
<span class="boring">}</span></code></pre></pre>
<p>在尾部增加一个成员及删除一个成员</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //从尾部增加一个节点
    pub fn push_back(&amp;mut self, elt: T) {
        //用box从堆内存申请一个节点
        self.push_back_node(box Node::new(elt));
    }

    fn push_back_node(&amp;mut self, mut node: Box&lt;Node&lt;T&gt;&gt;) {
        // 整体不安全
        unsafe {
            node.next = None;
            node.prev = self.tail;
            //需要将Box的堆内存leak出来使用。此块内存后继如果还在链表，需要由LinkedList负责drop.
            //如果pop出链表，那会重新用这里leak出来的NonNull&lt;Node&lt;T&gt;&gt;重新生成Box
            let node = Some(Box::leak(node).into());

            match self.tail {
                None =&gt; self.head = node,
                //前面代码已经有分析 
                Some(tail) =&gt; (*tail.as_ptr()).next = node,
            }

            self.tail = node;
            self.len += 1;
        }
    }

    //从尾端删除节点
    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.pop_back_node().map(Node::into_element)
    }

    fn pop_back_node(&amp;mut self) -&gt; Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt; {
        self.tail.map(|node| unsafe {
            //重新创建Box以便删除堆内存
            let node = Box::from_raw(node.as_ptr());
            self.tail = node.prev;

            match self.tail {
                None =&gt; self.head = None,
                
                Some(tail) =&gt; (*tail.as_ptr()).next = None,
            }

            self.len -= 1;
            node
        })
    }
    //删除一个节点，这个操作也是RUST比较独特的体现
    unsafe fn unlink_node(&amp;mut self, mut node: NonNull&lt;Node&lt;T&gt;&gt;) {
        //现在拥有node的所有权，
        let node = unsafe { node.as_mut() }; 

        match node.prev {
            //不能复制新的节点，注意这里的写法
            Some(prev) =&gt; unsafe { (*prev.as_ptr()).next = node.next },
            // node是head节点
            None =&gt; self.head = node.next,
        };

        match node.next {
            //不能获取next的所有权，只能是这个写法
            Some(next) =&gt; unsafe { (*next.as_ptr()).prev = node.prev },
            // node是tail节点
            None =&gt; self.tail = node.prev,
        };

        self.len -= 1;
    }   
    ...
}

//Drop
unsafe impl&lt;#[may_dangle] T&gt; Drop for LinkedList&lt;T&gt; {
    fn drop(&amp;mut self) {
        struct DropGuard&lt;'a, T&gt;(&amp;'a mut LinkedList&lt;T&gt;);

        impl&lt;'a, T&gt; Drop for DropGuard&lt;'a, T&gt; {
            fn drop(&amp;mut self) {
                //如果此函数后面的while循环出现panic，这里可以继续做释放
                //此处代码的存在应该是RUST标准库中隐藏比较深的bug导致
                while self.0.pop_front_node().is_some() {}
            }
        }

        while let Some(node) = self.pop_front_node() {
            let guard = DropGuard(self);
            //显式的drop 获取的Box&lt;Node&lt;T&gt;&gt;
            drop(node);
            //执行到此处，guard认为已经完成，不能再调用guard的drop
            mem::forget(guard);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上基本上说明了RUST的LinkedList的设计及代码的一些关键点。</p>
<p>用Iterator来对List进行访问，Iterator的相关结构代码如下：
into_iter()相关结构及方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//变量本身的Iterator的类型
pub struct IntoIter&lt;T&gt; {
    list: LinkedList&lt;T&gt;,
}

impl&lt;T&gt; IntoIterator for LinkedList&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;

    /// 对LinkedList&lt;T&gt; 做消费
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter { list: self }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        //从头部获取变量
        self.list.pop_front()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.list.len, Some(self.list.len))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>iter_mut()调用相关结构及方法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//可变引用的Iterator的类型
pub struct IterMut&lt;'a, T: 'a&gt; {
    head: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    tail: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    len: usize,
    //这个marker也标示了IterMut对LinkedList有一个可变引用
    //创建IterMut后，与之相关的LinkerList不能在被其他安全的代码修改
    marker: PhantomData&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl &lt;T&gt; LinkedList&lt;T&gt; {
    ...
    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { head: self.head, tail: self.tail, len: self.len, marker: PhantomData }
    }
    ...
}
impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a mut T&gt; {
        if self.len == 0 {
            None
        } else {
            //用Option::map简化代码
            self.head.map(|node| unsafe {
                // 保存首部成员
                let node = &amp;mut *node.as_ptr();
                // 删除首部成员
                self.len -= 1;
                self.head = node.next;
                // 返回可变引用，此处的生命周期如下：
                // 返回值生命周期小于self
                // self 生命周期小于 LinkedList
                &amp;mut node.element
            })
        }
    }

    ...
}

//不可变引用的Iterator的类型
pub struct Iter&lt;'a, T: 'a&gt; {
    head: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    tail: Option&lt;NonNull&lt;Node&lt;T&gt;&gt;&gt;,
    len: usize,
    //对生命周期做标识，也标识了一个对LinkedList的不可变引用
    marker: PhantomData&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; Clone for Iter&lt;'_, T&gt; {
    fn clone(&amp;self) -&gt; Self {
        //本书中第一次出现这个表述
        Iter { ..*self }
    }
}

//Iterator trait for Iter略
<span class="boring">}</span></code></pre></pre>
<p>LinkedList其他的代码略。
LinkedList当然有不使用unsafe方式的实现方法，但是unsafe的实现方式最简化，效率最高。且unsafe的代码量并不高，可控性很强。盲目的排斥unsafe实际上也是一件不RUST的事。</p>
<h2 id="string-类型分析"><a class="header" href="#string-类型分析">String 类型分析</a></h2>
<p>String结构定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Vec&lt;u8&gt;</code>和String的关系可以与[u8]与&amp;str的关系相对比。整个String实际上是一个大的
Adapter 模式，针对Vec<u8>, [u8], &amp;str三者做组合
String的创建函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl String {
     pub const fn new() -&gt; String {
        String { vec: Vec::new() }
    }

    //将str内容加到String的尾部
    pub fn push_str(&amp;mut self, string: &amp;str) {
        //adapter，直接用Vec::extend_from_slice([u8])
        //具体的细节请参考Vec那节
        self.vec.extend_from_slice(string.as_bytes())
    }
    ...
}

impl ToOwned for str {
    type Owned = String;
    fn to_owned(&amp;self) -&gt; String {
        //这里是个adapter模式，首先从用self.as_bytes()获取[u8], 然后用通用的[u8].to_owned()完成
        //to_owned逻辑,随后从Vec[u8]生成String
        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
    }

    
    fn clone_into(&amp;self, target: &amp;mut String) {
        //adapter模式，需要先得到Vec&lt;u8&gt;,因为into_bytes会消费掉String。
        //target不支持，所以需要用take先把所有权转移出来，然后获取Vec&lt;u8&gt;
        //这是RUST的一个通用的技巧
        let mut b = mem::take(target).into_bytes();
        //通用的[u8].clone_into
        self.as_bytes().clone_into(&amp;mut b);
        //把新的String赋给原先的地址
        *target = unsafe { String::from_utf8_unchecked(b) }
    }
}

impl From&lt;&amp;str&gt; for String {
    fn from(s: &amp;str) -&gt; String {
        s.to_owned()
    }
} 


<span class="boring">}</span></code></pre></pre>
<p>解引用方法代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ops::Deref for String {
    type Target = str;

    fn deref(&amp;self) -&gt; &amp;str {
        //&amp;self.vec会被强转为&amp;[u8]
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}

impl ops::DerefMut for String {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut str {
        //这里直接用&amp;mut self.vec应该也可以，会被强转成&amp;mut [u8]
        unsafe { str::from_utf8_unchecked_mut(&amp;mut *self.vec) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>运算符重载方法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ops::Index&lt;ops::RangeFull&gt; for String {
    type Output = str;

    fn index(&amp;self, _index: ops::RangeFull) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}
impl ops::Index&lt;ops::Range&lt;usize&gt;&gt; for String {
    type Output = str;

    fn index(&amp;self, index: ops::Range&lt;usize&gt;) -&gt; &amp;str {
        //先用Index&lt;RangeFull&gt;取&amp;str, 然后用Index&lt;Range&gt;取子串
        &amp;self[..][index]
    }
}
impl Borrow&lt;str&gt; for String {
    fn borrow(&amp;self) -&gt; &amp;str {
        //自动解引用, 利用Index&lt;RangeFull&gt;完成，代码最简
        &amp;self[..]
    }
}

impl BorrowMut&lt;str&gt; for String {
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut str {
        //自动解引用, 利用Index&lt;RangeFull&gt;完成，代码最简
        &amp;mut self[..]
    }
}

impl Add&lt;&amp;str&gt; for String {
    type Output = String;

    fn add(mut self, other: &amp;str) -&gt; String {
        self.push_str(other);
        self
    }
}

impl AddAssign&lt;&amp;str&gt; for String {
    fn add_assign(&amp;mut self, other: &amp;str) {
        self.push_str(other);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>字符串数组连接方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//此函数主要简化多个字符串的连接
impl&lt;S: Borrow&lt;str&gt;&gt; Concat&lt;str&gt; for [S] {
    type Output = String;

    fn concat(slice: &amp;Self) -&gt; String {
        //见下个方法分析
        Join::join(slice, &quot;&quot;)
    }
}

impl&lt;S: Borrow&lt;str&gt;&gt; Join&lt;&amp;str&gt; for [S] {
    type Output = String;

    fn join(slice: &amp;Self, sep: &amp;str) -&gt; String {
        unsafe { String::from_utf8_unchecked(join_generic_copy(slice, sep.as_bytes())) }
    }
}

macro_rules! specialize_for_lengths {
    ($separator:expr, $target:expr, $iter:expr; $($num:expr),*) =&gt; {{
        let mut target = $target;
        let iter = $iter;
        let sep_bytes = $separator;
        match $separator.len() {
            $(
                // 如果分隔切片长度符合预设值
                $num =&gt; {
                    for s in iter {
                        //拷贝分隔切片到目的切片，且更新目的切片
                        copy_slice_and_advance!(target, sep_bytes);
                        //拷贝内容切片
                        let content_bytes = s.borrow().as_ref();
                        copy_slice_and_advance!(target, content_bytes);
                    }
                },
            )*
            _ =&gt; {
                // 如果分隔切片长度不符合预设值，实质也做与上段代码同样的操作
                for s in iter {
                    copy_slice_and_advance!(target, sep_bytes);
                    let content_bytes = s.borrow().as_ref();
                    copy_slice_and_advance!(target, content_bytes);
                }
            }
        }
        target
    }}
}

//完成一个切片拷贝后，切片向前到未拷贝的开始处
macro_rules! copy_slice_and_advance {
    ($target:expr, $bytes:expr) =&gt; {
        let len = $bytes.len();
        //将目的切片切分成两段，首段为待拷贝空间，尾端为未拷贝空间
        let (head, tail) = { $target }.split_at_mut(len);
        head.copy_from_slice($bytes);
        $target = tail;
    };
}

//将若干个T类型的切片连接到一起形成一个基于T类型的切片
fn join_generic_copy&lt;B, T, S&gt;(slice: &amp;[S], sep: &amp;[T]) -&gt; Vec&lt;T&gt;
where
    T: Copy, //最基础的成员类型
    B: AsRef&lt;[T]&gt; + ?Sized, //可以表示为最基础成员的切片引用
    S: Borrow&lt;B&gt;, //以B类型作为操作类型，所以S应该能borrow成B类型的引用
{
    let sep_len = sep.len();
    let mut iter = slice.iter();

    // 第一个成员头部没有间隔
    let first = match iter.next() {
        Some(first) =&gt; first,
        None =&gt; return vec![],
    };

    //计算iter中所有成员的长度，并加上间隔长度乘剩余成员的数目
    //得到总的长度。
    //从这个函数能够发现rust的链式编程的能力
    
    let reserved_len = sep_len
        .checked_mul(iter.len())//这里去掉了slice的首个成员，
        .and_then(|n| {
            //这里的重新重新生成iter，计算了所有的slice的所有成员
            slice.iter().map(|s| s.borrow().as_ref().len()).try_fold(n, usize::checked_add)
        })
        .expect(&quot;attempt to join into collection with len &gt; usize::MAX&quot;);

    // 创建一个有足够容量的Vec
    let mut result = Vec::with_capacity(reserved_len);
    debug_assert!(result.capacity() &gt;= reserved_len);
    //完成first的内容拷贝
    result.extend_from_slice(first.borrow().as_ref());

    unsafe {
        let pos = result.len();
        let target = result.get_unchecked_mut(pos..reserved_len);
        
        //完成对剩余成员及分隔符拷贝到result
        let remain = specialize_for_lengths!(sep, target, iter; 0, 1, 2, 3, 4);

        //完成长度拷贝。
        let result_len = reserved_len - remain.len();
        result.set_len(result_len);
    }
    result
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rust的fmt相关代码"><a class="header" href="#rust的fmt相关代码">RUST的fmt相关代码</a></h2>
<p>fmt给出RUST实现可变参数的解决方案。<br />
alloc库中给出了format宏，完成对可变参数的格式化输出。<br />
format宏代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! format {
    ($($arg:tt)*) =&gt; {{
        //format宏调用后继的format函数，并由format_args宏将可变参数完成参数转换
        let res = $crate::fmt::format($crate::__export::format_args!($($arg)*));
        res
    }}
}
<span class="boring">}</span></code></pre></pre>
<p>format_args宏将可变参数转换成Arguments类型变量，可以作为RUST的可变参数支持的经典案列。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//因为安全的愿因，下宏由编译器实现，
//format_args宏对输入的字符串和参数分析后返回类型为Arguments的变量，
macro_rules! format_args {
    ($fmt:expr) =&gt; {{ /* compiler built-in */ }};
    ($fmt:expr, $($args:tt)*) =&gt; {{ /* compiler built-in */ }};
}
//Arguments类型结构
pub struct Arguments&lt;'a&gt; {
    // 存放需要格式化的参数之间的字符串，对应于每一个格式化参数
    // 此字符串可以为空
    pieces: &amp;'a [&amp;'static str],

    // 针对每个格式化参数的格式描述
    fmt: Option&lt;&amp;'a [rt::v1::Argument]&gt;,

    // 每个参数，以及生成参数的格式化字符串的函数
    args: &amp;'a [ArgumentV1&lt;'a&gt;],
}
<span class="boring">}</span></code></pre></pre>
<p>format_args生成Arguments举例如下：
format_args!(&quot;ab {:b} cd {:p}&quot;, 1, 2) 
结果的Arguments结构中：<br />
其中<strong>pieces</strong>有两个成员，为:<code>&quot;ab &quot;, &quot; cd &quot; </code>, 注意字符串中的空格
fmt有两个成员，为： </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //具体结构见后继的定义
    { postion:0, 
      format:{align:UnKnown, flags:0, precision:Implied, width:Implied}}, 
    { position:1, 
      format:{align:UnKnown, flags:4, precision:Implied, width:Implied}}
<span class="boring">}</span></code></pre></pre>
<p>其中<strong>args</strong>有两个成员为: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //具体的结构见后继的定义
    {1, core::fmt::num::Binary::fmt()}, 
    {2, core::fmt::num::Pointer::fmt()}
<span class="boring">}</span></code></pre></pre>
<p>fmt及args相关的类型定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//rt::v1::Argument
//对非默认格式化参数，每个参数format_args!宏会生成一个Argument变量
pub struct Argument {
    //表示参数的在Arguments中的序号，
    pub position: usize,
    //格式参数，用于格式化输出
    pub format: FormatSpec,
}
pub struct FormatSpec {
    //格式化时需要填充的字符
    pub fill: char,
    pub align: Alignment,
    //FlagV1 按位赋值
    pub flags: u32,
    pub precision: Count,
    pub width: Count,
}

//上面结构中的辅助类型
pub enum Alignment {
    /// 左端对齐
    Left,
    /// 右端对齐
    Right,
    /// 中间对齐
    Center,
    /// 没有对齐
    Unknown,
}

//flags 的位, 
enum FlagV1 {
    SignPlus, //0
    SignMinus,  //1
    Alternate,  //2
    SignAwareZeroPad, //3
    DebugLowerHex,  //4
    DebugUpperHex,  //5
}

pub enum Count {
    /// 字面量的值
    Is(usize),
    /// Specified using `$` and `*` syntaxes, stores the index into `args`
    Param(usize),
    /// Not specified
    Implied,
}

//以下结构可认为是针对每一个参数，都有一个格式化输出的函数与其对应
pub struct ArgumentV1&lt;'a&gt; {
    //类似C语言的va_arg的返回类型，可以认为是void *
    value: &amp;'a Opaque,
    //针对value的格式化输出函数
    formatter: fn(&amp;Opaque, &amp;mut Formatter&lt;'_&gt;) -&gt; Result,
}

//上述结构中的类型
//类似void
extern &quot;C&quot; {
    type Opaque;
}

//每个格式化参数需要生成一个Formatter变量
//用于存放格式化信息以指示如和生成参数的格式化字符串
//生成的格式化字符串应输出到哪里
pub struct Formatter&lt;'a&gt; {
    //以下到precision都是由format_arg!宏在发现参数要求非默认的格式化时
    //生成的。
    flags: u32,
    fill: char,
    align: rt::v1::Alignment,
    width: Option&lt;usize&gt;,
    precision: Option&lt;usize&gt;,
    
    //格式化字符串输出的缓存，当前一般就是String
    buf: &amp;'a mut (dyn Write + 'a),
}
<span class="boring">}</span></code></pre></pre>
<p>format_args宏完成Arguments的生成后，
下面的format函数将之作为参数完成格式化字符串生成.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Arguments包含了本输出中所有的需要格式化的参数
pub fn format(args: Arguments&lt;'_&gt;) -&gt; string::String {
    //估计了输出字符串长度，尽量减少堆内存的重新申请
    let capacity = args.estimated_capacity();
    //申请足够空间的字符串
    let mut output = string::String::with_capacity(capacity);
    //根据输入的格式化参数，完成对参数的格式化字符串输出
    output.write_fmt(args).expect(&quot;a formatting trait implementation returned an error&quot;);
    output
}
<span class="boring">}</span></code></pre></pre>
<p>使用了String::write_fmt, 是Write trait 的方法，String实现了此trait，代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Write {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; Result;
    fn write_char(&amp;mut self, c: char) -&gt; Result {
        self.write_str(c.encode_utf8(&amp;mut [0; 4]))
    }

    //格式化的输出
    fn write_fmt(mut self: &amp;mut Self, args: Arguments&lt;'_&gt;) -&gt; Result {
        //见后面的write函数分析
        write(&amp;mut self, args)
    }
}
// String的Write trait实现
impl fmt::Write for String {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        self.push_str(s);
        Ok(())
    }

    fn write_char(&amp;mut self, c: char) -&gt; fmt::Result {
        self.push(c);
        Ok(())
    }
}

//Formatter的Write trait实现
impl Write for Formatter&lt;'_&gt; {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; Result {
        self.buf.write_str(s)
    }

    fn write_char(&amp;mut self, c: char) -&gt; Result {
        self.buf.write_char(c)
    }

    fn write_fmt(&amp;mut self, args: Arguments&lt;'_&gt;) -&gt; Result {
        write(self.buf, args)
    }
}

//这里是Display, Debug常用的另外一个格式化输出的宏write!
macro_rules! write {
    ($dst:expr, $($arg:tt)*) =&gt; {
        //$dst即&amp;mut dyn Write
        $dst.write_fmt($crate::format_args!($($arg)*))
    };
}

//此函数是格式化输入的核心函数，output当前可暂时认为是String
pub fn write(output: &amp;mut dyn Write, args: Arguments&lt;'_&gt;) -&gt; Result {
    //创建格式化参数的变量,buf设置为output
    let mut formatter = Formatter::new(output);
    let mut idx = 0;

    match args.fmt {
        //如果所有参数都是默认格式输出
        None =&gt; {
            // 对所有的参数进行轮询
            for (i, arg) in args.args.iter().enumerate() {
                //获取该参数前需要输出的字符串
                let piece = unsafe { args.pieces.get_unchecked(i) };
                if !piece.is_empty() {
                    //向output输出获取的字符串
                    formatter.buf.write_str(*piece)?;
                }
                //调用每个参数的格式化输出函数，向formatter输出格式化参数字符串
                //此时formatter所有的成员都是默认
                (arg.formatter)(arg.value, &amp;mut formatter)?;
                idx += 1;
            }
        }
        //如果有参数不是默认格式输出
        Some(fmt) =&gt; {
            // 对所有参数进行轮询
            for (i, arg) in fmt.iter().enumerate() {
                // 获取该参数前应该输出的字符串
                let piece = unsafe { args.pieces.get_unchecked(i) };
                if !piece.is_empty() {
                    //向output输出获取的字符串
                    formatter.buf.write_str(*piece)?;
                }
                //生成格式并输出格式化参数字符串
                unsafe { run(&amp;mut formatter, arg, args.args) }?;
                idx += 1;
            }
        }
    }

    // 如果还有额外的字符串
    if let Some(piece) = args.pieces.get(idx) {
        //输出该字符串
        formatter.buf.write_str(*piece)?;
    }

    Ok(())
}

//非默认个数输出的格式化字符串输出函数
unsafe fn run(fmt: &amp;mut Formatter&lt;'_&gt;, arg: &amp;rt::v1::Argument, args: &amp;[ArgumentV1&lt;'_&gt;]) -&gt; Result {
    //根据格式化参数的格式完成fmt的格式参数设置
    fmt.fill = arg.format.fill;
    fmt.align = arg.format.align;
    fmt.flags = arg.format.flags;
    unsafe {
        fmt.width = getcount(args, &amp;arg.format.width);
        fmt.precision = getcount(args, &amp;arg.format.precision);
    }

    debug_assert!(arg.position &lt; args.len());
    //获取格式化参数
    let value = unsafe { args.get_unchecked(arg.position) };

    // 真正的进行格式化
    (value.formatter)(value.value, fmt)
}


impl&lt;'a&gt; Arguments&lt;'a&gt; {
    /// format_args!()完成字符串和参数解析后，如果都是默认格式，用下面的函数创建
    /// Arguments变量
    pub const fn new_v1(pieces: &amp;'a [&amp;'static str], args: &amp;'a [ArgumentV1&lt;'a&gt;]) -&gt; Arguments&lt;'a&gt; {
        if pieces.len() &lt; args.len() || pieces.len() &gt; args.len() + 1 {
            panic!(&quot;invalid args&quot;);
        }
        Arguments { pieces, fmt: None, args }
    }

    //format_args!()完成字符串和参数解析后，如果格式化格式不是默认格式，用下面的函数创建Arguments
    pub const fn new_v1_formatted(
        pieces: &amp;'a [&amp;'static str],
        args: &amp;'a [ArgumentV1&lt;'a&gt;],
        fmt: &amp;'a [rt::v1::Argument],
        _unsafe_arg: UnsafeArg,
    ) -&gt; Arguments&lt;'a&gt; {
        Arguments { pieces, fmt: Some(fmt), args }
    }

    //预估格式化后字符串长度
    pub fn estimated_capacity(&amp;self) -&gt; usize {
        //计算所有除格式化参数外的长度
        let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();

        if self.args.is_empty() {
            pieces_length
        } else if !self.pieces.is_empty() &amp;&amp; self.pieces[0].is_empty() &amp;&amp; pieces_length &lt; 16 {
            //如果字符串以格式化参数作为起始且除格式化以外的字符小于16
            0
        } else {
            //其他情况，为了防止额外申请堆内存，事先申请更多的内存
            pieces_length.checked_mul(2).unwrap_or(0)
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>以输出为二进制的isize的格式化为例，分析一下格式化具体的实现类型结构及方法：
首先，fmt::Binary负责二进制格式化trait </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//对于不同进制的格式化实现trait
macro_rules! integer {
    ($Int:ident, $Uint:ident) =&gt; {
        int_base! { fmt::Binary   for $Int as $Uint  -&gt; Binary }
        int_base! { fmt::Octal    for $Int as $Uint  -&gt; Octal }
        int_base! { fmt::LowerHex for $Int as $Uint  -&gt; LowerHex }
        int_base! { fmt::UpperHex for $Int as $Uint  -&gt; UpperHex }

        int_base! { fmt::Binary   for $Uint as $Uint -&gt; Binary }
        int_base! { fmt::Octal    for $Uint as $Uint -&gt; Octal }
        int_base! { fmt::LowerHex for $Uint as $Uint -&gt; LowerHex }
        int_base! { fmt::UpperHex for $Uint as $Uint -&gt; UpperHex }
    };
}
//在isize,usize实现上述的格式化trait
integer! { isize, usize }

//int_base的宏定义
macro_rules! int_base {
    (fmt::$Trait:ident for $T:ident as $U:ident -&gt; $Radix:ident) =&gt; {
        impl fmt::$Trait for $T {
            fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
                //具体的函数
                $Radix.fmt_int(*self as $U, f)
            }
        }
    };
}

//int_base宏中的$Radix的类型结构定义
struct Binary;

//fmt_int定义在下面的trait中
//此trait实现不同进制的整数的格式化通用操作
trait GenericRadix: Sized {
    ///进制 
    const BASE: u8;

    /// 格式化的前缀字符串.
    const PREFIX: &amp;'static str;

    /// x为十进制的数字，返回值是self进制的x的字符的编码数值 
    fn digit(x: u8) -&gt; u8;

    /// 将某一个数值按输入的格式化变量的要求进行格式化.
    fn fmt_int&lt;T: DisplayInt&gt;(&amp;self, mut x: T, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        //首先获取足够的字符串空间来存放格式化后的内容
        //对于二进制，需要128个字节
        let zero = T::zero();
        let is_nonnegative = x &gt;= zero;
        let mut buf = [MaybeUninit::&lt;u8&gt;::uninit(); 128];
        let mut curr = buf.len();
        //见后继DisplayInt的分析
        let base = T::from_u8(Self::BASE);
        if is_nonnegative {
            //从最低位到最高位填充buf
            for byte in buf.iter_mut().rev() {
                //余值填入当前的buf
                let n = x % base; // Get the current place value.
                //减掉已经填充的值
                x = x / base; // Deaccumulate the number.
                //将值转换为字符并写入buf
                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.
                curr -= 1;
                if x == zero {
                    // No more digits left to accumulate.
                    break;
                };
            }
        } else {
            //仍然从最低位到最高位
            for byte in buf.iter_mut().rev() {
                //获得当前位的值,负数
                let n = zero - (x % base); // Get the current place value.
                x = x / base; // Deaccumulate the number.
                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.
                curr -= 1;
                if x == zero {
                    // No more digits left to accumulate.
                    break;
                };
            }
        }
        //获取有意义的切片
        let buf = &amp;buf[curr..];
        //生成utf-8字符串
        let buf = unsafe {
            str::from_utf8_unchecked(slice::from_raw_parts(
                MaybeUninit::slice_as_ptr(buf),
                buf.len(),
            ))
        };
        //Formatter会根据参数生成符合格式化的其他填充内容
        f.pad_integral(is_nonnegative, Self::PREFIX, buf)
    }
}

//以下为对isize及usize实现GenericRadix trait的代码
macro_rules! radix {
    ($T:ident, $base:expr, $prefix:expr, $($x:pat =&gt; $conv:expr),+) =&gt; {
        impl GenericRadix for $T {
            const BASE: u8 = $base;
            const PREFIX: &amp;'static str = $prefix;
            fn digit(x: u8) -&gt; u8 {
                match x {
                    $($x =&gt; $conv,)+
                    x =&gt; panic!(&quot;number not in the range 0..={}: {}&quot;, Self::BASE - 1, x),
                }
            }
        }
    }
}

//这里只列出二进制，其他进制略
radix! { Binary,    2, &quot;0b&quot;, x @  0 ..=  1 =&gt; b'0' + x }

//Formatter的其他方法如下：
impl&lt;'a&gt; Formatter&lt;'a&gt; {
    //对整形的格式化填充内容，在基础内容的基础上填充格式化需要的其他字符，完成对类型的格式化输出
    pub fn pad_integral(&amp;mut self, is_nonnegative: bool, prefix: &amp;str, buf: &amp;str) -&gt; Result {
        //获取基础内容字符串的长度
        //作为计算总长度的基础
        let mut width = buf.len();

        //是否需要正负符号
        let mut sign = None;
        if !is_nonnegative {
            //负数需要符号
            sign = Some('-');
            //输出的字符串长度+1
            width += 1;
        } else if self.sign_plus() {
            //格式化要求输出+号
            sign = Some('+');
            width += 1;
        }

        let prefix = if self.alternate() {
            //要求输出进制前缀
            width += prefix.chars().count();
            Some(prefix)
        } else {
            None
        };

        // 将符号及进制前缀输出
        fn write_prefix(f: &amp;mut Formatter&lt;'_&gt;, sign: Option&lt;char&gt;, prefix: Option&lt;&amp;str&gt;) -&gt; Result {
            if let Some(c) = sign {
                f.buf.write_char(c)?;
            }
            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }
        }

        match self.width {
            //格式化参数中没有对字宽有要求
            None =&gt; {
                //写入符号及前缀
                write_prefix(self, sign, prefix)?;
                //写入基本内容
                self.buf.write_str(buf)
            }
            //格式化参数有最小字宽要求,且当前字宽已经大于
            //最小字宽
            Some(min) if width &gt;= min =&gt; {
                write_prefix(self, sign, prefix)?;
                self.buf.write_str(buf)
            }
            //格式化参数有最小字宽要求，当前字宽小于最小字宽
            //格式化参数规定填充0
            Some(min) if self.sign_aware_zero_pad() =&gt; {
                //不管输入的格式化参数中填充属性是什么，改变成为0
                //因为后继要恢复，replace恰如其分
                let old_fill = crate::mem::replace(&amp;mut self.fill, '0');
                //不管输入的格式化参数中对齐属性是什么，改变成为右侧对齐
                let old_align = crate::mem::replace(&amp;mut self.align, rt::v1::Alignment::Right);
                //写入符号和前缀
                write_prefix(self, sign, prefix)?;
                //填充min-width个0，右侧对齐
                //如果随后还要pading,则在post_padding返回
                //padding方法见后继分析
                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;
                //写入基本内容
                self.buf.write_str(buf)?;
                //继续完成padding
                post_padding.write(self)?;
                //恢复格式化参数中填充属性及对齐属性内容
                self.fill = old_fill;
                self.align = old_align;
                Ok(())
            }
            // 格式化有最小字宽要求，当前字宽小于最小字宽，
            // 填充为空
            Some(min) =&gt; {
                //先进性填充
                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;
                //写入符号及前缀
                write_prefix(self, sign, prefix)?;
                //写入基本内容
                self.buf.write_str(buf)?;
                //继续完成padding
                post_padding.write(self)
            }
        }
    }

    //完成格式化中的填充功能
    pub(crate) fn padding(
        &amp;mut self,
        padding: usize,
        default: rt::v1::Alignment,
    ) -&gt; result::Result&lt;PostPadding, Error&gt; {
        let align = match self.align {
            rt::v1::Alignment::Unknown =&gt; default,
            _ =&gt; self.align,
        };

        //确定基础内容之前padding和之后padding的字符数目
        let (pre_pad, post_pad) = match align {
            rt::v1::Alignment::Left =&gt; (0, padding),
            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown =&gt; (padding, 0),
            rt::v1::Alignment::Center =&gt; (padding / 2, (padding + 1) / 2),
        };

        //完成基础内容之前的padding输出
        for _ in 0..pre_pad {
            self.buf.write_char(self.fill)?;
        }

        //创建基础内容之后padding的结构
        Ok(PostPadding::new(self.fill, post_pad))
    }

}

//PostPadding实现，在格式化内容基础内容之后进行填充
pub(crate) struct PostPadding {
    //填充字符
    fill: char,
    //填充字符数目
    padding: usize,
}

impl PostPadding {
    fn new(fill: char, padding: usize) -&gt; PostPadding {
        PostPadding { fill, padding }
    }

    pub(crate) fn write(self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        //输出padding内容
        for _ in 0..self.padding {
            f.buf.write_char(self.fill)?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上是格式化输出的代码基本脉络，格式化输出还有很多其他代码，请读者参考这个脉络自行研究</p>
<p>对输出做格式化是非常复杂的可变参数支持的例子。从对以上的代码分析，在RUST支持可变参数的途径：</p>
<ol>
<li>首先定义一个支持可变参数的宏，例如foramt_args宏，这个宏将可变参数转变成一个数据结构，数据结构需要根据需要进行设计。</li>
<li>根据数据结构设计方法或函数。</li>
</ol>
<p>Vec<T>中的vec！宏也是一个典型的可变参数实现，但其用途较单纯，因此也非常简单。可变参数是非常具有直观性及方便的语法。写一些库的时候需要经常用到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="茶歇"><a class="header" href="#茶歇">茶歇</a></h1>
<p>前面章节已经基本把core库及alloc库分析完毕。这两个库是不依赖于操作系统的。<br />
后继主要分析的std库，即在library/std/src目录下的代码，将紧密的与操作系统发生关联。<br />
C程序员开发一个大型的跨操作系统的应用时。在操作系统的C标准库的基础上实现一个适配层，屏蔽不同操作系统的
C标准库的差异是必须的一个工作。<br />
RUST的标准库也同样，在library/std/src/sys; library/std/src/os下实现了对不同操作系统的适配层。这一适配层完成的工作：</p>
<ol>
<li>定义RUST本身对于操作系统的统一的类型结构，方法及函数。提供给标准库其他模块使用。</li>
<li>将1中定义适配按照操作系统完成对系统调用的类型，函数的适配。 </li>
</ol>
<p>RUST适配操作系统调用的难度在于要将操作系统的资源及操作转换为适合RUST的所有权，借用及生命周期概念的类型及操作。<br />
因为操作系统的系统调用基本上都是C语言，RUST设计了非常方便及简单的与C的交互机制，RUST与C的交互类似于C++与C的交互，几乎是无缝的融合。而在操作系统适配层这个层面，与其说是RUST程序，不如说是RUST语法的C程序。C程序员感觉到十分的熟悉和亲切。</p>
<p>在适配层之上，RUST按照自身语法的要求，对适配层的实现做了若干扩展。如针对RUST全局静态变量的扩展。这一部分代码放在library/std/src/syscommon 目录下。</p>
<p>操作系统的适配层提供的结构显然还太过于底层及复杂，RUST在此基础上实现了更符合现代语言的类型结构，方法，函数，作为标准库的外界接口提供给RUST的程序员。</p>
<p>后继分析如下进行：</p>
<ol>
<li>按照操作系统的内存管理，文件描述符，进程/线程管理，进程/线程间通信，IO, 网络，文件, 时间，异步编程，杂项的顺序做分析</li>
<li>分析先给出RUST对操作系统适配层及适配层扩展实现，主要给出linux的相关实现代码摘要分析。适当的给一下wasi的代码分析。</li>
<li>RUST在2的基础上实现的标准库外部接口。</li>
</ol>
<h1 id="rust中与c语言互通"><a class="header" href="#rust中与c语言互通">RUST中与C语言互通</a></h1>
<p>因为涉及到大量的C语言库函数的调用，所以，我们首先要搞清楚如何与C语言互操作的内容。RUST与C语言互操作，主要就是完成RUST到C语言的类型转换，以及函数调用语义的实现。<br />
代码路径： library/std/src/ffi/<em>.</em></p>
<h2 id="c语言类型定义适配"><a class="header" href="#c语言类型定义适配">C语言类型定义适配</a></h2>
<p>代码路径：library/core/ffi/mod.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! type_alias_no_nz {
    {
      $Docfile:tt, $Alias:ident = $Real:ty;
      $( $Cfg:tt )*
    } =&gt; {
        #[doc = include_str!($Docfile)]
        $( $Cfg )*
        #[unstable(feature = &quot;core_ffi_c&quot;, issue = &quot;94501&quot;)]
        pub type $Alias = $Real;
    }
}

macro_rules! type_alias {
    {
      $Docfile:tt, $Alias:ident = $Real:ty, $NZAlias:ident = $NZReal:ty;
      $( $Cfg:tt )*
    } =&gt; {
        type_alias_no_nz! { $Docfile, $Alias = $Real; $( $Cfg )* }

        #[doc = concat!(&quot;Type alias for `NonZero` version of [`&quot;, stringify!($Alias), &quot;`]&quot;)]
        #[unstable(feature = &quot;raw_os_nonzero&quot;, issue = &quot;82363&quot;)]
        $( $Cfg )*
        pub type $NZAlias = $NZReal;
    }
}

//以下的定义，对所有C语言的类型以&quot;c_xxxx&quot;来命名，并用类型别名的形式定义为RUST的类型
//以下做了简化，仅针对linux操作系统
type_alias! { &quot;c_char.md&quot;, c_char = c_char_definition::c_char, NonZero_c_char = c_char_definition::NonZero_c_char;
type_alias! { &quot;c_schar.md&quot;, c_schar = i8, NonZero_c_schar = NonZeroI8; }
type_alias! { &quot;c_uchar.md&quot;, c_uchar = u8, NonZero_c_uchar = NonZeroU8; }
type_alias! { &quot;c_short.md&quot;, c_short = i16, NonZero_c_short = NonZeroI16; }
type_alias! { &quot;c_ushort.md&quot;, c_ushort = u16, NonZero_c_ushort = NonZeroU16; }
type_alias! { &quot;c_int.md&quot;, c_int = i32, NonZero_c_int = NonZeroI32; }
type_alias! { &quot;c_uint.md&quot;, c_uint = u32, NonZero_c_uint = NonZeroU32; }
type_alias! { &quot;c_long.md&quot;, c_long = i32, NonZero_c_long = NonZeroI32;
type_alias! { &quot;c_ulong.md&quot;, c_ulong = u32, NonZero_c_ulong = NonZeroU32;
type_alias! { &quot;c_longlong.md&quot;, c_longlong = i64, NonZero_c_longlong = NonZeroI64; }
type_alias! { &quot;c_ulonglong.md&quot;, c_ulonglong = u64, NonZero_c_ulonglong = NonZeroU64; }
type_alias_no_nz! { &quot;c_float.md&quot;, c_float = f32; }
type_alias_no_nz! { &quot;c_double.md&quot;, c_double = f64; 

pub type c_size_t = usize;
pub type c_ptrdiff_t = isize;
pub type c_ssize_t = isize;

mod c_char_definition {
    cfg_if! {
        if #[cfg(any(
            all(
                target_os = &quot;linux&quot;,
                any(
                    target_arch = &quot;aarch64&quot;,
                    target_arch = &quot;arm&quot;,
                    target_arch = &quot;powerpc&quot;,
                    target_arch = &quot;powerpc64&quot;,
                    target_arch = &quot;s390x&quot;,
                    target_arch = &quot;riscv64&quot;,
                    target_arch = &quot;riscv32&quot;
                )
            ),
            all(target_os = &quot;fuchsia&quot;, target_arch = &quot;aarch64&quot;)
        ))] {
            pub type c_char = u8;
            pub type NonZero_c_char = crate::num::NonZeroU8;
        } 
    }        
}
//以下是针对C语言的可变参数 VA_ARG给出的相关RUST匹配
pub enum c_void {
    __variant1,
    __variant2,
}

pub struct VaListImpl&lt;'f&gt; {
    gp_offset: i32,
    fp_offset: i32,
    overflow_arg_area: *mut c_void,
    reg_save_area: *mut c_void,
    _marker: PhantomData&lt;&amp;'f mut &amp;'f c_void&gt;,
}

pub struct VaList&lt;'a, 'f: 'a&gt; {
    inner: &amp;'a mut VaListImpl&lt;'f&gt;,

    _marker: PhantomData&lt;&amp;'a mut VaListImpl&lt;'f&gt;&gt;,
}

impl&lt;'f&gt; VaListImpl&lt;'f&gt; {
    pub fn as_va_list&lt;'a&gt;(&amp;'a mut self) -&gt; VaList&lt;'a, 'f&gt; {
        VaList { inner: self, _marker: PhantomData }
    }
}
impl&lt;'f&gt; Clone for VaListImpl&lt;'f&gt; {
    #[inline]
    fn clone(&amp;self) -&gt; Self {
        let mut dest = crate::mem::MaybeUninit::uninit();
        // SAFETY: we write to the `MaybeUninit`, thus it is initialized and `assume_init` is legal
        unsafe {
            va_copy(dest.as_mut_ptr(), self);
            dest.assume_init()
        }
    }
}

impl&lt;'f&gt; VaListImpl&lt;'f&gt; {
    /// Advance to the next arg.
    #[inline]
    pub unsafe fn arg&lt;T: sealed_trait::VaArgSafe&gt;(&amp;mut self) -&gt; T {
        // SAFETY: the caller must uphold the safety contract for `va_arg`.
        unsafe { va_arg(self) }
    }

    /// Copies the `va_list` at the current location.
    pub unsafe fn with_copy&lt;F, R&gt;(&amp;self, f: F) -&gt; R
    where
        F: for&lt;'copy&gt; FnOnce(VaList&lt;'copy, 'f&gt;) -&gt; R,
    {
        let mut ap = self.clone();
        let ret = f(ap.as_va_list());
        // SAFETY: the caller must uphold the safety contract for `va_end`.
        unsafe {
            va_end(&amp;mut ap);
        }
        ret
    }
}

extern &quot;rust-intrinsic&quot; {
    //以下缺少了C语言va_start的对应，RUST不需要
    /// Destroy the arglist `ap` after initialization with `va_start` or
    /// `va_copy`.
    fn va_end(ap: &amp;mut VaListImpl&lt;'_&gt;);

    /// Copies the current location of arglist `src` to the arglist `dst`.
    fn va_copy&lt;'f&gt;(dest: *mut VaListImpl&lt;'f&gt;, src: &amp;VaListImpl&lt;'f&gt;);

    /// Loads an argument of type `T` from the `va_list` `ap` and increment the
    /// argument `ap` points to.
    fn va_arg&lt;T: sealed_trait::VaArgSafe&gt;(ap: &amp;mut VaListImpl&lt;'_&gt;) -&gt; T;
}

<span class="boring">}</span></code></pre></pre>
<h2 id="系统调用的封装"><a class="header" href="#系统调用的封装">系统调用的封装</a></h2>
<p>操作系统的系统调用一般出错返回-1, 为了简化对此情况的处理，将这个出错封装到RUST的Result类型，RUST实现了以下机制:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//对系统调用出错的判断
pub trait IsMinusOne {
    fn is_minus_one(&amp;self) -&gt; bool;
}

macro_rules! impl_is_minus_one {
    ($($t:ident)*) =&gt; ($(impl IsMinusOne for $t {
        fn is_minus_one(&amp;self) -&gt; bool {
            *self == -1
        }
    })*)
}

//对所有系统调用可能的返回类型实现了出错判断trait
impl_is_minus_one! { i8 i16 i32 i64 isize }

//对系统调用进行出错处理的封装，将错误转换为Result类型
pub fn cvt&lt;T: IsMinusOne&gt;(t: T) -&gt; crate::io::Result&lt;T&gt; {
    //Error是对操作系统错误的封装
    if t.is_minus_one() { Err(crate::io::Error::last_os_error()) } else { Ok(t) }
}

//对于被中断的系统调用做额外的处理封装
pub fn cvt_r&lt;T, F&gt;(mut f: F) -&gt; crate::io::Result&lt;T&gt;
where
    T: IsMinusOne,
    F: FnMut() -&gt; T,
{
    loop {
        match cvt(f()) {
            //如果返回是调用被中断, 则再次执行系统调用
            Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
            other =&gt; return other,
        }
    }
}

//对系统调用的返回值进行判断，转换为io::Result的结果
pub fn cvt_nz(error: libc::c_int) -&gt; crate::io::Result&lt;()&gt; {
    if error == 0 { Ok(()) } else { Err(crate::io::Error::from_raw_os_error(error)) }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="cstr及cstring代码分析"><a class="header" href="#cstr及cstring代码分析">CStr及CString代码分析</a></h2>
<p>代码路径：library/std/src/ffi/c_str.rs<br />
RUST定义CStr及CString主要的目的就是与C的各种库函数交互。<br />
因此CStr及CString不涉及字符串的迭代器，格式化，加减，分裂，字符查找等等操作。只是负责做String及str与C语言之间的转换及与转换相关及调试相关的若干功能。<br />
之所以设计CString，是因为如果需要保存C语言的字符串，需要用堆内存的方式来完成。同时，传递给C语言的字符串，需要位于堆内存中代码才会比较简单及安全。<br />
一般的处理C语言交互传入的字符串的过程是:首先需要用CStr将字符串进行包装，使得保证后继操作复合RUST的安全规则；如果需要对字符串做保存，那需要用CStr生成一个CString。当然，也可以直接转化为String，要根据具体的情况和需求处理，但仅使用String的方式在某些场景下显然效率不高并且也是不合适的。<br />
如果是需要将RUST的str转换成C语言的字符串，则先转换成CString.</p>
<p>CString及CStr类型结构定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CString {
    // C语言的字符串是一个以0位结尾的字节数组. 通常的，申请的空间大小会大于字符串长度，因此
    // 下面的切片长度不能用于判断字符串长度
    inner: box&lt;[u8]&gt;,
}
pub struct CStr {
    // 此处没有太好的办法，C语言对字符串实际上会存储在一个申请后就固定的字节数组里，然后用指针表示字符串类型
    // 但RUST显然不可能用裸指针来实现，切片类型是最接近的。但要注意C语言中的实际上是个固定的数组
    inner: [c_char],
}
<span class="boring">}</span></code></pre></pre>
<p>CStr主要的需求是对C语言的char*进行封装并定义转换方法，将C语言的字符串安全化。并在需要的时候转化成str或CString类型</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl CStr {
    //主要的创建方法，这个函数接收一个已经由C语言模块传递过来的char *指针，然后创建RUST
    //需要的CStr引用 并返回
    // 调用代码应该保证传入参数的正确性。此函数返回的引用生命周期由调用代码的上下文决定
    // 生命周期的正确性也由调用代码保证。
    pub unsafe fn from_ptr&lt;'a&gt;(ptr: *const c_char) -&gt; &amp;'a CStr {
        //将* const c_char转换成 &amp;[u8]
        unsafe {
            //调用C语言的库函数libc::strlen获得字符串长度，这里实际可以用RUST自行实现
            let len = sys::strlen(ptr);
            let ptr = ptr as *const u8;
            //先创建&amp;[u8], 然后创建Self类型引用
            Self::_from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))
        }
    }

    pub fn from_bytes_until_nul(bytes: &amp;[u8]) -&gt; Result&lt;&amp;CStr, FromBytesUntilNulError&gt; {
        //core库实现了memchr，查找到字符串尾部字节位置
        let nul_pos = memchr::memchr(0, bytes);
        match nul_pos {
            Some(nul_pos) =&gt; {
                // slice仅保留有效的字节.
                let subslice = &amp;bytes[..nul_pos + 1];
                // 见后继的分析
                Ok(unsafe { CStr::from_bytes_with_nul_unchecked(subslice) })
            }
            None =&gt; Err(FromBytesUntilNulError(())),
        }
    }
    //从准备好的[u8]创建CStr的引用并返回
    pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &amp;[u8]) -&gt; &amp;CStr {
        debug_assert!(!bytes.is_empty() &amp;&amp; bytes[bytes.len() - 1] == 0);
        //见后继的分析
        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }
    }

    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &amp;[u8]) -&gt; &amp;Self {
        // 利用裸指针转换，注意这里CStr结构定义没有用#[repr(transparent)]或#[repr(C)]，这里直接做转换的根据感觉有些不足，
        //返回的生命周期要小于bytes，但因为bytes基本上是从一个裸指针转换而来的，所以
        //这里的&amp;Self的生命周期的正确性还是要由调用代码负责
        unsafe { &amp;*(bytes as *const [u8] as *const Self) }
    }

    //将CStr转换成C语言的字符串，需要保证复合C语言字符串的规则
    //此函数可能引发一个潜在问题如下例：
    /// use std::ffi::CString;
    ///
    /// let ptr = CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr();
    /// unsafe {
    ///     // 这里会出现悬垂指针,见后面的解释
    ///     *ptr;
    /// }
    /// ```
    ///
    /// 以上悬垂指针是因为`as_ptr`没有生命周期，因为CString创建的变量又没有变量声明与之绑定，所以其在执行完as_ptr后立即被释放。
    /// 可使用如下的方法
    /// ```no_run
    /// # #![allow(unused_must_use)]
    /// use std::ffi::CString;
    /// 
    /// //声明一个变量，生命周期一般会到作用域的尾部。
    /// let hello = CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;);
    /// let ptr = hello.as_ptr();
    /// unsafe {
    ///     // `ptr` is valid because `hello` is in scope
    ///     *ptr;
    /// }
    /// ```
    pub const fn as_ptr(&amp;self) -&gt; *const c_char {
        self.inner.as_ptr()
    }

    //转换成去掉尾部0的[u8]切片引用
    pub fn to_bytes(&amp;self) -&gt; &amp;[u8] {
        let bytes = self.to_bytes_with_nul();
        // SAFETY: to_bytes_with_nul returns slice with length at least 1
        unsafe { bytes.get_unchecked(..bytes.len() - 1) }
    }

    //转换成[u8]切片引用,尾部仍然有0
    pub fn to_bytes_with_nul(&amp;self) -&gt; &amp;[u8] {
        unsafe { &amp;*(&amp;self.inner as *const [c_char] as *const [u8]) }
    }

    //转换成&amp;str
    pub fn to_str(&amp;self) -&gt; Result&lt;&amp;str, str::Utf8Error&gt; {
        str::from_utf8(self.to_bytes())
    }

    //转换成CString
    pub fn into_c_string(self: Box&lt;CStr&gt;) -&gt; CString {
        //将堆内存从Box取出
        let raw = Box::into_raw(self) as *mut [u8];
        //重新形成Box结构，然后创建CString
        CString { inner: unsafe { Box::from_raw(raw) } }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>CString的相关实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl CString {
    pub fn new&lt;T: Into&lt;Vec&lt;u8&gt;&gt;&gt;(t: T) -&gt; Result&lt;CString, NulError&gt; {
        trait SpecNewImpl {
            fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt;;
        }

        impl&lt;T: Into&lt;Vec&lt;u8&gt;&gt;&gt; SpecNewImpl for T {
            default fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt; {
                let bytes: Vec&lt;u8&gt; = self.into();
                match memchr::memchr(0, &amp;bytes) {
                    Some(i) =&gt; Err(NulError(i, bytes)),
                    None =&gt; Ok(unsafe { CString::_from_vec_unchecked(bytes) }),
                }
            }
        }

        //此函数用来防止多次申请内存
        fn spec_new_impl_bytes(bytes: &amp;[u8]) -&gt; Result&lt;CString, NulError&gt; {
            // 此处checked_add的优化效率最高，bytes中没有0，所以需要加1
            let capacity = bytes.len().checked_add(1).unwrap();

            // 申请堆内存，并将bytes写入堆内存,此处申请可以防止重复申请，但无论成功与否都会申请内存
            let mut buffer = Vec::with_capacity(capacity);
            //此时还没有给buffer的尾部赋0
            buffer.extend(bytes);

            // 看bytes内是否有0值
            match memchr::memchr(0, bytes) {
                //有0，出错了，将buffer在参数返回，由外部代码处理
                Some(i) =&gt; Err(NulError(i, buffer)),
                //无0，生成CString，生成函数中会赋0
                None =&gt; Ok(unsafe { CString::_from_vec_unchecked(buffer) }),
            }
        }

        //可以从[u8]切片生成CString
        impl SpecNewImpl for &amp;'_ [u8] {
            fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt; {
                spec_new_impl_bytes(self)
            }
        }

        //支持从str生成CString
        impl SpecNewImpl for &amp;'_ str {
            fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt; {
                spec_new_impl_bytes(self.as_bytes())
            }
        }

        //支持从可变[u8]生成CString
        impl SpecNewImpl for &amp;'_ mut [u8] {
            fn spec_new_impl(self) -&gt; Result&lt;CString, NulError&gt; {
                spec_new_impl_bytes(self)
            }
        }

        t.spec_new_impl()
    }

    //从Vec创建CString,实际是从String创建的支持函数
    pub unsafe fn from_vec_unchecked(v: Vec&lt;u8&gt;) -&gt; Self {
        debug_assert!(memchr::memchr(0, &amp;v).is_none());
        unsafe { Self::_from_vec_unchecked(v) }
    }

    //Vec&lt;u8&gt;已经完成安全检查，不会出错
    unsafe fn _from_vec_unchecked(mut v: Vec&lt;u8&gt;) -&gt; Self {
        //以下就是增加尾部的0值
        v.reserve_exact(1);
        v.push(0);
        //将堆内存从Vec结构转移至Box结构
        Self { inner: v.into_boxed_slice() }
    }

    //从C语言字符串创建CString, 此时c语言的字符串应该是前期RUST代码申请的堆内存
    //要规避不是RUST申请的堆内存的情况
    pub unsafe fn from_raw(ptr: *mut c_char) -&gt; CString {
        // ptr应该从CString::into_raw得到的,此方法使用后，可以省略一次内存拷贝
        unsafe {
            //得到字符串长度
            let len = sys::strlen(ptr) + 1; // Including the NUL byte
            //形成正确的切片引用 
            let slice = slice::from_raw_parts_mut(ptr, len as usize);
            //形成CString
            CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }
        }
    }

    pub fn into_raw(self) -&gt; *mut c_char {
        //CString已经包含了0值
        Box::into_raw(self.into_inner()) as *mut c_char
    }

    //转换成String类型
    pub fn into_string(self) -&gt; Result&lt;String, IntoStringError&gt; {
        String::from_utf8(self.into_bytes()).map_err(|e| IntoStringError {
            error: e.utf8_error(),
            inner: unsafe { Self::_from_vec_unchecked(e.into_bytes()) },
        })
    }

    pub fn into_bytes(self) -&gt; Vec&lt;u8&gt; {
        //消费了CString，Box中的堆内存转移到Vec
        let mut vec = self.into_inner().into_vec();
        //删掉尾部的0值
        let _nul = vec.pop();
        debug_assert_eq!(_nul, Some(0u8));
        vec
    }

    pub fn into_bytes_with_nul(self) -&gt; Vec&lt;u8&gt; {
        //不对尾部的0值做处理
        self.into_inner().into_vec()
    }

    //将CString转换为[u8]切片引用
    pub fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        // 删除尾部的0值
        unsafe { self.inner.get_unchecked(..self.inner.len() - 1) }
    }

    //保留尾部的0值
    pub fn as_bytes_with_nul(&amp;self) -&gt; &amp;[u8] {
        &amp;self.inner
    }

    //转换为CStr的引用
    pub fn as_c_str(&amp;self) -&gt; &amp;CStr {
        &amp;*self
    }

    
    pub fn into_boxed_c_str(self) -&gt; Box&lt;CStr&gt; {
        //Box取出堆内存指针，然后转换，再封装入Box，RUST这个实在是麻烦
        unsafe { Box::from_raw(Box::into_raw(self.into_inner()) as *mut CStr) }
    }

    fn into_inner(self) -&gt; Box&lt;[u8]&gt; {
        //将Box取出，如果直接解封装的方式，因为会调用self的drop函数，会再调用内部的Box的drop。
        //用MannuallyDrop来规避是不想再重构了，这个代码的例子不应学习
        //如果有需要inner，那就不应该用Box&lt;[u8]&gt;这种方式来设计
        //这个设计导致必须用下面这种技巧，带来理解上的复杂性
        let this = mem::ManuallyDrop::new(self);
        unsafe { ptr::read(&amp;this.inner) }
    }

    //从Vec生成CString
    pub unsafe fn from_vec_with_nul_unchecked(v: Vec&lt;u8&gt;) -&gt; Self {
        debug_assert!(memchr::memchr(0, &amp;v).unwrap() + 1 == v.len());
        unsafe { Self::_from_vec_with_nul_unchecked(v) }
    }

    //同上，无需再检查0值
    unsafe fn _from_vec_with_nul_unchecked(v: Vec&lt;u8&gt;) -&gt; Self {
        Self { inner: v.into_boxed_slice() }
    }

    //此函数为从String转换为CString准备
    pub fn from_vec_with_nul(v: Vec&lt;u8&gt;) -&gt; Result&lt;Self, FromVecWithNulError&gt; {
        //确定0值的位置
        let nul_pos = memchr::memchr(0, &amp;v);
        match nul_pos {
            //如果0值的位置正确
            Some(nul_pos) if nul_pos + 1 == v.len() =&gt; {
                // 创建CString
                Ok(unsafe { Self::_from_vec_with_nul_unchecked(v) })
            }
            //出错处理
            Some(nul_pos) =&gt; Err(FromVecWithNulError {
                error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),
                bytes: v,
            }),
            None =&gt; Err(FromVecWithNulError {
                error_kind: FromBytesWithNulErrorKind::NotNulTerminated,
                bytes: v,
            }),
        }
    }
}

//drop函数
impl Drop for CString {
    fn drop(&amp;mut self) {
        unsafe {
            //消费了Box，堆内存已经拷贝到栈，然后将C语言的字符串设置为空字符串。
            *self.inner.get_unchecked_mut(0) = 0;
            
        }
    }
}

impl ops::Deref for CString {
    type Target = CStr;

    fn deref(&amp;self) -&gt; &amp;CStr {
        unsafe { CStr::_from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>CString, CStr其他代码略。</p>
<h2 id="代码工程中的一个技巧"><a class="header" href="#代码工程中的一个技巧">代码工程中的一个技巧</a></h2>
<p>在对不同的CPU架构，不同的操作系统进行适配的时候，通常在代码中采用如下的组织方式：</p>
<ol>
<li>有接口定义文件，在C语言中一般用头文件，在RUST中用mod.rs文件，这个文件负责向其他模块提供一致的API访问界面.</li>
<li>每种CPU架构或者每种操作系统各自建立一个目录(模块).</li>
<li>每种CPU架构或者每种操作系统各自实现接口的代码都在此目录下实现.</li>
<li>利用编译参数控制对于特定CPU架构，操作系统仅编译特定目录下的代码.<br />
举例如下：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod common;

cfg_if::cfg_if! {
    if #[cfg(unix)] {
        mod unix;
        pub use self::unix::*;
    } else if #[cfg(windows)] {
        mod windows;
        pub use self::windows::*;
    } else if #[cfg(target_os = &quot;solid_asp3&quot;)] {
        mod solid;
        pub use self::solid::*;
    } else if #[cfg(target_os = &quot;hermit&quot;)] {
        mod hermit;
        pub use self::hermit::*;
    } else if #[cfg(target_os = &quot;wasi&quot;)] {
        mod wasi;
        pub use self::wasi::*;
    } else if #[cfg(target_family = &quot;wasm&quot;)] {
        mod wasm;
        pub use self::wasm::*;
    } else if #[cfg(all(target_vendor = &quot;fortanix&quot;, target_env = &quot;sgx&quot;))] {
        mod sgx;
        pub use self::sgx::*;
    } else {
        mod unsupported;
        pub use self::unsupported::*;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上的mod.rs实现RUST对编译的控制，按照事先的target_os的配置控制了编译的目录。这是RUST的一个优势，C语言需要在Makefile里面来控制编译的目录。
RUST用<code>pub use self::windows::*</code>的语法，将特定的操作系统的模块重导出为 <code>std::sys::*</code>，从而对其他的RUST模块实现了对不同操作系统API接口访问的统一。
类似的设计方式可能会在多种场景下遇到，例如对不同数据库API的适配，对不同3D API的适配等等。</p>
<h2 id="osstring-代码分析"><a class="header" href="#osstring-代码分析">OsString 代码分析</a></h2>
<p>操作系统系统调用采用的字符串类型很可能与C语言不同,单纯只有CStr及CString满足不了需求。按照与CStr及CString类似的实现，RUST也实现了OsStr及OsString。显然，这个模块包括了操作系统相关及操作系统无关的两个部分：
操作系统无关部分代码路径如下：<br />
library/src/std/src/ffi/os_str.rs<br />
操作系统相关部分代码路径如下，(仅列出linux及windows)： 
library/src/std/src/sys/unix/os_str.rs<br />
library/src/std/src/sys/windows/os_str.rs</p>
<p>linux操作系统相关部分的接口类型结构定义： </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct Buf {
    pub inner: Vec&lt;u8&gt;,
}

#[repr(transparent)]
pub struct Slice {
    pub inner: [u8],
}
<span class="boring">}</span></code></pre></pre>
<p>windows操作系统相关部分的接口结构定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Buf {
    pub inner: Wtf8Buf,
}
pub struct Slice {
    pub inner: Wtf8,
}
pub struct Wtf8Buf {
    bytes: Vec&lt;u8&gt;,
}
pub struct Wtf8 {
    bytes: [u8],
}
<span class="boring">}</span></code></pre></pre>
<p>OsString及OsStr的定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OsString {
    inner: Buf,
}

pub struct OsStr {
    inner: Slice,
}
<span class="boring">}</span></code></pre></pre>
<p>OsString及OsStr实际上是两个适配器，每个方法基本上都是做个透传，如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl OsString {
    pub fn new() -&gt; OsString {
        OsString { inner: Buf::from_string(String::new()) }
    }
    
    pub fn into_string(self) -&gt; Result&lt;String, OsString&gt; {
        self.inner.into_string().map_err(|buf| OsString { inner: buf })
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>OsString及OStr在unix上的结构定义与RUST的String及str基本一致，代码略</p>
<h1 id="std的内存管理分析"><a class="header" href="#std的内存管理分析">std的内存管理分析</a></h1>
<p>std库与core库在内存管理RUST提供的机制是统一的。即Allocator trait 与 GlobalAlloc trait。<br />
从std库可以发现RUST为什么将内存管理分成了Allocator及GlobalAlloc两个trait。<br />
GlobalAlloc trait是操作系统无关及操作系统相关的界面接口。GlobalAlloc的主要功能就是对操作系统的系统调用进行封装，并完成RUST的内存类型与操作系统的系统调用的类型转换。<br />
Allocator是RUST自身的内存管理模块，其他的RUST模块如果有内存需求，同过Allocator triat来完成。Allocator使用GlobalAlloc完成对操作系统的使用。</p>
<p>std库用System 作为这两个trait的实现载体，core库中用Global重新实现了Allocator，Global没有实现GlobalAlloc,因为Global需要适配非操作系统情况，具体请参考02-内存一章, System的代码如下：</p>
<p>以下是unix操作系统相关的部分，代码位置：library/std/src/sys/unix/alloc.rs<br />
不同的操作系统，其内存申请的系统调用都不一致，因此对GlobalAlloc的实现也不一致。<br />
类unix的操作系统主要使用了libc的库函数实现操作系统的系统调用。后继还会看到更多的libc中与操作系统交互的代码，分析RUST std库的代码，必须熟练的掌握libc库。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//单元结构体，仅用来作为内存管理的实现载体
pub struct System;

unsafe impl GlobalAlloc for System {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        // 用libc来实现内存申请，这里适配的难点在于对齐的适配，
        // libc的malloc对齐是不能指定的。  
        // 只有在申请的内存对齐小于MIN_ALIGN而且申请的内存大小大于对齐大小时
        // 才能调用libc的malloc做申请.  
        // 对齐的内存申请C程序员不是太长接触
        if layout.align() &lt;= MIN_ALIGN &amp;&amp; layout.align() &lt;= layout.size() {
            libc::malloc(layout.size()) as *mut u8
        } else {
            //见随后的分析
            aligned_malloc(&amp;layout)
        }
    }

    unsafe fn alloc_zeroed(&amp;self, layout: Layout) -&gt; *mut u8 {
        // 一样需要处理对齐
        if layout.align() &lt;= MIN_ALIGN &amp;&amp; layout.align() &lt;= layout.size() {
            libc::calloc(layout.size(), 1) as *mut u8
        } else {
            let ptr = self.alloc(layout);
            //不能用calloc处理时需要清零
            if !ptr.is_null() {
                ptr::write_bytes(ptr, 0, layout.size());
            }
            ptr
        }
    }

    unsafe fn dealloc(&amp;self, ptr: *mut u8, _layout: Layout) {
        //都使用free做释放
        libc::free(ptr as *mut libc::c_void)
    }

    unsafe fn realloc(&amp;self, ptr: *mut u8, layout: Layout, new_size: usize) -&gt; *mut u8 {
        //对齐处理
        if layout.align() &lt;= MIN_ALIGN &amp;&amp; layout.align() &lt;= new_size {
            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8
        } else {
            //无法对齐时的处理，
            realloc_fallback(self, ptr, layout, new_size)
        }
    }
}

//此函数用于libc的realloc无法支持RUST语义时使用
pub unsafe fn realloc_fallback(
    alloc: &amp;System,
    ptr: *mut u8,
    old_layout: Layout,
    new_size: usize,
) -&gt; *mut u8 {
    // Docs for GlobalAlloc::realloc require this to be valid:
    let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());

    let new_ptr = GlobalAlloc::alloc(alloc, new_layout);
    if !new_ptr.is_null() {
        let size = cmp::min(old_layout.size(), new_size);
        ptr::copy_nonoverlapping(ptr, new_ptr, size);
        GlobalAlloc::dealloc(alloc, ptr, old_layout);
    }
    new_ptr
}
cfg_if::cfg_if! {
    if #[cfg(target_os = &quot;wasi&quot;)] {
        //wasi提供aligned_alloc的支持
        unsafe fn aligned_malloc(layout: &amp;Layout) -&gt; *mut u8 {
            libc::aligned_alloc(layout.align(), layout.size()) as *mut u8
        }
    } else {
        //其他需要用posix_memalign来完成
        unsafe fn aligned_malloc(layout: &amp;Layout) -&gt; *mut u8 {
            let mut out = ptr::null_mut();
            // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.
            // Since these are all powers of 2, we can just use max.
            let align = layout.align().max(crate::mem::size_of::&lt;usize&gt;());
            let ret = libc::posix_memalign(&amp;mut out, align, layout.size());
            if ret != 0 { ptr::null_mut() } else { out as *mut u8 }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST程序需要处理内存对齐，所以调用了一些不常见的libc内存函数。 
以下为操作系统无关部分的内存管理实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl System {
    //具体的内存申请实现，与Global类似，可参考前文的解释
    fn alloc_impl(&amp;self, layout: Layout, zeroed: bool) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        match layout.size() {
            0 =&gt; Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
            size =&gt; unsafe {
                let raw_ptr = if zeroed {
                    //System也实现了GlobalAlloc trait，这与core库中不同，core库中对GlobalAlloc trait中方法的调用是使用了编译器提供了包装。这使得core库即可以适用于用户态也可以适用于内核态。但std库就是在用户态，所以解决方法更直接。
                    GlobalAlloc::alloc_zeroed(self, layout)
                } else {
                    GlobalAlloc::alloc(self, layout)
                };
                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                Ok(NonNull::slice_from_raw_parts(ptr, size))
            },
        }
    }

    //内存不足，需要增加空间的申请操作
    unsafe fn grow_impl(
        &amp;self,
        ptr: NonNull&lt;u8&gt;,
        old_layout: Layout,
        new_layout: Layout,
        zeroed: bool,
    ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        debug_assert!(
            new_layout.size() &gt;= old_layout.size(),
            &quot;`new_layout.size()` must be greater than or equal to `old_layout.size()`&quot;
        );

        match old_layout.size() {
            //旧的空间是0，那相当于申请一个新空间的操作
            0 =&gt; self.alloc_impl(new_layout, zeroed),

            //旧的内存块与新内存块的对齐是一致的
            old_size if old_layout.align() == new_layout.align() =&gt; unsafe {
                //直接调用realloc的逻辑即可，
                let new_size = new_layout.size();

                intrinsics::assume(new_size &gt;= old_layout.size());
                //realloc的逻辑保证旧的内存块的内容被保留
                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);
                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                if zeroed {
                    //旧内存块的内容不变，仅对新内存块处理
                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);
                }
                //形成新的NonNull&lt;[u8]&gt;返回
                Ok(NonNull::slice_from_raw_parts(ptr, new_size))
            },
            
            //旧内存块与新内存块的对齐不一致
            old_size =&gt; unsafe {
                //需要按照新的内存布局参数重新申请一块内存
                let new_ptr = self.alloc_impl(new_layout, zeroed)?;
                //将旧内存块的内容拷贝到新内存
                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);
                //将旧内存块释放掉
                Allocator::deallocate(&amp;self, ptr, old_layout);
                Ok(new_ptr)
            },
        }
    }
}

// 实现Allocator trait, std库后继会使用此trait完成内存管理操作。
unsafe impl Allocator for System {
    //申请内存块
    fn allocate(&amp;self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        self.alloc_impl(layout, false)
    }
    //申请内存块，并将内存块清零
    fn allocate_zeroed(&amp;self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        self.alloc_impl(layout, true)
    }
    //释放内存块
    unsafe fn deallocate(&amp;self, ptr: NonNull&lt;u8&gt;, layout: Layout) {
        if layout.size() != 0 {
            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }
        }
    }
    //增长内存空间
    unsafe fn grow(
        &amp;self,
        ptr: NonNull&lt;u8&gt;,
        old_layout: Layout,
        new_layout: Layout,
    ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        unsafe { self.grow_impl(ptr, old_layout, new_layout, false) }
    }
    //增长内存空间，增长的部分进行清零
    unsafe fn grow_zeroed(
        &amp;self,
        ptr: NonNull&lt;u8&gt;,
        old_layout: Layout,
        new_layout: Layout,
    ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        unsafe { self.grow_impl(ptr, old_layout, new_layout, true) }
    }
    //收缩内存空间，此时必须重新申请内存。
    unsafe fn shrink(
        &amp;self,
        ptr: NonNull&lt;u8&gt;,
        old_layout: Layout,
        new_layout: Layout,
    ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocError&gt; {
        debug_assert!(
            new_layout.size() &lt;= old_layout.size(),
            &quot;`new_layout.size()` must be smaller than or equal to `old_layout.size()`&quot;
        );
        
        match new_layout.size() {
            // 收缩空间至0, 实际上就是释放内存
            0 =&gt; unsafe {
                Allocator::deallocate(&amp;self, ptr, old_layout);
                //返回一个dangling的指针表示悬垂指针。此处应该用Option&lt;NonNull&lt;[u8]&gt;&gt;返回才符合
                //rust的习惯用法吧，目前的返回代码后继有额外的判断负担
                Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))
            },

            //如果内存对齐相同
            new_size if old_layout.align() == new_layout.align() =&gt; unsafe {
                intrinsics::assume(new_size &lt;= old_layout.size());
                //realloc函数会保留原内存内容
                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);
                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                Ok(NonNull::slice_from_raw_parts(ptr, new_size))
            },

            //对齐不同，必须重新申请内存
            new_size =&gt; unsafe {
                let new_ptr = Allocator::allocate(&amp;self, new_layout)?;
                //将原内存内容拷贝入新内存
                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);
                //释放原内存
                Allocator::deallocate(&amp;self, ptr, old_layout);
                Ok(new_ptr)
            },
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上是std库的通用实现,代码位置：library/std/src/alloc.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="std库文件描述符代码分析"><a class="header" href="#std库文件描述符代码分析">std库文件描述符代码分析</a></h1>
<p>以linux为例，文件描述符实际上是操作系统所有资源的标识。也是对其他模块分析的一个基础。<br />
RUST文件描述符管理的结构设计：</p>
<ol>
<li>对操作系统文件描述符的适配层。对于RUST来说，操作系统的文件描述符与获取的堆内存指针要处理的安全性类似。需要建立类似智能指针的结构完成对其的管理，从而纳入到RUST的安全体系内。</li>
<li>RUST自身的文件描述符类型结构，在1中最重要的是解决安全问题，缺乏文件的逻辑功能。文件的逻辑功能在RUST的文件描述符类型的方法中进行了实现。仍然是操作系统的适配层。</li>
<li>在2的基础上，实现普通的文件，目录文件，Socket，Pipe，IO设备文件等逻辑文件类型。</li>
</ol>
<p>本章将讨论1及2，3以后在涉及到各模块时再进行详细分析<br />
代码目录： library/src/std/src/os/fd/raw.rs<br />
library/src/std/src/os/fd/owned.rs<br />
library/src/std/src/sys/unix/fd.rs</p>
<h2 id="操作系统的文件描述符的所有权设计"><a class="header" href="#操作系统的文件描述符的所有权设计">操作系统的文件描述符的所有权设计</a></h2>
<p>RUST当然要使用操作系统调用返回的fd来操作文件，fd在RUST中被重定义为RawFd类型。不同系统的RawFd可能不一样，但类型名称都是RawFd。<br />
可以把RawFd按照裸指针来理解，RawFd不能作为所有权的载体，但RUST中文件显然需要具备所有权，因此，RUST在RawFd上定义了封装类型OwnedFd来实现针对RawFd的所有权，又定义了类型BorrowedFd作为OwnedFd的借用类型。<br />
理解这两个类型，我们可以把RawFd类比与裸指针* const T， OwnedFd类比于 T, BorrowedFd类比于&amp;T。</p>
<p>打开一个文件后(其他模块定义)，RUST底层会用系统返回的RawFd(fd)类型变量创建OwnedFd并存储到适当的类型中。当需要调用存在fd的系统调用时，从OwnedFd获取RawFd作为参数完成系统调用。</p>
<p>以linux操作系统为基础进行分析：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//虽然是int型，但因为表示操作系统资源，所以可以类比于裸指针。
//后继被标识文件所有权的封装类型所封装后才能进入安全的RUST领域。
pub type RawFd = raw::c_int;

//此trait用于从封装RawFd的类型中获取RawFd,
//此时返回的RawFd安全性类似于裸指针。
pub trait AsRawFd {
    fn as_raw_fd(&amp;self) -&gt; RawFd;
}

//从RawFd创建一个封装类型,返回的Self获得了RawFd代表的文件的所有权 
pub trait FromRawFd {
    unsafe fn from_raw_fd(fd: RawFd) -&gt; Self;
}

//将封装类型变量消费掉，并返回RawFd，此时RUST中没有其他变量拥有RawFd代表文件的所有权，后继要由RawFd对close负责，或者将RawFd重新封装入另一个表示所有权的封装类型变量。 
pub trait IntoRawFd {
    fn into_raw_fd(self) -&gt; RawFd;
}

//获取标准输入的RawFd
impl AsRawFd for io::Stdin {
    fn as_raw_fd(&amp;self) -&gt; RawFd {
        //libc的标准输入文件标识宏
        libc::STDIN_FILENO
    }
}

//标准输出的RawFd
impl AsRawFd for io::Stdout {
    fn as_raw_fd(&amp;self) -&gt; RawFd {
        //libc的标准输出宏
        libc::STDOUT_FILENO
    }
}

//标准错误的RawFd
impl AsRawFd for io::Stderr {
    fn as_raw_fd(&amp;self) -&gt; RawFd {
        //libc的标准错误宏
        libc::STDERR_FILENO
    }
}
<span class="boring">}</span></code></pre></pre>
<p>拥有RawFd所有权的OwnedFd类型结构及OwnedFd的借用类型结构BorrowedFd。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
pub struct BorrowedFd&lt;'fd&gt; {
    fd: RawFd,
    //用OwnedFd作为RawFd的所有权版本，RawFd实际上可认为是对OwnedFd的借用。
    //但仅用fd无法表达出生命周期和借用关系，
    //这里的PhantomData用OwnedFd的引用及生命周期泛型表示了这个关系
    _phantom: PhantomData&lt;&amp;'fd OwnedFd&gt;,
}

#[repr(transparent)]
pub struct OwnedFd {
    //这个封装仅是一个形式，编译器并没有认为OwnedFd已经拥有了fd所代表文件的所有权。
    //所以，OwnedFd拥有所有权这个事情实际上是代码约定，其他代码务必不能导致用RawFd创建另一份
    //OwnedFd, 也不能另外调用fd的close。
    //调用操作系统的系统调用获得文件Fd后，应该第一时间用OwnedFd进行封装，后继如果要使用，则应该
    //用borrow的方法来借出BorrowedFd，
    fd: RawFd,
}

impl BorrowedFd&lt;'_&gt; {
    //直接在RawFd上生成BorrowFd, 这个函数主要用于不适合获得rawfd的所有权，
    //但需要借用fd时。
    //例如:标准输入/输出/错误， 或者从C语言调用传入的参数fd，不允许关闭,
    //如果在这些rawfd的基础上生成OwnedFd，会导致他们被错误关闭
    pub unsafe fn borrow_raw(fd: RawFd) -&gt; Self {
        assert_ne!(fd, u32::MAX as RawFd);
        //这里的PhantomData的赋值令人疑惑，只能认为是编译器的魔术了 
        unsafe { Self { fd, _phantom: PhantomData } }
    }
}

impl OwnedFd {
    //复制，这里是在操作系统内部复制了一个新的fd，需要调用系统调用完成
    pub fn try_clone(&amp;self) -&gt; crate::io::Result&lt;Self&gt; {
        // 设置复制的功能设定标志
        let cmd = libc::F_DUPFD_CLOEXEC;

        //调用libc库完成复制，返回新的fd
        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;
        //用新的fd创建新的Owned变量
        Ok(unsafe { Self::from_raw_fd(fd) })
    }
}

impl AsRawFd for BorrowedFd&lt;'_&gt; {
    //此方法应该尽量仅用于调用系统调用的时候使用
    fn as_raw_fd(&amp;self) -&gt; RawFd {
        self.fd
    }
}

impl AsRawFd for OwnedFd {
    //此方法应该尽量仅用于调用系统调用时使用
    fn as_raw_fd(&amp;self) -&gt; RawFd {
        self.fd
    }
}

impl IntoRawFd for OwnedFd {
    fn into_raw_fd(self) -&gt; RawFd {
        let fd = self.fd;
        //必须forget，否则会触发drop调用close(fd)
        forget(self);
        fd
    }
}

impl FromRawFd for OwnedFd {
    //应该只能用这个方法创建OwnedFd
    unsafe fn from_raw_fd(fd: RawFd) -&gt; Self {
        assert_ne!(fd, u32::MAX as RawFd);
        unsafe { Self { fd } }
    }
}

//这个方法证明OwnedFd拥有了操作系统返回的fd的所有权
impl Drop for OwnedFd {
    fn drop(&amp;mut self) {
        unsafe {
            let _ = libc::close(self.fd);
        }
    }
}

//对OwnedFd创建借用的trait
pub trait AsFd {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt;;
}

impl AsFd for OwnedFd {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        //BorrowedFd中的PhantomData从&amp;self中获得
        unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }
    }
}
//以下为所有的高层视角资源生成OwnedFd的借用
impl AsFd for fs::File {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        //实质是OwnedFd.as_fd
        self.as_inner().as_fd()
    }
}

impl From&lt;fs::File&gt; for OwnedFd {
    fn from(file: fs::File) -&gt; OwnedFd {
        //消费了File
        file.into_inner().into_inner().into_inner()
        //此处不涉及对file的forget
    }
}

impl From&lt;OwnedFd&gt; for fs::File {
    fn from(owned_fd: OwnedFd) -&gt; Self {
        //创建fs::File
        Self::from_inner(FromInner::from_inner(FromInner::from_inner(owned_fd)))
    }
}

impl AsFd for crate::net::TcpStream {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        //socket在unix与fd没有区别，也使用OwnedFd和BorrowedFd来做所有权的解决方案
        self.as_inner().socket().as_fd()
    }
}

impl From&lt;crate::net::TcpStream&gt; for OwnedFd {
    fn from(tcp_stream: crate::net::TcpStream) -&gt; OwnedFd {
        //消费掉tcp_stream，具体在tcp stream分析
        tcp_stream.into_inner().into_socket().into_inner().into_inner().into()
    }
}

impl From&lt;OwnedFd&gt; for crate::net::TcpStream {
    fn from(owned_fd: OwnedFd) -&gt; Self {
        //后继在TcpStream章节分析
        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
            owned_fd,
        ))))
    }
}

impl AsFd for crate::net::TcpListener {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        //同TcpStream
        self.as_inner().socket().as_fd()
    }
}

impl From&lt;crate::net::TcpListener&gt; for OwnedFd {
    fn from(tcp_listener: crate::net::TcpListener) -&gt; OwnedFd {
        tcp_listener.into_inner().into_socket().into_inner().into_inner().into()
    }
}

impl From&lt;OwnedFd&gt; for crate::net::TcpListener {
    fn from(owned_fd: OwnedFd) -&gt; Self {
        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
            owned_fd,
        ))))
    }
}

impl AsFd for crate::net::UdpSocket {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        //UDP与TCP类似
        self.as_inner().socket().as_fd()
    }
}

impl From&lt;crate::net::UdpSocket&gt; for OwnedFd {
    fn from(udp_socket: crate::net::UdpSocket) -&gt; OwnedFd {
        udp_socket.into_inner().into_socket().into_inner().into_inner().into()
    }
}

impl From&lt;OwnedFd&gt; for crate::net::UdpSocket {
    fn from(owned_fd: OwnedFd) -&gt; Self {
        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(
            owned_fd,
        ))))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对于需要调用RUST以外语言实现的第三方库时，都会面临一个从第三方库获取的资源如何在RUST设计其所有权的问题。Unix的fd的方案给出了一个经典的设计方式。即把第三方库获取的资源在逻辑上类似于裸指针，如RawFd。然后用一个封装结构封装用于所有权实现，例如OwnedFd。用另一个封装结构用作借用，例如BorrowedFd。这个设计方案在真正的生产环境中会经常被用到。</p>
<h2 id="rust标准库文件描述符的结构与实现"><a class="header" href="#rust标准库文件描述符的结构与实现">RUST标准库文件描述符的结构与实现</a></h2>
<p>在OwnedFd的基础上创建的结构，是文件操作的操作系统适配层的实现。以下代码分析linux操作系统的RUST文件描述符模块实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//RUST的文件描述符类型结构
pub struct FileDesc(OwnedFd);

impl FileDesc {
    //从文件描述符读出字节流
    pub fn read(&amp;self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        let ret = cvt(unsafe {
            //调用libc的read函数
            libc::read(
                //按C语言的调用进行转换
                self.as_raw_fd(),
                //转换成void *指针
                buf.as_mut_ptr() as *mut c_void,
                //不能超过buf，也不能超过一次读的最大长度
                cmp::min(buf.len(), READ_LIMIT),
            )
        })?;
        Ok(ret as usize)
    }

    //对应于libc的iovec读的方式,具体请参考libc的说明
    pub fn read_vectored(&amp;self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        let ret = cvt(unsafe {
            libc::readv(
                self.as_raw_fd(),
                bufs.as_ptr() as *const libc::iovec,
                cmp::min(bufs.len(), max_iov()) as c_int,
            )
        })?;
        Ok(ret as usize)
    }

    //一直读到文件结束
    pub fn read_to_end(&amp;self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; {
        let mut me = self;
        (&amp;mut me).read_to_end(buf)
    }

    //从文件的某一个位置开始读，请参考libc的pread64的man
    pub fn read_at(&amp;self, buf: &amp;mut [u8], offset: u64) -&gt; io::Result&lt;usize&gt; {
        use libc::pread64;

        unsafe {
            cvt(pread64(
                self.as_raw_fd(),
                buf.as_mut_ptr() as *mut c_void,
                cmp::min(buf.len(), READ_LIMIT),
                offset as i64,
            ))
            .map(|n| n as usize)
        }
    }

    //读到buffer中的某一个位置
    pub fn read_buf(&amp;self, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; io::Result&lt;()&gt; {
        let ret = cvt(unsafe {
            libc::read(
                self.as_raw_fd(),
                buf.unfilled_mut().as_mut_ptr() as *mut c_void,
                cmp::min(buf.remaining(), READ_LIMIT),
            )
        })?;

        //原有的空间是MaybeUninit，读到内容后需要进行初始化标注
        unsafe {
            buf.assume_init(ret as usize);
        }
        //更新内容长度
        buf.add_filled(ret as usize);
        Ok(())
    }

    //向文件描述符写入字节流
    pub fn write(&amp;self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        let ret = cvt(unsafe {
            libc::write(
                self.as_raw_fd(),
                buf.as_ptr() as *const c_void,
                cmp::min(buf.len(), READ_LIMIT),
            )
        })?;
        Ok(ret as usize)
    }

    //iovec的方式写入
    pub fn write_vectored(&amp;self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        let ret = cvt(unsafe {
            libc::writev(
                self.as_raw_fd(),
                bufs.as_ptr() as *const libc::iovec,
                cmp::min(bufs.len(), max_iov()) as c_int,
            )
        })?;
        Ok(ret as usize)
    }

    //在文件的某一位置写入字节流
    pub fn write_at(&amp;self, buf: &amp;[u8], offset: u64) -&gt; io::Result&lt;usize&gt; {
        use libc::pwrite64;

        unsafe {
            cvt(pwrite64(
                self.as_raw_fd(),
                buf.as_ptr() as *const c_void,
                cmp::min(buf.len(), READ_LIMIT),
                offset as i64,
            ))
            .map(|n| n as usize)
        }
    }

    //获取FD_CLOEXEC，具体请参考libc的相关手册
    pub fn get_cloexec(&amp;self) -&gt; io::Result&lt;bool&gt; {
        unsafe { Ok((cvt(libc::fcntl(self.as_raw_fd(), libc::F_GETFD))? &amp; libc::FD_CLOEXEC) != 0) }
    }

    //设置FD_CLOEXEC的属性，一般会在打开文件时完成设置，否则要注意不同线程竞争问题
    pub fn set_cloexec(&amp;self) -&gt; io::Result&lt;()&gt; {
        unsafe {
            let previous = cvt(libc::fcntl(self.as_raw_fd(), libc::F_GETFD))?;
            let new = previous | libc::FD_CLOEXEC;
            if new != previous {
                cvt(libc::fcntl(self.as_raw_fd(), libc::F_SETFD, new))?;
            }
            Ok(())
        }
    }

    //设置为非阻塞
    pub fn set_nonblocking(&amp;self, nonblocking: bool) -&gt; io::Result&lt;()&gt; {
        unsafe {
            let v = nonblocking as c_int;
            cvt(libc::ioctl(self.as_raw_fd(), libc::FIONBIO, &amp;v))?;
            Ok(())
        }
    }

    //复制文件描述符
    pub fn duplicate(&amp;self) -&gt; io::Result&lt;FileDesc&gt; {
        Ok(Self(self.0.try_clone()?))
    }

    //后继可以加入其他需要的通用文件操作方法
}

impl AsInner&lt;OwnedFd&gt; for FileDesc {
    //不消费FileDesc获取内部引用
    fn as_inner(&amp;self) -&gt; &amp;OwnedFd {
        &amp;self.0
    }
}

impl IntoInner&lt;OwnedFd&gt; for FileDesc {
    fn into_inner(self) -&gt; OwnedFd {
        //消费self，获得内部OwnedFd
        //不必做其他资源释放操作
        self.0
    }
}

impl FromInner&lt;OwnedFd&gt; for FileDesc {
    //从参数创建FileDesc类型变量
    fn from_inner(owned_fd: OwnedFd) -&gt; Self {
        Self(owned_fd)
    }
}

impl AsFd for FileDesc {
    //创建一个引用
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        self.0.as_fd()
    }
}

impl AsRawFd for FileDesc {
    //简化代码
    fn as_raw_fd(&amp;self) -&gt; RawFd {
        self.0.as_raw_fd()
    }
}

impl IntoRawFd for FileDesc {
    fn into_raw_fd(self) -&gt; RawFd {
        //见OwnedFd::into_raw_fd
        self.0.into_raw_fd()
    }
}

impl FromRawFd for FileDesc {
    //见OwnedFd::from_raw_fd
    unsafe fn from_raw_fd(raw_fd: RawFd) -&gt; Self {
        Self(FromRawFd::from_raw_fd(raw_fd))
    }
}

<span class="boring">}</span></code></pre></pre>
<p>以上代码要细心体会RUST所有权及借用概念是如何在文件描述符来使用的。</p>
<h1 id="std库进程管理代码分析"><a class="header" href="#std库进程管理代码分析">std库进程管理代码分析</a></h1>
<p>在服务器端，服务器程序经常需要创建进程以完成一些任务。在客户端进程管理最显著的应用场景是操作系统的shell。另外，在目前JS成为主导地位的界面编程中，一个桌面应用分为前端进程及后端进程也是一种可行的架构。<br />
描述进程管理的需求以一个linux的shell命令比较合适：
例如： cat 序言.md | more
在shell程序执行这条命令时，做了以下的工作：</p>
<ol>
<li>创建1个管道</li>
<li>fork第一个子进程</li>
<li>指定第一个子进程的标准输入是管道的读出端</li>
<li>第一个子进程用execv执行more的可执行文件</li>
<li>fork第二个子进程</li>
<li>第二个子进程用execv执行cat可执行文件, &quot;序言.md&quot;作为参数</li>
<li>wait两个子进程结束
上例如果用RUST来实现，代码简略如下：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let child_more = Command::new(&quot;more&quot;)
                           .stdin(Stdio::piped())
                           .spawn()
                           .expect(&quot;error more&quot;);
    let child_cat = Command::new(&quot;cat&quot;)
                          .arg(&quot;引言.md&quot;)
                          .stdout(child_more.stdin.unwrap())
                          .spawn().expect(&quot;cat error&quot;);              
<span class="boring">}</span></code></pre></pre>
<p>可以看到，RUST代码相当简单及易于理解。注意这里不要与C语言的system函数相比较，system实际上创建一个shell进程执行system的输入命令。属于在以上所述的基础在上一层的逻辑层面。<br />
RUST进程管理的任务基本如上所述。<br />
RUST进程管理在操作系统适配层涉及到：</p>
<ol>
<li>匿名管道</li>
<li>进程管理</li>
</ol>
<p>适配层扩展主要是标准输入/输出/错误及重定向的RUST实现</p>
<p>RUST标准库对外提供的进程管理是Command及其的方法和函数。</p>
<p>操作系统无关的代码路径：library/src/std/src/process.rs<br />
library/src/std/src/syscommon/process.rs
操作系统相关的代码路径：library/src/std/src/sys/unix/process/*<br />
library/src/std/src/os/linux/process.rs<br />
library/src/std/src/sys/unix/pipe.rs</p>
<h2 id="匿名管道"><a class="header" href="#匿名管道">匿名管道</a></h2>
<p>匿名管道被设计用来在父子进程或者同一个父进程创建的子进程之间进行通信。一般只用于标准输入及输出的重定向。以下是Linux的实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//匿名管道的资源用文件描述符表示
pub struct AnonPipe(FileDesc);

//创建管道的函数，管道只能通过这个函数完成创建
pub fn anon_pipe() -&gt; io::Result&lt;(AnonPipe, AnonPipe)&gt; {
    //匿名管道会创建两个文件描述符
    let mut fds = [0; 2];

    unsafe {
        //pipe2系统调用，fds的类型RUST做了推断，O_CLOEXEC表示后继exec调用的时候会自动close
        cvt(libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC))?;
        //返回两个匿名管道,AnonPipe生命周期终结的时候会close此处创建的fd, 返回的第一个管道是读出，
        // 第二个管道是写入
        Ok((AnonPipe(FileDesc::from_raw_fd(fds[0])), AnonPipe(FileDesc::from_raw_fd(fds[1]))))
    }
}
//FileDesc的adapter
//管道创建以后的读写操作
impl AnonPipe {
    pub fn read(&amp;self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //就是对内部FileDesc的同名函数调用，
        //后继的函数逻辑也相同，代码省略
        self.0.read(buf)
    }

    pub fn read_vectored(&amp;self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {...}

    pub fn is_read_vectored(&amp;self) -&gt; bool {...}

    pub fn write(&amp;self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {...}

    pub fn write_vectored(&amp;self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {...}

    pub fn is_write_vectored(&amp;self) -&gt; bool {...}
}

//为了进程管理专门实现的函数，可以从中看一下RUST的多路通道读的程序
pub fn read2(p1: AnonPipe, v1: &amp;mut Vec&lt;u8&gt;, p2: AnonPipe, v2: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;()&gt; {
    // 获取C调用的文件描述符
    let p1 = p1.into_inner();
    let p2 = p2.into_inner();
    //需要设置成非阻塞，后继用异步读的方式
    p1.set_nonblocking(true)?;
    p2.set_nonblocking(true)?;

    //准备libc的poll调用参数，具体的细节请参考libc的手册
    let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };
    fds[0].fd = p1.as_raw_fd();
    fds[0].events = libc::POLLIN;
    fds[1].fd = p2.as_raw_fd();
    fds[1].events = libc::POLLIN;
    loop {
        // poll调用，当任意一个fd有内容可读事件，则返回，否则阻塞
        cvt_r(|| unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) })?;

        //fds[0]读到v1
        if fds[0].revents != 0 &amp;&amp; read(&amp;p1, v1)? {
            // 见下面read返回Ok(true)的说明，
            // 此函数的两个文件是联动的,读到其中一个即认为任务结束
            // 另一个也很快会输出，后继要阻塞等能读到p2为止 
            p2.set_nonblocking(false)?;
            //因为返回是Result&lt;()&gt;类型，此处用drop将Result&lt;usize&gt;转换为
            // Result&lt;()&gt;
            return p2.read_to_end(v2).map(drop);
        }
        if fds[1].revents != 0 &amp;&amp; read(&amp;p2, v2)? {
            //见上
            p1.set_nonblocking(false)?;
            return p1.read_to_end(v1).map(drop);
        }
    }

    fn read(fd: &amp;FileDesc, dst: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;bool, io::Error&gt; {
        //一直读完
        match fd.read_to_end(dst) {
            //读到内容
            Ok(_) =&gt; Ok(true),
            Err(e) =&gt; {
                if e.raw_os_error() == Some(libc::EWOULDBLOCK)
                    || e.raw_os_error() == Some(libc::EAGAIN)
                {
                    //没有读到内容，但实际没有出错
                    Ok(false)
                } else {
                    //读出错
                    Err(e)
                }
            }
        }
    }
    //必然会在前面返回。这里会对p1及p2做所有权释放，会close掉创建的管道文件
}
<span class="boring">}</span></code></pre></pre>
<p>下节中既可以看到进程管理函数对pipe使用的例子。</p>
<h2 id="标准输入输出重定向类型及实现"><a class="header" href="#标准输入输出重定向类型及实现">标准输入输出重定向类型及实现</a></h2>
<p>在pipe的基础上，对重定向实现的支持类型结构。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//当创建子进程时，需要对子进程的标准输入/输出/错误每一个的配置
//指定为此结构中的一种类型。
pub enum Stdio {
    //继承父进程的fd
    Inherit,
    //设置为Null
    Null,
    //创建匿名管道作为标准输入/输出/错误
    MakePipe,
    //标准输入/输出/错误使用给出的文件描述符
    Fd(FileDesc),
}

// 创建子进程时，父进程针对于子进程的标准输入/输出/错误的对应管道配置
// 此时管道已经创建
pub struct StdioPipes {
    //None表示不重定向，Some()表示重定向到匿名管道
    pub stdin: Option&lt;AnonPipe&gt;,
    pub stdout: Option&lt;AnonPipe&gt;,
    pub stderr: Option&lt;AnonPipe&gt;,
}

// 对于子进程的标准输入/输出/错误完成准备后，调用操作系统创建进程时，
// 对子进程的标准输入/输出/错误每一个指定为下面结构中的一种类型
pub enum ChildStdio {
    //继承父进程的标准输入输出错误fd
    Inherit,
    //设置fd为参数
    Explicit(c_int),
    //从RUST的FileDesc中的信息设置fd 
    Owned(FileDesc),
}
//准备完毕后，此类型结构具有子进程的标准输入/输出/错误的完整设置
pub struct ChildPipes {
    pub stdin: ChildStdio,
    pub stdout: ChildStdio,
    pub stderr: ChildStdio,
}
//针对Stdio实现方法
impl Stdio {
    // 此方法是父进程与子进程的标准输入/输出/错误的准备方法，每次准备三者其一,
    // 此方法的输出会设置 StdioPipes及childPipes的变量
    pub fn to_child_stdio(&amp;self, readable: bool) -&gt; io::Result&lt;(ChildStdio, Option&lt;AnonPipe&gt;)&gt; {
        match *self {
            //指定为继承父进程，子进程为继承父进程，父进程没有与之相关的管道
            Stdio::Inherit =&gt; Ok((ChildStdio::Inherit, None)),

            //配置为使用指定的文件描述符
            Stdio::Fd(ref fd) =&gt; {
                if fd.as_raw_fd() &gt;= 0 &amp;&amp; fd.as_raw_fd() &lt;= libc::STDERR_FILENO {
                    //如果指定的文件描述符是标准输入/输出/错误，则复制后返回Owned,
                    //父进程没有管道与子进程连接
                    Ok((ChildStdio::Owned(fd.duplicate()?), None))
                } else {
                    //子进程使用指定的文件描述符，此时因为不能获取FileDesc的所有权，所以只能使用RawFd，父进程没有管道与之连接
                    Ok((ChildStdio::Explicit(fd.as_raw_fd()), None))
                }
            }

            //配置为创建管道连接父子进程
            Stdio::MakePipe =&gt; {
                //创建管道, 
                let (reader, writer) = pipe::anon_pipe()?;
                //根据读写标志设置自身管道的文件描述符, readable为真指子进程是读方
                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };
                //返回创建的管道描述符
                Ok((ChildStdio::Owned(theirs.into_inner()), Some(ours)))
            }

            //指定为dev/null
            Stdio::Null =&gt; {
                let mut opts = OpenOptions::new();
                opts.read(readable);
                opts.write(!readable);
                let path = unsafe { CStr::from_ptr(DEV_NULL.as_ptr() as *const _) };
                //需要先打开/dev/null
                let fd = File::open_c(&amp;path, &amp;opts)?;
                //输出为/dev/null的fd
                Ok((ChildStdio::Owned(fd.into_inner()), None))
            }
        }
    }
}

impl From&lt;AnonPipe&gt; for Stdio {
    fn from(pipe: AnonPipe) -&gt; Stdio {
        Stdio::Fd(pipe.into_inner())
    }
}

impl From&lt;File&gt; for Stdio {
    fn from(file: File) -&gt; Stdio {
        Stdio::Fd(file.into_inner())
    }
}
//直接获取RawFd用于操作系统调用
impl ChildStdio {
    pub fn fd(&amp;self) -&gt; Option&lt;c_int&gt; {
        match *self {
            ChildStdio::Inherit =&gt; None,
            ChildStdio::Explicit(fd) =&gt; Some(fd),
            ChildStdio::Owned(ref fd) =&gt; Some(fd.as_raw_fd()),
        }
    }
}
//以下是上面代码的一个使用的实例：
impl Command {
    ......

    //setup_io作为创建子进程的标准输入/输出/错误的准备函数
    //形成父进程与子进程标准输入/输出/错误的必要的管道创建及
    // 配对返回
    pub fn setup_io(
        &amp;self,
        default: Stdio,
        needs_stdin: bool,
    ) -&gt; io::Result&lt;(StdioPipes, ChildPipes)&gt; {
        let null = Stdio::Null;
        let default_stdin = if needs_stdin { &amp;default } else { &amp;null };
        //没有配置的话就使用默认配置, stdin/stdout/stderr是Stdio类型变量
        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);
        let stdout = self.stdout.as_ref().unwrap_or(&amp;default);
        let stderr = self.stderr.as_ref().unwrap_or(&amp;default);
        //创建标准输入的子进程文件对,their用于子进程，our用于本进程
        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;
        //创建标准输出的子进程文件对
        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;
        //创建标准错误的子进程文件对 
        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;
        //完成本进程的设置
        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };
        //完成子进程的设置
        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };
        Ok((ours, theirs))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>管道是类unix系统实现多个进程组合完成一个大的任务的有效特性。</p>
<h2 id="进程管理"><a class="header" href="#进程管理">进程管理</a></h2>
<p>使用RUST的创建进程的代码举例如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::process::Command;

Command::new(&quot;ls&quot;)
        .arg(&quot;-l&quot;)
        .arg(&quot;-a&quot;)
        .stdout(Stdio::piped())
        .spawn()
        .expect(&quot;ls command failed to start&quot;);
<span class="boring">}</span></code></pre></pre>
<p>可以看到，RUST把C语言库中分散的进程准备及执行相关的内容整体组织进了Command结构的实现中，并利用函数式编程的链式调用使其语法易于理解，从后面的实现中也可以看出Command对程序员是一个巨大的福利。
Command的具体使用方式请参考官方标准库文档获得指导。</p>
<p>RUST中操作系统适配层对其他模块提供的接口类型结构及实现：<br />
RUST在进程管理的操作系统适配层的设计中，没有使用trait的设计方式。而是直接使用了各操作系统统一实现相同类型名称的类型，再对类型实现相同名字及参数的方法。<br />
因为在编译中每种操作系统都会单独编译，所以这种方式方便有效，也是C语言跨操作系统经常采用的代码组织方法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//以下以linux为例的Process进程类型结构, 
//各操作系统针对Process的结构体成员定义可以不同，但必须是Process类型名并对Process实现同样的方法。
pub struct Process {
    //进程pid
    pid: pid_t,
    //退出的状态
    status: Option&lt;ExitStatus&gt;,
    // Linux上，每个process与一个fd相关联。
    #[cfg(target_os = &quot;linux&quot;)]
    pidfd: Option&lt;PidFd&gt;,
}
//Process的方法实现
impl Process {
    //linux的创建方法，应该在fork函数调用以后才能调用此方法
    #[cfg(target_os = &quot;linux&quot;)]
    unsafe fn new(pid: pid_t, pidfd: pid_t) -&gt; Self {
        use crate::os::unix::io::FromRawFd;
        use crate::sys_common::FromInner;
        // Safety: If `pidfd` is nonnegative, we assume it's valid and otherwise unowned.
        let pidfd = (pidfd &gt;= 0).then(|| PidFd::from_inner(sys::fd::FileDesc::from_raw_fd(pidfd)));
        Process { pid, status: None, pidfd }
    }

    //父进程调用此函数杀掉子进程
    pub fn kill(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        // 假如子进程已经是退出状态，那子进程的pid可能已经分配给其他进程使用，此时需要返回错误。
        if self.status.is_some() {
            Err(io::const_io_error!(
                ErrorKind::InvalidInput,
                &quot;invalid argument: can't kill an exited process&quot;,
            ))
        } else {
            //libc库的kill调用
            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)
        }
    }

    //父进程等待子进程结束，会引发阻塞
    pub fn wait(&amp;mut self) -&gt; io::Result&lt;ExitStatus&gt; {
        use crate::sys::cvt_r;

        //判断子进程是否已经退出
        if let Some(status) = self.status {
            return Ok(status);
        }

        let mut status = 0 as c_int;
        //调用libc的waitpid等待子进程结束
        cvt_r(|| unsafe { libc::waitpid(self.pid, &amp;mut status, 0) })?;
        //子进程已经退出，设置合适的状态
        self.status = Some(ExitStatus::new(status));
        Ok(ExitStatus::new(status))
    }

    //非阻塞的等待子进程退出
    pub fn try_wait(&amp;mut self) -&gt; io::Result&lt;Option&lt;ExitStatus&gt;&gt; {
        if let Some(status) = self.status {
            return Ok(Some(status));
        }
        let mut status = 0 as c_int;
        //用libc::WNOHANG表示非阻塞
        let pid = cvt(unsafe { libc::waitpid(self.pid, &amp;mut status, libc::WNOHANG) })?;
        if pid == 0 {
            //没有退出
            Ok(None)
        } else {
            //已经退出
            self.status = Some(ExitStatus::new(status));
            Ok(Some(ExitStatus::new(status)))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因为wasi进程管理与unix类似，因此下面再给出windows的代码做一下对比：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Process {
    //windows句柄
    handle: Handle,
}

impl Process {
    pub fn kill(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        //使用windows的系统调用
        cvt(unsafe { c::TerminateProcess(self.handle.as_raw_handle(), 1) })?;
        Ok(())
    }

    pub fn wait(&amp;mut self) -&gt; io::Result&lt;ExitStatus&gt; {
        unsafe {
            //windows使用如下调用来等待进程退出
            let res = c::WaitForSingleObject(self.handle.as_raw_handle(), c::INFINITE);
            if res != c::WAIT_OBJECT_0 {
                return Err(Error::last_os_error());
            }
            let mut status = 0;
            //额外调用来获取退出码
            cvt(c::GetExitCodeProcess(self.handle.as_raw_handle(), &amp;mut status))?;
            Ok(ExitStatus(status))
        }
    }

    pub fn try_wait(&amp;mut self) -&gt; io::Result&lt;Option&lt;ExitStatus&gt;&gt; {
        unsafe {
            //不等待
            match c::WaitForSingleObject(self.handle.as_raw_handle(), 0) {
                c::WAIT_OBJECT_0 =&gt; {}
                c::WAIT_TIMEOUT =&gt; {
                    return Ok(None);
                }
                _ =&gt; return Err(io::Error::last_os_error()),
            }
            //获取退出码
            let mut status = 0;
            cvt(c::GetExitCodeProcess(self.handle.as_raw_handle(), &amp;mut status))?;
            Ok(Some(ExitStatus(status)))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>由上可见，不同的操作系统实现了相同的类型名及类型方法。<br />
其他进程管理相关的类型结构及方法实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Command完成进程准备的所有参数，进程启动等, 操作系统适配层及标准库对外接口都有Command名称的类型，
//要注意区别， 此处是操作系统适配层的实现。
pub struct Command {
    //进程的可执行文件名.
    program: CString,
    //进程的命令行参数,同上，是否支持中文？  
    args: Vec&lt;CString&gt;,
    /// 传递给`execvp`的参数, 第一个参数应该是`program`, 然后是
    /// `args`, 最后应该是`null`. 修改时需要注意这三个参数的联动性
    argv: Argv,
    env: CommandEnv,

    //当前目录
    cwd: Option&lt;CString&gt;,
    //unix的uid
    uid: Option&lt;uid_t&gt;,
    //unix的gid
    gid: Option&lt;gid_t&gt;,
    // 对CString参数的输入是否存在0做标识
    saw_nul: bool,
    closures: Vec&lt;Box&lt;dyn FnMut() -&gt; io::Result&lt;()&gt; + Send + Sync&gt;&gt;,
    groups: Option&lt;Box&lt;[gid_t]&gt;&gt;,
    //标准输入配置
    stdin: Option&lt;Stdio&gt;,
    //标准输出配置
    stdout: Option&lt;Stdio&gt;,
    //标准错误配置
    stderr: Option&lt;Stdio&gt;,
    #[cfg(target_os = &quot;linux&quot;)]
    create_pidfd: bool,
    pgroup: Option&lt;pid_t&gt;,
}

impl Command {
    pub fn new(program: &amp;OsStr) -&gt; Command {
        let mut saw_nul = false;
        //OsStr转换为CStr,并返回OsStr是否存在尾值0
        let program = os2c(program, &amp;mut saw_nul);
        //用program创建默认的Command结构体
        Command {
            //argv尾部必须有一个null指针
            argv: Argv(vec![program.as_ptr(), ptr::null()]),
            args: vec![program.clone()],
            //同名参数赋值
            program,
            env: Default::default(),
            cwd: None,
            uid: None,
            gid: None,
            saw_nul,
            closures: Vec::new(),
            groups: None,
            stdin: None,
            stdout: None,
            stderr: None,
            create_pidfd: false,
            pgroup: None,
        }
    }

    //这个方法设置进程的执行文件名program作为第一个arg参数
    pub fn set_arg_0(&amp;mut self, arg: &amp;OsStr) {
        // Set a new arg0
        let arg = os2c(arg, &amp;mut self.saw_nul);
        debug_assert!(self.argv.0.len() &gt; 1);
        self.argv.0[0] = arg.as_ptr();
        self.args[0] = arg;
    }

    //此方法增加增加一个进程命令的参数
    pub fn arg(&amp;mut self, arg: &amp;OsStr) {
        let arg = os2c(arg, &amp;mut self.saw_nul);
        //增加参数到argv
        self.argv.0[self.args.len()] = arg.as_ptr();
        self.argv.0.push(ptr::null());

        //增加参数到args
        self.args.push(arg);
    }

    //根据标准输入/输出/错误的配置完成动作
    pub fn setup_io(
        &amp;self,
        default: Stdio,
        needs_stdin: bool,
    ) -&gt; io::Result&lt;(StdioPipes, ChildPipes)&gt; {
        let null = Stdio::Null;
        let default_stdin = if needs_stdin { &amp;default } else { &amp;null };
        //没有配置的话就使用默认配置
        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);
        let stdout = self.stdout.as_ref().unwrap_or(&amp;default);
        let stderr = self.stderr.as_ref().unwrap_or(&amp;default);
        //创建标准输入的子进程文件对,their用于子进程，our用于本进程
        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;
        //创建标准输出的子进程文件对
        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;
        //创建标准错误的子进程文件对 
        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;
        //完成本进程的设置
        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };
        //完成子进程的设置
        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };
        Ok((ours, theirs))
    }
<span class="boring">}</span></code></pre></pre>
<p>以下为创建进程的方法实现，从以下代码可见，在底层面向操作系统调用编程时，<br />
RUST可近似的认为C代码，复杂及容易出现问题。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //创建进程的具体执行方法
    pub fn spawn(
        &amp;mut self,
        default: Stdio,
        needs_stdin: bool,
    ) -&gt; io::Result&lt;(Process, StdioPipes)&gt; {
        //父子进程结果通信的魔数
        const CLOEXEC_MSG_FOOTER: [u8; 4] = *b&quot;NOEX&quot;;

        //完成环境变量创建
        let envp = self.capture_env();

        //命令行出错处理
        if self.saw_nul() {
            return Err(io::const_io_error!(
                ErrorKind::InvalidInput,
                &quot;nul byte found in provided data&quot;,
            ));
        }

        //完成标准输入/输出/错误文件的创建与准备
        let (ours, theirs) = self.setup_io(default, needs_stdin)?;

        //利用posix的api来创建进程
        if let Some(ret) = self.posix_spawn(&amp;theirs, envp.as_ref())? {
            return Ok((ret, ours));
        }

        //创建一个匿名管道,这个匿名管道用来捕捉exec的错误
        let (input, output) = sys::pipe::anon_pipe()?;

        //此时要对环境参数加锁
        let env_lock = sys::os::env_read_lock();
        //fork新的进程, 新进程复制所有的老进程的参数和栈
        let (pid, pidfd) = unsafe { self.do_fork()? };

        if pid == 0 {
            //新创建的子进程, 总是abort退出
            crate::panic::always_abort();
            //不用理会env_lock，父进程会处理,这个细节RUST和C是一样容易出错的
            mem::forget(env_lock);
            //子进程不使用input
            drop(input);
            //执行二进制可执行文件,执行成功不会返回, exec执行成功后,因为output设置了FD_CLOEXEC，
            //所以output会被关闭
            let Err(err) = unsafe { self.do_exec(theirs, envp.as_ref()) };
            //exec执行失败,做错误处理
            let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;
            let errno = errno.to_be_bytes();
            let bytes = [
                errno[0],
                errno[1],
                errno[2],
                errno[3],
                CLOEXEC_MSG_FOOTER[0],
                CLOEXEC_MSG_FOOTER[1],
                CLOEXEC_MSG_FOOTER[2],
                CLOEXEC_MSG_FOOTER[3],
            ];
            // 将exec的错误写入管道，使得父进程能够获得
            // 这里是一个细致的考虑
            rtassert!(output.write(&amp;bytes).is_ok());
            unsafe { libc::_exit(1) }
        }

        //对env_lock进行处理
        drop(env_lock);
        //不需要output，要显式drop
        drop(output);

        //根据fork的返回创建RUST的子进程结构
        let mut p = unsafe { Process::new(pid, pidfd) };
        let mut bytes = [0; 8];

        loop {
            //如果子进程exec成功，则管道对端会关闭，此处read会返回
            match input.read(&amp;mut bytes) {
                //子进程成功执行
                Ok(0) =&gt; return Ok((p, ours)),
                //子进程exec失败，返回错误
                Ok(8) =&gt; {
                    let (errno, footer) = bytes.split_at(4);
                    assert_eq!(
                        CLOEXEC_MSG_FOOTER, footer,
                        &quot;Validation on the CLOEXEC pipe failed: {:?}&quot;,
                        bytes
                    );
                    let errno = i32::from_be_bytes(errno.try_into().unwrap());
                    //子进程失败时做个等待
                    assert!(p.wait().is_ok(), &quot;wait() should either return Ok or panic&quot;);
                    return Err(Error::from_raw_os_error(errno));
                }
                //以下为其他失败情况
                Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
                Err(e) =&gt; {
                    assert!(p.wait().is_ok(), &quot;wait() should either return Ok or panic&quot;);
                    panic!(&quot;the CLOEXEC pipe failed: {e:?}&quot;)
                }
                Ok(..) =&gt; {
                    // pipe I/O up to PIPE_BUF bytes should be atomic
                    assert!(p.wait().is_ok(), &quot;wait() should either return Ok or panic&quot;);
                    panic!(&quot;short read on the CLOEXEC pipe&quot;)
                }
            }
        }
    }

    //fork系统调用的RUST版本,不做更多分析
    unsafe fn do_fork(&amp;mut self) -&gt; Result&lt;(pid_t, pid_t), io::Error&gt; {
        use crate::sync::atomic::{AtomicBool, Ordering};

        static HAS_CLONE3: AtomicBool = AtomicBool::new(true);
        const CLONE_PIDFD: u64 = 0x00001000;

        #[repr(C)]
        struct clone_args {
            flags: u64,
            pidfd: u64,
            child_tid: u64,
            parent_tid: u64,
            exit_signal: u64,
            stack: u64,
            stack_size: u64,
            tls: u64,
            set_tid: u64,
            set_tid_size: u64,
            cgroup: u64,
        }

        raw_syscall! {
            fn clone3(cl_args: *mut clone_args, len: libc::size_t) -&gt; libc::c_long
        }

        // Bypassing libc for `clone3` can make further libc calls unsafe,
        // so we use it sparingly for now. See #89522 for details.
        // Some tools (e.g. sandboxing tools) may also expect `fork`
        // rather than `clone3`.
        let want_clone3_pidfd = self.get_create_pidfd();

        // If we fail to create a pidfd for any reason, this will
        // stay as -1, which indicates an error.
        let mut pidfd: pid_t = -1;

        // Attempt to use the `clone3` syscall, which supports more arguments
        // (in particular, the ability to create a pidfd). If this fails,
        // we will fall through this block to a call to `fork()`
        if want_clone3_pidfd &amp;&amp; HAS_CLONE3.load(Ordering::Relaxed) {
            let mut args = clone_args {
                flags: CLONE_PIDFD,
                pidfd: &amp;mut pidfd as *mut pid_t as u64,
                child_tid: 0,
                parent_tid: 0,
                exit_signal: libc::SIGCHLD as u64,
                stack: 0,
                stack_size: 0,
                tls: 0,
                set_tid: 0,
                set_tid_size: 0,
                cgroup: 0,
            };

            let args_ptr = &amp;mut args as *mut clone_args;
            let args_size = crate::mem::size_of::&lt;clone_args&gt;();

            let res = cvt(clone3(args_ptr, args_size));
            match res {
                Ok(n) =&gt; return Ok((n as pid_t, pidfd)),
                Err(e) =&gt; match e.raw_os_error() {
                    // Multiple threads can race to execute this store,
                    // but that's fine - that just means that multiple threads
                    // will have tried and failed to execute the same syscall,
                    // with no other side effects.
                    Some(libc::ENOSYS) =&gt; HAS_CLONE3.store(false, Ordering::Relaxed),
                    // Fallback to fork if `EPERM` is returned. (e.g. blocked by seccomp)
                    Some(libc::EPERM) =&gt; {}
                    _ =&gt; return Err(e),
                },
            }
        }

        // Generally, we just call `fork`. If we get here after wanting `clone3`,
        // then the syscall does not exist or we do not have permission to call it.
        cvt(libc::fork()).map(|res| (res, pidfd))
    }

    // 执行二进制文件,值得注意的是，调用execvp, 函数将不再返回，从而导致父进程已经申请的内存及
    // 文件描述符资源会错误的被处理，因此，这个函数整体的安全规则仍然与C语言调用execvp的规则一致，
    // RUST的安全规则在此处起不到更大的帮助
    unsafe fn do_exec(
        &amp;mut self,
        stdio: ChildPipes,
        maybe_envp: Option&lt;&amp;CStringArray&gt;,
    ) -&gt; Result&lt;!, io::Error&gt; {
        use crate::sys::{self, cvt_r};

        //用dup2系统调用设置本进程的标准输入/输出/错误
        if let Some(fd) = stdio.stdin.fd() {
            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;
        }
        if let Some(fd) = stdio.stdout.fd() {
            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;
        }
        if let Some(fd) = stdio.stderr.fd() {
            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;
        }

        //设置进程其他参数，具体请参考libc的编程手册获得相关函数指导
        {
            if let Some(_g) = self.get_groups() {
                cvt(libc::setgroups(_g.len().try_into().unwrap(), _g.as_ptr()))?;
            }
            if let Some(u) = self.get_gid() {
                cvt(libc::setgid(u as gid_t))?;
            }
            if let Some(u) = self.get_uid() {
                if libc::getuid() == 0 &amp;&amp; self.get_groups().is_none() {
                    cvt(libc::setgroups(0, ptr::null()))?;
                }
                cvt(libc::setuid(u as uid_t))?;
            }
        }
        if let Some(ref cwd) = *self.get_cwd() {
            cvt(libc::chdir(cwd.as_ptr()))?;
        }

        if let Some(pgroup) = self.get_pgroup() {
            cvt(libc::setpgid(0, pgroup))?;
        }

        {
            //对进程接收的信号进行设置
            use crate::mem::MaybeUninit;
            //注意这里用MaybeUninit申请了一个栈变量，后继需要给C函数使用
            //因为不能由RUST做drop，所以用uninit(),这是调用C的通常用法
            let mut set = MaybeUninit::&lt;libc::sigset_t&gt;::uninit();
            //这些设置，execvp执行后，那边的代码会重新设置
            cvt(sigemptyset(set.as_mut_ptr()))?;
            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), ptr::null_mut()))?;

            {
                //设置PIPE为默认处理
                let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);
                if ret == libc::SIG_ERR {
                    return Err(io::Error::last_os_error());
                }
            }
        }

        //用于在执行二进制之前做些提前设置的回调闭包操作,如统计信息和log日志之类
        //考虑很完善
        for callback in self.get_closures().iter_mut() {
            callback()?;
        }

        //以下用于在exec出错的时候恢复环境变量,这个地方是RUST细心对安全考虑的地方
        //请细心体会以下下面利用生命周期的错误处理方式
        let mut _reset = None;
        if let Some(envp) = maybe_envp {
            struct Reset(*const *const libc::c_char);

            impl Drop for Reset {
                fn drop(&amp;mut self) {
                    unsafe {
                        *sys::os::environ() = self.0;
                    }
                }
            }

            _reset = Some(Reset(*sys::os::environ()));
            *sys::os::environ() = envp.as_ptr();
        }

        //调用execvp执行二进制文件
        libc::execvp(self.get_program_cstr().as_ptr(), self.get_argv().as_ptr());
        //返回证明出错
        Err(io::Error::last_os_error())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上是RUST操作系统适配层的代码分析。</p>
<p>RUST标准库对外提供的进程管理类型结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::sys::process as imp;
// Child用来保存创建的子进程的信息, 
// 其实质是Process的封装结构，Child被用来
// 作为单个子进程的管理信息的类型结构。每个Child变量
// 保存一个子进程的所有管理信息
pub struct Child {
    //系统分配的子进程的标识句柄
    pub(crate) handle: imp::Process,

    //父进程用此向子进程标准输入写入通信信息
    pub stdin: Option&lt;ChildStdin&gt;,

    //父进程用此从子进程标准输出读出通信信息
    pub stdout: Option&lt;ChildStdout&gt;,

    //父进程用此从子进程标准错误读出错误信息
    pub stderr: Option&lt;ChildStderr&gt;,
}

//父进程保留的与子进程标准输入/输出/错误相对应的管道信息
pub struct ChildStdin {
    inner: AnonPipe,
}
pub struct ChildStdout {
    inner: AnonPipe,
}
pub struct ChildStderr {
    inner: AnonPipe,
}

//Command用于其他模块对进程管理操作的界面
pub struct Command {
    inner: imp::Command,
}
impl Command {
    //输入进程的二进制可执行文件的路径及名称，
    pub fn new&lt;S: AsRef&lt;OsStr&gt;&gt;(program: S) -&gt; Command {
        Command { inner: imp::Command::new(program.as_ref()) }
    }

    //输入一个进程命令的参数
    pub fn arg&lt;S: AsRef&lt;OsStr&gt;&gt;(&amp;mut self, arg: S) -&gt; &amp;mut Command {
        self.inner.arg(arg.as_ref());
        self
    }

    //输入若干进程命令的参数
    pub fn args&lt;I, S&gt;(&amp;mut self, args: I) -&gt; &amp;mut Command
    where
        I: IntoIterator&lt;Item = S&gt;,
        S: AsRef&lt;OsStr&gt;,
    {
        for arg in args {
            self.arg(arg.as_ref());
        }
        self
    }

    //针对进程插入或设置一个环境参数
    pub fn env&lt;K, V&gt;(&amp;mut self, key: K, val: V) -&gt; &amp;mut Command
    where
        K: AsRef&lt;OsStr&gt;,
        V: AsRef&lt;OsStr&gt;,
    {
        self.inner.env_mut().set(key.as_ref(), val.as_ref());
        self
    }

    //插入或设置若干个环境参数
    pub fn envs&lt;I, K, V&gt;(&amp;mut self, vars: I) -&gt; &amp;mut Command
    where
        I: IntoIterator&lt;Item = (K, V)&gt;,
        K: AsRef&lt;OsStr&gt;,
        V: AsRef&lt;OsStr&gt;,
    {
        for (ref key, ref val) in vars {
            self.inner.env_mut().set(key.as_ref(), val.as_ref());
        }
        self
    }

    //清除一个环境参数
    pub fn env_remove&lt;K: AsRef&lt;OsStr&gt;&gt;(&amp;mut self, key: K) -&gt; &amp;mut Command {
        self.inner.env_mut().remove(key.as_ref());
        self
    }

    //清除所有环境参数
    pub fn env_clear(&amp;mut self) -&gt; &amp;mut Command {
        self.inner.env_mut().clear();
        self
    }

    //获取当前目录
    pub fn current_dir&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, dir: P) -&gt; &amp;mut Command {
        self.inner.cwd(dir.as_ref().as_ref());
        self
    }

    //配置标准输入, 此处的Stdio见后面的代码，与imp::Stdio不同。
    pub fn stdin&lt;T: Into&lt;Stdio&gt;&gt;(&amp;mut self, cfg: T) -&gt; &amp;mut Command {
        self.inner.stdin(cfg.into().0);
        self
    }

    //配置标准输出
    pub fn stdout&lt;T: Into&lt;Stdio&gt;&gt;(&amp;mut self, cfg: T) -&gt; &amp;mut Command {
        self.inner.stdout(cfg.into().0);
        self
    }
    
    //配置标准错误
    pub fn stderr&lt;T: Into&lt;Stdio&gt;&gt;(&amp;mut self, cfg: T) -&gt; &amp;mut Command {
        self.inner.stderr(cfg.into().0);
        self
    }

    //正式按照Command的参数创建进程
    pub fn spawn(&amp;mut self) -&gt; io::Result&lt;Child&gt; {
        self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)
    }

    //创建子进程，并等待子进程结束,返回Output结构变量
    pub fn output(&amp;mut self) -&gt; io::Result&lt;Output&gt; {
        self.inner
            .spawn(imp::Stdio::MakePipe, false)
            .map(Child::from_inner)
            .and_then(|p| p.wait_with_output())
    }

    //创建子进程，等待进程结束，返回进程退出码
    pub fn status(&amp;mut self) -&gt; io::Result&lt;ExitStatus&gt; {
        self.inner
            .spawn(imp::Stdio::Inherit, true)
            .map(Child::from_inner)
            .and_then(|mut p| p.wait())
    }

    ...    
}

//进程命令的参数集合
pub struct CommandArgs&lt;'a&gt; {
    inner: imp::CommandArgs&lt;'a&gt;,
}

//保存子进程结束后的输出
pub struct Output {
    //子进程退出的返回码
    pub status: ExitStatus,
    //子进程的标准输出输出的内容
    pub stdout: Vec&lt;u8&gt;,
    //子进程标准错误输出的内容
    pub stderr: Vec&lt;u8&gt;,
}

//标准输入输出的类型结构
pub struct Stdio(imp::Stdio);

impl Stdio {
    //创建一个管道的标准输入输出
    pub fn piped() -&gt; Stdio {
        Stdio(imp::Stdio::MakePipe)
    }
    //继承父进程
    pub fn inherit() -&gt; Stdio {
        Stdio(imp::Stdio::Inherit)
    }

    //使用/dev/null作为进程标准输入输出
    pub fn null() -&gt; Stdio {
        Stdio(imp::Stdio::Null)
    }
}

//对子进程的API
impl Child {
    //杀掉子进程
    pub fn kill(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        self.handle.kill()
    }

    //获取子进程的id值
    pub fn id(&amp;self) -&gt; u32 {
        self.handle.id()
    }

    //等待子进程结束，需要提前释放子进程的标准输入，否则子进程
    //可能不会退出
    pub fn wait(&amp;mut self) -&gt; io::Result&lt;ExitStatus&gt; {
        drop(self.stdin.take());
        self.handle.wait().map(ExitStatus)
    }


    //尝试等子进程退出
    pub fn try_wait(&amp;mut self) -&gt; io::Result&lt;Option&lt;ExitStatus&gt;&gt; {
        Ok(self.handle.try_wait()?.map(ExitStatus))
    }

    //等待子进程退出并获取所有输出
    pub fn wait_with_output(mut self) -&gt; io::Result&lt;Output&gt; {
        //需要先关闭子进程的标准输入
        drop(self.stdin.take());

        //申请缓存
        let (mut stdout, mut stderr) = (Vec::new(), Vec::new());
        match (self.stdout.take(), self.stderr.take()) {
            (None, None) =&gt; {}

            (Some(mut out), None) =&gt; {
                //读子进程标准输出到缓存
                let res = out.read_to_end(&amp;mut stdout);
                res.unwrap();
            }
            (None, Some(mut err)) =&gt; {
                //读标准错误到缓存
                let res = err.read_to_end(&amp;mut stderr);
                res.unwrap();
            }
            (Some(out), Some(err)) =&gt; {
                //读两个，此函数应该专门为这个目的做的设计
                let res = read2(out.inner, &amp;mut stdout, err.inner, &amp;mut stderr);
                res.unwrap();
            }
        }

        //等待子进程结束
        let status = self.wait()?;
        //创建Output返回
        Ok(Output { status, stdout, stderr })
    }
}
//从进程退出并返回一个值，父进程会获得这个值
pub fn exit(code: i32) -&gt; ! {
    crate::rt::cleanup();
    crate::sys::os::exit(code)
}

//异常退出，与exit相比较，不会处理资源释放操作
pub fn abort() -&gt; ! {
    crate::sys::abort_internal();
}
<span class="boring">}</span></code></pre></pre>
<p>不熟悉操作系统的进程操作，基本就没有办法理解进程管理，因此，最关键的仍然是对操作系统系统调用的理解，而操作系统调用实际上又是C编程的较高级的内容。对RUST的std库的深入学习目前仍然需要有较高的C语言编程水平。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发编程相关类型结构代码分析"><a class="header" href="#并发编程相关类型结构代码分析">并发编程相关类型结构代码分析</a></h1>
<p>并发编程主要包括线程及线程间通信内容。并发编程的熟练是程序员迈向高级水平的必由之路和标志之一。<br />
本书认为读者已经很清楚并发的基础概念并且已经有了并发编码的基础。因此会直接涉及到一些并发中比较本质的代码。<br />
按照先通用后特殊的原则，本节内容的先后顺序如下：<br />
<strong>临界区同步</strong>：</p>
<ol>
<li>分析基于linux的RUST底层同步机制，包括futex, mutex, condvar, rwlock等。从linux系统分析，RUST实际上重新构建了自己的线程锁机制。在操作系统的适配层提供了与其他语言类似的类型，方法，函数。</li>
<li>在1的基础上，分析RUST根据自身需求实现的适配扩展层。主要是匹配RUST的静态全局变量而进行了适配</li>
<li>在1,2的基础上，RUST向标准库的使用者提供了屏蔽锁的概念的临界区数据类型。使用临界区数据类型的代码实际可以把临界区数据看成与智能指针类似的数据，不必额外关注线程间的互斥。</li>
</ol>
<p><strong>线程管理</strong>：</p>
<ol>
<li>操作系统的线程结构，函数的适配层， </li>
<li>线程局部存储适配层</li>
<li>线程同步原语的适配层</li>
<li>标准库线程外部接口实现</li>
<li>线程间消息通信的实现 </li>
</ol>
<h2 id="临界区同步的linux适配层"><a class="header" href="#临界区同步的linux适配层">临界区同步的linux适配层</a></h2>
<p>代码路径： library/std/src/sys/unix/locks/*.rs<br />
library/std/src/sys/unix/futex.rs</p>
<h3 id="锁的基础设施futex代码分析"><a class="header" href="#锁的基础设施futex代码分析">锁的基础设施FUTEX代码分析</a></h3>
<p>FUTEX是一种高效率的互斥机制，其本质是将原先分配给内核的部分锁处理代码转移到用户态处理。<br />
所有的临界区锁保护实际上是基于一个原子变量的检测及赋值，当这个原子变量处于一个范围时，允许代码执行，否则，就进入等待队列。当处于临界区的代码执行完毕后，会恢复原子变量唤醒等待队列等待的线程或进程。<br />
传统上，对锁的原子变量的检测是放在内核态的，内核检测及修改原子变量并完成等待阻塞操作或唤醒操作。这显然是一种效率很低的做法，因为大部分时候临界区是不会发生冲突的。每次检测都执行一次内核态与用户态的切换没有必要。因此，诞生了将原子变量检测与赋值放在用户态完成的思路。<br />
这个思路需要完成的需求整体如下：</p>
<ol>
<li>用户态声明一个原子变量作为能否进入临界区的锁。如果该值被设置为某值，代表不能进入临界区，其他值代表可以进入临界区</li>
<li>访问临界区的线程或进程修改原子变量表示要进入临界区，然后探测原子变量，看是否能够进入，能够进入则执行临界区访问</li>
<li>不能进入则调用系统调用进入内核，内核会重新做原子变量判断并决定是否进入等待，这个过程是不可被其他线程打断的。</li>
<li>位于临界区的线程或进程执行完毕临界区代码后，在用户态修改原子变量，并唤醒一个或所有等待的进程或线程</li>
<li>可以满足跨进程</li>
</ol>
<p>futex即是满足这个需求的设计。显然，传统的锁机制如pthread_mutex可以用futex方案重新设计。所以futex实际上是作为传统锁机制的基础设施存在。但对其做了解对于系统级编程仍然是有必要的。</p>
<p>RUST对futex的linux系统实现的适配如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn futex_wait(futex: &amp;AtomicI32, expected: i32, timeout: Option&lt;Duration&gt;) -&gt; bool {
    use super::time::Timespec;
    use crate::ptr::null;
    use crate::sync::atomic::Ordering::Relaxed;

    // 计算超时
    let timespec =
        timeout.and_then(|d| Some(Timespec::now(libc::CLOCK_MONOTONIC).checked_add_duration(&amp;d)?));

    loop {
        // 判断原子变量是否是期待的值
        if futex.load(Relaxed) != expected {
            //不是，直接返回
            return true;
        }

        // 是期待值，进入阻塞处理
        // 以下说明，RUST目前对futex的应用是线程间的同步, 具体的系统调用请参考man手册
        let r = unsafe {
            //futex系统调用
            libc::syscall(
                libc::SYS_futex,
                futex as *const AtomicI32,
                //FUTEX_PRIVATE_FLAG说明仅支持本进程线程间的futex
                libc::FUTEX_WAIT_BITSET | libc::FUTEX_PRIVATE_FLAG,
                //传入的futex是这个值时就阻塞
                expected,
                //超时
                timespec.as_ref().map_or(null(), |t| &amp;t.t as *const libc::timespec),
                null::&lt;u32&gt;(), // This argument is unused for FUTEX_WAIT_BITSET.
                !0u32,         // A full bitmask, to make it behave like a regular FUTEX_WAIT.
            )
        };

        //错误处理, 请参考libc的man手册
        match (r &lt; 0).then(super::os::errno) {
            Some(libc::ETIMEDOUT) =&gt; return false,
            Some(libc::EINTR) =&gt; continue,
            _ =&gt; return true,
        }
    }
}

//唤醒一个等待futex的执行者
pub fn futex_wake(futex: &amp;AtomicI32) -&gt; bool {
    unsafe {
        //futex系统调用
        libc::syscall(
            libc::SYS_futex,
            futex as *const AtomicI32,
            libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,
            1,
        ) &gt; 0
    }
}

/// 唤醒所有等待futex的所有者.
pub fn futex_wake_all(futex: &amp;AtomicI32) {
    unsafe {
        //futex系统调用
        libc::syscall(
            libc::SYS_futex,
            futex as *const AtomicI32,
            libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,
            i32::MAX,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<p>FUTEX的令人惊讶在于为什么如此之晚这一特性才被实现。</p>
<h3 id="mutex源代码分析"><a class="header" href="#mutex源代码分析">Mutex源代码分析</a></h3>
<p>Mutex作为传统的临界区保护机制，在linux适配层上，RUST利用futex重新实现了Mutex库而没有使用pthread_mutex_t。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mutex {
    /// 0: unlocked
    /// 1: locked, no other threads waiting
    /// 2: locked, and other threads waiting (contended)
    /// 用作锁判断的原始变量,值的含义见上面英文注释
    futex: AtomicI32,
}

impl Mutex {
    pub const fn new() -&gt; Self {
        //初始化为不加锁
        Self { futex: AtomicI32::new(0) }
    }

    pub unsafe fn init(&amp;mut self) {}

    pub unsafe fn destroy(&amp;self) {}

    //如果临界区操作的代码短，可以用try_lock, 获取到锁后
    //即可快速完成操作，作为整体不进入内核的方案。
    //try_lock如果返回false，需要调用lock等待锁被打开
    pub unsafe fn try_lock(&amp;self) -&gt; bool {
        //利用原子操作试图加锁，如果futex不为0,会失败
        //如果成功，表明获得了锁
        self.futex.compare_exchange(0, 1, Acquire, Relaxed).is_ok()
    }

    //如果临界区操作代码较长，则应该直接调用lock方法
    pub unsafe fn lock(&amp;self) {
        if self.futex.compare_exchange(0, 1, Acquire, Relaxed).is_err() {
            //如果失败，说明已经由其他线程占有了锁，本线程需要等待
            self.lock_contended();
        }
    }

    //执行后会等待其他线程临界区操作结束
    fn lock_contended(&amp;self) {
        // 这里处理另一个线程很快结束操作临界区的情况,
        // 再次试图避免进入内核
        let mut state = self.spin();

        // 自旋等待后，判断临界区是否已经可以进入 
        if state == 0 {
            //试图再次获取锁
            match self.futex.compare_exchange(0, 1, Acquire, Relaxed) {
                //成功，不进入内核
                Ok(_) =&gt; return, // Locked!
                //不成功，state应为当前的futex
                Err(s) =&gt; state = s,
            }
        }

        //需要调用系统内核进入等待状态
        loop {
            // 如果没有其他线程等待，则修改futex为2来通知有线程在等待锁
            if state != 2 &amp;&amp; self.futex.swap(2, Acquire) == 0 {
                //如果此时发现已经获取了锁，则返回
                //出现这个结果表明在代码执行时，另一个线程释放了锁 
                return;
            }

            // 如果state是2且futex不是0，则需要阻塞.
            futex_wait(&amp;self.futex, 2, None);

            // 阻塞被解除后，再次做自旋以规避进入阻塞
            state = self.spin();
        }
    }

    // 在临界区操作非常快的情况下，不进入操作系统内核的解决方案 
    fn spin(&amp;self) -&gt; i32 {
        let mut spin = 100;
        loop {
            // 读取原子变量
            let state = self.futex.load(Relaxed);

            // 判断是否循环结束或者其他线程已经在等待/其他线程退出临界区 
            if state != 1 || spin == 0 {
                //判断真，直接返回
                return state;
            }

            //做个CPU自旋
            crate::hint::spin_loop();
            spin -= 1;
        }
    }

    //解锁，lock调用后及try_lock调用返回为真时，需要调用这个函数。
    pub unsafe fn unlock(&amp;self) {
        if self.futex.swap(0, Release) == 2 {
            // 如果是2，说明有线程通过操作系统内核等待，需要wake
            self.wake();
        }
    }

    #[cold]
    fn wake(&amp;self) {
        //通知操作系统内核，唤醒一个线程
        futex_wake(&amp;self.futex);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="convar分析"><a class="header" href="#convar分析">Convar分析</a></h3>
<p>RUST标准库的条件变量Condvar解决方案：<br />
条件变量本身是一种信号机制， 通常用于生产消费的两个线程或多个线程。生产线程完成临界区数据后，向消费线程发出通知。消费线程拿不到临界区数据时，会阻塞等待信号。<br />
条件变量需要与一个Mutex的变量配合，来完成临界区数据及信号自身的保护。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Condvar {
    // 本身是一个原子变量，值的变化表示条件变化
    futex: AtomicI32,
}

impl Condvar {
    //初始化
    pub const fn new() -&gt; Self {
        Self { futex: AtomicI32::new(0) }
    }

    pub unsafe fn init(&amp;mut self) {}

    pub unsafe fn destroy(&amp;self) {}


    //通知一个线程条件已经变化，调用此函数前，应该对关联
    //mutex加锁，调用后，应释放锁
    pub unsafe fn notify_one(&amp;self) {
        //简单的改变值，表示条件已经变化
        self.futex.fetch_add(1, Relaxed);
        //用futex操作系统调用完成通知,仅唤醒一个线程
        futex_wake(&amp;self.futex);
    }

    //调用前应对关联mutex加锁，调用后应释放锁
    pub unsafe fn notify_all(&amp;self) {
        self.futex.fetch_add(1, Relaxed);
        //唤醒所有等待线程
        futex_wake_all(&amp;self.futex);
    }

    pub unsafe fn wait(&amp;self, mutex: &amp;Mutex) {
        self.wait_optional_timeout(mutex, None);
    }

    pub unsafe fn wait_timeout(&amp;self, mutex: &amp;Mutex, timeout: Duration) -&gt; bool {
        self.wait_optional_timeout(mutex, Some(timeout))
    }

    //等待条件变化,调用此函数前，应该将关联mutex上锁保护self.futex及其他临界区的操作,
    //调用后，应释放锁
    unsafe fn wait_optional_timeout(&amp;self, mutex: &amp;Mutex, timeout: Option&lt;Duration&gt;) -&gt; bool {
        // 外部应该先将mutex上锁，防止其他线程改变self.futex，此处获取当前值 
        let futex_value = self.futex.load(Relaxed);

        // 释放锁。 
        mutex.unlock();

        // 如果条件不变，则进入等待 
        let r = futex_wait(&amp;self.futex, futex_value, timeout);

        // 条件已经变化，加锁保护self.futex的值及其他的临界区的操作 
        mutex.lock();

        r
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rwlock源代码分析"><a class="header" href="#rwlock源代码分析">RWLock源代码分析</a></h3>
<p>读写锁适用的场景如下：<br />
临界区允许多个读同时存在，但读写不能同时存在。临界区读的时候要设置锁处于读锁，此时允许读不允许写。如果有线程要写，需要等待。
临界区写的时候要设置写锁，此时和正常的锁是一致的，所有其他试图访问临界区的线程都需要等待。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RwLock {
    // 从0到30位用来作为锁的计数:
    //   0: Unlocked
    //   1..=0x3FFF_FFFE: 作为读线程的计数，并作为读锁
    //   0x3FFF_FFFF: 写锁
    // Bit 30: 有其他读线程在等待，此时应该是写锁.
    // Bit 31: 有其他写线程在等待，此时读锁及写锁都有可能.
    state: AtomicI32,
    // 利用这个值的变化做信号的通知，类似与CondVar的操作.
    writer_notify: AtomicI32,
}

const READ_LOCKED: i32 = 1;
const MASK: i32 = (1 &lt;&lt; 30) - 1;
const WRITE_LOCKED: i32 = MASK;
const MAX_READERS: i32 = MASK - 1;
const READERS_WAITING: i32 = 1 &lt;&lt; 30;
const WRITERS_WAITING: i32 = 1 &lt;&lt; 31;

fn is_unlocked(state: i32) -&gt; bool {
    state &amp; MASK == 0
}

fn is_write_locked(state: i32) -&gt; bool {
    state &amp; MASK == WRITE_LOCKED
}

fn has_readers_waiting(state: i32) -&gt; bool {
    state &amp; READERS_WAITING != 0
}

fn has_writers_waiting(state: i32) -&gt; bool {
    state &amp; WRITERS_WAITING != 0
}

//这个函数用来判断是否可以进入临界区读
fn is_read_lockable(state: i32) -&gt; bool {
    // 只有在读线程的数量小于最大值，且没有其他线程在等着读或等着写，此时可以更新读锁
    // 否则应该进入读等待队列，
    // 只要有线程等着写，要后继的读线程就需要阻塞在读锁中
    state &amp; MASK &lt; MAX_READERS &amp;&amp; !has_readers_waiting(state) &amp;&amp; !has_writers_waiting(state)
}

fn has_reached_max_readers(state: i32) -&gt; bool {
    state &amp; MASK == MAX_READERS
}

impl RwLock {
    pub const fn new() -&gt; Self {
        Self { state: AtomicI32::new(0), writer_notify: AtomicI32::new(0) }
    }

    pub unsafe fn destroy(&amp;self) {}

    //试图读，一般如果需要做读锁，应直接调用read，此函数用作不希望阻塞的情况
    pub unsafe fn try_read(&amp;self) -&gt; bool {
        // 如果判断可读，则对读锁加1,然后进入临界区做读操作，如果失败，可以调用read等待读
        self.state
            .fetch_update(Acquire, Relaxed, |s| is_read_lockable(s).then(|| s + READ_LOCKED))
            .is_ok()
    }

    //获取读锁或阻塞等待到能获取
    pub unsafe fn read(&amp;self) {
        let state = self.state.load(Relaxed);
        if !is_read_lockable(state)
            //此时更新读锁失败，证明锁已经被改变
            || self
                .state
                .compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)
                .is_err()
        {
            //复杂的读锁获取或者进入等待
            self.read_contended();
        }
    }

    //解锁读
    pub unsafe fn read_unlock(&amp;self) {
        //更新读锁
        let state = self.state.fetch_sub(READ_LOCKED, Release) - READ_LOCKED;

        // 除非有写线程在等待，否则此时不应该有线程在等待读. 写线程优先于读
        debug_assert!(!has_readers_waiting(state) || has_writers_waiting(state));

        // 如果有线程等着写，那就做唤醒操作，解锁读时，一定是有等着写的线程才能导致读线程被阻塞.
        if is_unlocked(state) &amp;&amp; has_writers_waiting(state) {
            self.wake_writer_or_readers(state);
        }
    }

    //读线程阻塞处理
    fn read_contended(&amp;self) {
        //自旋读，主要处理同时读的读锁更细冲突导致的不一致情况
        let mut state = self.spin_read();

        loop {
            // 再次尝试获取读锁
            if is_read_lockable(state) {
                match self.state.compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)
                {
                    //成功
                    Ok(_) =&gt; return, // Locked!
                    //如果是读锁不一致，那就再次尝试
                    Err(s) =&gt; {
                        state = s;
                        continue;
                    }
                }
            }

            // 如果达到最大的读线程数目, 可能是有线程忘记解锁 
            if has_reached_max_readers(state) {
                panic!(&quot;too many active read locks on RwLock&quot;);
            }

            // 确保等待读的标志已经被设置.
            if !has_readers_waiting(state) {
                if let Err(s) =
                    self.state.compare_exchange(state, state | READERS_WAITING, Relaxed, Relaxed)
                {
                    //这里，上段的is_read_lockable(state)执行是失败的，所以不会有读锁被增加的问题
                    //失败说明读锁又在被并发修改，所以此时可能可以读了，要再次尝试
                    state = s;
                    continue;
                }
            }

            // 终于可以阻塞了，如果此时state没变，就会阻塞 
            futex_wait(&amp;self.state, state | READERS_WAITING, None);

            // 此处或者是阻塞失败，或者被唤醒，两者都要重新看是否能够获得锁或者继续阻塞 
            state = self.spin_read();
        }
    }

    // 试图读，应该在不希望阻塞的情况下调用, 此方法返回成功代表已经获取了写锁
    pub unsafe fn try_write(&amp;self) -&gt; bool {
        self.state
            //读的时候必须处于Unlocked状态
            .fetch_update(Acquire, Relaxed, |s| is_unlocked(s).then(|| s + WRITE_LOCKED))
            .is_ok()
    }

    //此函数用于获取写锁或阻塞等待到能获取
    pub unsafe fn write(&amp;self) {
        if self.state.compare_exchange_weak(0, WRITE_LOCKED, Acquire, Relaxed).is_err() {
            //进入更复杂的锁获取或等待
            self.write_contended();
        }
    }

    //解锁写
    pub unsafe fn write_unlock(&amp;self) {
        //更新值
        let state = self.state.fetch_sub(WRITE_LOCKED, Release) - WRITE_LOCKED;

        //还没有唤醒，应该没有其他线程冲突
        debug_assert!(is_unlocked(state));

        //有等待线程的话，就唤醒
        if has_writers_waiting(state) || has_readers_waiting(state) {
            self.wake_writer_or_readers(state);
        }
    }

    //进入写等待队列的处理
    fn write_contended(&amp;self) {
        let mut state = self.spin_write();

        //假定当前没有线程等待写, 后继处理如果更新，
        //则说明有两个以上的线程在竞争获取写锁，所以
        //设置state时需要同时更新写等待标志位
        let mut other_writers_waiting = 0;

        loop {
            //  如果unlocked，那试图获取写锁
            if is_unlocked(state) {
                match self.state.compare_exchange_weak(
                    state,
                    state | WRITE_LOCKED | other_writers_waiting,
                    Acquire,
                    Relaxed,
                ) {
                    //获取成功
                    Ok(_) =&gt; return, // Locked!
                    Err(s) =&gt; {
                        //获取失败，再次循环
                        state = s;
                        continue;
                    }
                }
            }

            // 不为unlock，进入写等待队列并更新写等待标志
            if !has_writers_waiting(state) {
                if let Err(s) =
                    self.state.compare_exchange(state, state | WRITERS_WAITING, Relaxed, Relaxed)
                {
                    //更新失败，说明有同时访问者，需要重新试图获取写锁
                    state = s;
                    continue;
                }
            }

            // 不为unlock，且写等待标志位已经设置
            // 已经有其他写线程在等待.
            other_writers_waiting = WRITERS_WAITING;

            // 获取写锁解除的通知变量
            let seq = self.writer_notify.load(Acquire);

            let s = self.state.load(Relaxed);
            //这个地方错了，本意估计是is_unlocked(s), state此时已经确定
            //为lock了(注:作者在github提交了issue，目前此错误已经被修改)
            if is_unlocked(state) || !has_writers_waiting(s) {
                //这里如果又有变化，那么再次试图获得写锁
                state = s;
                continue;
            }

            // 阻塞，等待解锁通知 
            futex_wait(&amp;self.writer_notify, seq, None);

            // 失败或者唤醒，重新再次试图获取写锁 
            state = self.spin_write();
        }
    }

    /// 唤醒等待线程
    fn wake_writer_or_readers(&amp;self, mut state: i32) {
        assert!(is_unlocked(state));

        // 仅有写现程在等.
        if state == WRITERS_WAITING {
            //改变写等待标记，此时可能会形成一个冲突，所以write_contended会等待之前再做
            //一次判断
            match self.state.compare_exchange(state, 0, Relaxed, Relaxed) {
                Ok(_) =&gt; {
                    self.wake_writer();
                    return;
                }
                Err(s) =&gt; {
                    // 有冲突，更新state，此时只有可能是读线程在更新.
                    state = s;
                }
            }
        }

        // 即有读线程在等，也有写线程在等
        if state == READERS_WAITING + WRITERS_WAITING {
            //清写等待标志，此时0到30位肯定是0
            if self.state.compare_exchange(state, READERS_WAITING, Relaxed, Relaxed).is_err() {
                // 不应该出错，如果出错，那锁状态已经不对，无能为力了，而且不知道错误在哪里.
                // 感觉还是应该panic一下
                return;
            }
            //唤醒等待的写线程
            if self.wake_writer() {
                return;
            }
            // 执行到这里，证明没有写线程在等，那接下来
            // 处理读线程。此时直接修改state就可以，因为不可能有其他
            // 线程修改state了
            state = READERS_WAITING;
        }

        // 唤醒等待的读线程 
        if state == READERS_WAITING {
            if self.state.compare_exchange(state, 0, Relaxed, Relaxed).is_ok() {
                //唤醒所有读，这里读线程被唤醒后，仍然可能会有写线程插入，但不会出现问题
                futex_wake_all(&amp;self.state);
            }
        }
    }

    /// 唤醒写线程
    fn wake_writer(&amp;self) -&gt; bool {
        //类似CondVar的处理方式，修改唤醒标志，然后唤醒即可
        self.writer_notify.fetch_add(1, Release);
        futex_wake(&amp;self.writer_notify)
    }

    /// 自旋，处理一些在很短的时间内的状态修改使得锁可以获取，规避进入内核.
    fn spin_until(&amp;self, f: impl Fn(i32) -&gt; bool) -&gt; i32 {
        let mut spin = 100; // Chosen by fair dice roll.
        loop {
            let state = self.state.load(Relaxed);
            //满足函数要求或自旋时间到，退出
            if f(state) || spin == 0 {
                return state;
            }
            crate::hint::spin_loop();
            spin -= 1;
        }
    }

    fn spin_write(&amp;self) -&gt; i32 {
        // 如果为unlock状态或者已经明确有写线程在等待并做了写等待置位.
        self.spin_until(|state| is_unlocked(state) || has_writers_waiting(state))
    }

    fn spin_read(&amp;self) -&gt; i32 {
        // 如果没有写锁，或者写等待或者读等待已经被置位 
        self.spin_until(|state| {
            !is_write_locked(state) || has_readers_waiting(state) || has_writers_waiting(state)
        })
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="可重入的mutex"><a class="header" href="#可重入的mutex">可重入的Mutex</a></h3>
<p>如果一个线程调用lock获取锁之后，允许其在临界区的代码又对该锁调用lock，这个锁是Reentrant mutex。用futex处理这种情况效率不高，因为需要多次进入内核获取线程信息。因此，使用已有的libc的pthread_mutex_t的机制.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReentrantMutex {
    //仅用来给libc使用
    inner: UnsafeCell&lt;libc::pthread_mutex_t&gt;,
}

unsafe impl Send for ReentrantMutex {}
unsafe impl Sync for ReentrantMutex {}

impl ReentrantMutex {
    //因为这个初始化没有完成可重入锁的设置，所以实际上没有初始化
    //但因为libc的限制，必须要先创建变量才能后完成初始化，所以需要此关联函数
    //调用此函数后，再调用init方法完成初始化
    pub const unsafe fn uninitialized() -&gt; ReentrantMutex {
        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }
    }

    //完成可重入锁的设置
    pub unsafe fn init(&amp;self) {
        //栈中定义一块内存
        let mut attr = MaybeUninit::&lt;libc::pthread_mutexattr_t&gt;::uninit();
        //利用C函数做初始化，
        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();
        //创建类型变量
        let attr = PthreadMutexAttr(&amp;mut attr);
        //设置attr属性
        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE))
            .unwrap();
        //完成初始化
        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();
    }

    //lock调用
    pub unsafe fn lock(&amp;self) {
        //简单的调用libc函数
        let result = libc::pthread_mutex_lock(self.inner.get());
        debug_assert_eq!(result, 0);
    }

    //不想阻塞时的调用
    pub unsafe fn try_lock(&amp;self) -&gt; bool {
        //简单的调用libc
        libc::pthread_mutex_trylock(self.inner.get()) == 0
    }

    //解锁
    pub unsafe fn unlock(&amp;self) {
        let result = libc::pthread_mutex_unlock(self.inner.get());
        debug_assert_eq!(result, 0);
    }

    //释放锁
    pub unsafe fn destroy(&amp;self) {
        let result = libc::pthread_mutex_destroy(self.inner.get());
        debug_assert_eq!(result, 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rust适配层扩展的锁机制"><a class="header" href="#rust适配层扩展的锁机制">RUST适配层扩展的锁机制</a></h2>
<p>代码路径： library/std/src/sys_common/mutex.rs|condvar.rs|rwlock.rs</p>
<h3 id="适用于静态变量的锁"><a class="header" href="#适用于静态变量的锁">适用于静态变量的锁</a></h3>
<p>因为所有权的定义，如果锁作为静态变量存在，则其初始化函数必须在编译期执行，即为const fn。静态锁主要用于保护静态变量形成的临界区。 </p>
<p>静态Mutex结构代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//用于static变量
pub struct StaticMutex(imp::Mutex);

unsafe impl Sync for StaticMutex {}

impl StaticMutex {
    /// const 函数可以用于static变量赋值 
    pub const fn new() -&gt; Self {
        Self(imp::Mutex::new())
    }

    //上锁后用锁的引用形成封装结构返回，StaticMutexGuard见下文分析
    pub unsafe fn lock(&amp;'static self) -&gt; StaticMutexGuard {
        self.0.lock();
        StaticMutexGuard(&amp;self.0)
    }
    //没有设计unlock方法
}

//此结构设计主要是充分利用RUST的编译器来简化解锁代码，
//使用StaticMutexGuard后可以不必再考虑解锁这件事
pub struct StaticMutexGuard(&amp;'static imp::Mutex);

impl Drop for StaticMutexGuard {
    //生命周期终止时做unlock
    fn drop(&amp;mut self) {
        unsafe {
            self.0.unlock();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="适用于静态变量的读写锁"><a class="header" href="#适用于静态变量的读写锁">适用于静态变量的读写锁</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StaticRwLock(imp::RwLock);

impl StaticRwLock {
    /// const fn以初始化静态读写锁.
    pub const fn new() -&gt; Self {
        Self(imp::RwLock::new())
    }

    pub fn read(&amp;'static self) -&gt; StaticRwLockReadGuard {
        unsafe { self.0.read() };
        StaticRwLockReadGuard(&amp;self.0)
    }

    pub fn write(&amp;'static self) -&gt; StaticRwLockWriteGuard {
        unsafe { self.0.write() };
        StaticRwLockWriteGuard(&amp;self.0)
    }
}

pub struct StaticRwLockReadGuard(&amp;'static imp::RwLock);

impl Drop for StaticRwLockReadGuard {
    fn drop(&amp;mut self) {
        unsafe {
            self.0.read_unlock();
        }
    }
}

pub struct StaticRwLockWriteGuard(&amp;'static imp::RwLock);

impl Drop for StaticRwLockWriteGuard {
    fn drop(&amp;mut self) {
        unsafe {
            self.0.write_unlock();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="适用于非静态变量的锁"><a class="header" href="#适用于非静态变量的锁">适用于非静态变量的锁</a></h3>
<h4 id="movablemutex"><a class="header" href="#movablemutex">MovableMutex</a></h4>
<p>代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//imp::MoveableMutex在linux即imp::Mutex，其他系统基本也一样
pub struct MovableMutex(imp::MovableMutex);

unsafe impl Sync for MovableMutex {}

impl MovableMutex {
    /// 创建锁 
    pub fn new() -&gt; Self {
        let mut mutex = imp::MovableMutex::from(imp::Mutex::new());
        //需要调用init(), 这里区别于StaticMutex
        unsafe { mutex.init() };
        Self(mutex)
    }

    pub(super) fn raw(&amp;self) -&gt; &amp;imp::Mutex {
        &amp;self.0
    }

    //获取锁
    pub fn raw_lock(&amp;self) {
        unsafe { self.0.lock() }
    }

    //不希望阻塞获取锁
    pub fn try_lock(&amp;self) -&gt; bool {
        unsafe { self.0.try_lock() }
    }

    //释放锁
    pub unsafe fn raw_unlock(&amp;self) {
        self.0.unlock()
    }
}

impl Drop for MovableMutex {
    fn drop(&amp;mut self) {
        //用pthread_mutex_t需要
        unsafe { self.0.destroy() };
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="条件变量"><a class="header" href="#条件变量">条件变量</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//对Condvar的关联Mutex做check
type CondvarCheck = &lt;imp::MovableMutex as check::CondvarCheck&gt;::Check;

/// 对操作系统的Condvar做的封装.
pub struct Condvar {
    //就是imp::Condvar
    inner: imp::MovableCondvar,
    check: CondvarCheck,
}

impl Condvar {
    /// 创建新的Condvar.
    pub fn new() -&gt; Self {
        let mut c = imp::MovableCondvar::from(imp::Condvar::new());
        unsafe { c.init() };
        Self { inner: c, check: CondvarCheck::new() }
    }

    /// 发信号唤醒一个等待此Condvar的线程.
    pub fn notify_one(&amp;self) {
        unsafe { self.inner.notify_one() };
    }

    /// 发信号唤醒所有等待此信号的线程.
    pub fn notify_all(&amp;self) {
        unsafe { self.inner.notify_all() };
    }

    /// 等待信号.
    pub unsafe fn wait(&amp;self, mutex: &amp;MovableMutex) {
        //确保始终使用同一个关联Mutex
        self.check.verify(mutex);
        // 阻塞并等待信号
        self.inner.wait(mutex.raw())
    }

    //超时等待
    pub unsafe fn wait_timeout(&amp;self, mutex: &amp;MovableMutex, dur: Duration) -&gt; bool {
        self.check.verify(mutex);
        self.inner.wait_timeout(mutex.raw(), dur)
    }
}

impl Drop for Condvar {
    fn drop(&amp;mut self) {
        unsafe { self.inner.destroy() };
    }
}

<span class="boring">}</span></code></pre></pre>
<h4 id="rwlock"><a class="header" href="#rwlock">RWLock</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MovableRwLock(imp::MovableRwLock);

impl MovableRwLock {
    pub fn new() -&gt; Self {
        Self(imp::MovableRwLock::from(imp::RwLock::new()))
    }

    pub fn read(&amp;self) {
        unsafe { self.0.read() }
    }

    pub fn try_read(&amp;self) -&gt; bool {
        unsafe { self.0.try_read() }
    }

    pub fn write(&amp;self) {
        unsafe { self.0.write() }
    }

    pub fn try_write(&amp;self) -&gt; bool {
        unsafe { self.0.try_write() }
    }

    pub unsafe fn read_unlock(&amp;self) {
        self.0.read_unlock()
    }

    pub unsafe fn write_unlock(&amp;self) {
        self.0.write_unlock()
    }
}

impl Drop for MovableRwLock {
    fn drop(&amp;mut self) {
        unsafe { self.0.destroy() };
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="rust中锁的杂项"><a class="header" href="#rust中锁的杂项">RUST中锁的杂项</a></h2>
<h3 id="加锁返回的统一类型"><a class="header" href="#加锁返回的统一类型">加锁返回的统一类型</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//lock方法的返回结果
pub type LockResult&lt;Guard&gt; = Result&lt;Guard, PoisonError&lt;Guard&gt;&gt;;
//try_lock方法的返回结果
pub type TryLockResult&lt;Guard&gt; = Result&lt;Guard, TryLockError&lt;Guard&gt;&gt;;

//错误类型
pub struct PoisonError&lt;T&gt; {
    guard: T,
}

impl&lt;T&gt; PoisonError&lt;T&gt; {
    //创建一个错误变量
    pub fn new(guard: T) -&gt; PoisonError&lt;T&gt; {
        PoisonError { guard }
    }

    //从Error中获取导致错误的变量
    pub fn into_inner(self) -&gt; T {
        self.guard
    }

    //获取导致错误变量的引用
    pub fn get_ref(&amp;self) -&gt; &amp;T {
        &amp;self.guard
    }

    //获取可变引用
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut T {
        &amp;mut self.guard
    }
}

//Mutex&lt;T&gt; try_lock错误返回
pub enum TryLockError&lt;T&gt; {
    //线程异常返回
    Poisoned(PoisonError&lt;T&gt;),
    //临界区已经被锁，需要阻塞
    WouldBlock,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="poison状态"><a class="header" href="#poison状态">Poison状态</a></h3>
<p>如果一个线程在获取一个锁的期间发生了panic，则锁保护的临界区的数据已经不能认为是正确的。因为panic导致锁在一个未期望的代码位置解锁。此时，需要对锁标志一个状态，RUST名词称为锁处于Poison状态，并设计了Flag来表示这个状态。<br />
代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 用于标识线程在加锁的状态下panic退出
pub struct Flag {
    failed: AtomicBool,
}

impl Flag {
    //初始的状态时候为假
    pub const fn new() -&gt; Flag {
        Flag { failed: AtomicBool::new(false) }
    }

    //加锁的时候被调用，此时如果本线程已经panic，则需要返回错误
    pub fn borrow(&amp;self) -&gt; LockResult&lt;Guard&gt; {
        //获取本线程的panic状态, 相关部分在Thread一节会再解释
        let ret = Guard { panicking: thread::panicking() };
        //如果Flag已经是真，则返回Err并给出本线程状态，否则返回Ok
        if self.get() { Err(PoisonError::new(ret)) } else { Ok(ret) }
    }

    //释放锁的时候被调用，如果本线程panic，则会更新Flag为true
    pub fn done(&amp;self, guard: &amp;Guard) {
        if !guard.panicking &amp;&amp; thread::panicking() {
            self.failed.store(true, Ordering::Relaxed);
        }
    }

    //获得Flag的值
    pub fn get(&amp;self) -&gt; bool {
        self.failed.load(Ordering::Relaxed)
    }
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust的临界区变量实现"><a class="header" href="#rust的临界区变量实现">RUST的临界区变量实现</a></h2>
<p>代码路径: library/std/src/sync/*.rs</p>
<h3 id="mutext的实现"><a class="header" href="#mutext的实现"><code>Mutex&lt;T&gt;</code>的实现</a></h3>
<p><code>Mutex&lt;T&gt;</code>是最典型的临界区变量。RUST的设计目标是在使用<code>Mutex&lt;T&gt;</code>时代码中不必关注其的跨线程操作的安全性，使用方式与内部可变性类型的使用相类似。这一设计思路实际在<code>RefCell&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>等类型设计上是一脉相承的：</p>
<ol>
<li>设计一个基础类型结构，将要操作的真实类型变量封装在其内，并拥有其所有权，</li>
<li>设计一个借用类型结构，由基础类型结构的某一方法生成，在此方法中完成附加安全操作，如计数增加，加锁等。</li>
<li>借用类型结构实现解引用方法，返回真实类型变量的引用或可变引用，由此可以对真实变类型变量进行访问，修改操作</li>
<li>借用类型结构的drop方法会执行安全逆操作，如减少计数或解锁。</li>
</ol>
<p><code>Mutex&lt;T&gt;</code>的设计如下：</p>
<ol>
<li>基本类型<code>Mutex&lt;T&gt;</code>，负责临界区的数据存储及Mutex锁</li>
<li><code>MutexGuard&lt;'a, T&gt;</code>作为<code>Mutex&lt;T&gt;</code>的借用类型结构, lock()作为借用方法，返回<code>MutexGuard&lt;T&gt;</code>，可以直接对其解引用后获得内部变量的引用/可变引用，随后执行临界区数据操作及读写。生命周期结束后，<code>MutexGuard&lt;T&gt;</code>的drop会解锁操作，从而使得加锁解锁操作实际上代码不必关心。lock()本身完全可以等同于一个borrow()的调用。</li>
<li><code>Mutex&lt;T&gt;</code>本身是一个内部可变型的类型, 实现多处共享且可修改</li>
<li>线程panic时的Poison处理,使得其他语言极少关注的情况在RUST中自然得解。 </li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Mutex&lt;T: ?Sized&gt; {
    //临界区的锁
    inner: sys::MovableMutex,
    //标识Mutex在线程panic时处于锁状态
    poison: poison::Flag,
    //临界区数据, Mutex本身是一个内部可变性的类型
    data: UnsafeCell&lt;T&gt;,
}

unsafe impl&lt;T: ?Sized + Send&gt; Send for Mutex&lt;T&gt; {}
unsafe impl&lt;T: ?Sized + Send&gt; Sync for Mutex&lt;T&gt; {}

<span class="boring">}</span></code></pre></pre>
<p>用于<code>Mutex&lt;T&gt;</code>配合的借用封装类型结构<code>MutexGuard</code>如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//用于lock调用后的对原始变量的访问引用。并包含了poison用于在自身生命周期终结的时候
//更新Mutex&lt;T&gt;的Flag
pub struct MutexGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a Mutex&lt;T&gt;,
    poison: poison::Guard,
}

//标识MutexGuard的当前线程panic状态
pub struct Guard {
    panicking: bool,
}

//支持函数, LockResult请参考14-线程间锁通信
pub fn map_result&lt;T, U, F&gt;(result: LockResult&lt;T&gt;, f: F) -&gt; LockResult&lt;U&gt;
where
    F: FnOnce(T) -&gt; U,
{
    match result {
        Ok(t) =&gt; Ok(f(t)),
        Err(PoisonError { guard }) =&gt; Err(PoisonError::new(f(guard))),
    }
}

//MutexGuard创建关联函数
impl&lt;'mutex, T: ?Sized&gt; MutexGuard&lt;'mutex, T&gt; {
    unsafe fn new(lock: &amp;'mutex Mutex&lt;T&gt;) -&gt; LockResult&lt;MutexGuard&lt;'mutex, T&gt;&gt; {
        //如果Mutex&lt;T&gt;的poison为假，即使本线程已经panic，也返回Ok类型
        //因为不是在加锁时遇到panic，所以临界区数据一致性没有受到破坏。
        poison::map_result(lock.poison.borrow(), |guard| MutexGuard { lock, poison: guard })
    }
}

//deref，返回临界区数据的引用
impl&lt;T: ?Sized&gt; Deref for MutexGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        //利用UnsafeCell获得内部可变性
        unsafe { &amp;*self.lock.data.get() }
    }
}

//返回临界区数据的可变引用
impl&lt;T: ?Sized&gt; DerefMut for MutexGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

//drop方法
impl&lt;T: ?Sized&gt; Drop for MutexGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            //更新Mutex&lt;T&gt;的Flag,一般的，如果在上锁的状态下线程panic
            //会导致对所有栈变量做drop调用，从而此drop被调用
            //self.lock.poison被更新为true
            self.lock.poison.done(&amp;self.poison);
            //解锁
            self.lock.inner.raw_unlock();
        }
    }
}

//获取Mutex
pub fn guard_lock&lt;'a, T: ?Sized&gt;(guard: &amp;MutexGuard&lt;'a, T&gt;) -&gt; &amp;'a sys::MovableMutex {
    &amp;guard.lock.inner
}

//获取线程panic状态
pub fn guard_poison&lt;'a, T: ?Sized&gt;(guard: &amp;MutexGuard&lt;'a, T&gt;) -&gt; &amp;'a poison::Flag {
    &amp;guard.lock.poison
}

<span class="boring">}</span></code></pre></pre>
<p>在<code>Mutex&lt;T&gt;</code>结构中，poison导致更新一般在发生panic时，线程drop<code>MutexGuard&lt;T&gt;</code>时进行标志更新。值得说明的时，上锁后线程异常退出是很少被考虑到的安全问题，RUST的标准库则给出了解决方案。</p>
<p><code>Mutex&lt;T&gt;</code>的代码分析如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//只能创建固定尺寸类型的临界区
impl&lt;T&gt; Mutex&lt;T&gt; {
    //对数据创建一个临界区
    pub fn new(t: T) -&gt; Mutex&lt;T&gt; {
        Mutex {
            //创建系统MovableMutex类型
            inner: sys::MovableMutex::new(),
            //poison为false
            poison: poison::Flag::new(),
            //必须用内部可变性类型
            data: UnsafeCell::new(t),
        }
    }
}

impl&lt;T: ?Sized&gt; Mutex&lt;T&gt; {
    // 获取锁，允许阻塞，返回guard结构用于访问临界区数据及处理锁的释放
    pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
        unsafe {
            //先做锁操作
            self.inner.raw_lock();
            //在MutexGuard的new中处理线程panic问题
            MutexGuard::new(self)
        }
    }

    //试图获取锁，不会阻塞
    pub fn try_lock(&amp;self) -&gt; TryLockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
        unsafe {
            if self.inner.try_lock() {
                //上锁成功，生成MutexGuard
                Ok(MutexGuard::new(self)?)
            } else {
                //失败，提示应该阻塞
                Err(TryLockError::WouldBlock)
            }
        }
    }

    //立即解锁，不希望等待guard生命周期终结，
    pub fn unlock(guard: MutexGuard&lt;'_, T&gt;) {
        drop(guard);
    }

    //是否有线程在panic时锁住了临界区
    pub fn is_poisoned(&amp;self) -&gt; bool {
        self.poison.get()
    }

    //消费Mutex&lt;T&gt;,并获取临界区数据
    pub fn into_inner(self) -&gt; LockResult&lt;T&gt;
    where
        T: Sized,
    {
        //获取临界区数据
        let data = self.data.into_inner();
        //根据是否有线程在panic时加锁,
        poison::map_result(self.poison.borrow(), |_| data)
    }

    //获取临界区数据的可变引用，如果已经执行过lock,
    //此处会编译失败
    pub fn get_mut(&amp;mut self) -&gt; LockResult&lt;&amp;mut T&gt; {
        let data = self.data.get_mut();
        poison::map_result(self.poison.borrow(), |_| data)
    }
}

<span class="boring">}</span></code></pre></pre>
<p>RUST的<code>Mutex&lt;T&gt;</code>再一次揭示了RUST标准库对编程员简化编程的努力及一些标准思维及技巧。</p>
<h3 id="condvar实现分析"><a class="header" href="#condvar实现分析"><code>Condvar</code>实现分析</a></h3>
<p>RUST的Condvar是与<code>MutexGuard&lt;'a, T&gt;</code>临界区变量相关联在一起。RUST的Condvar摆脱了其他语言的那些复杂概念与代码形式，使用方式逻辑上非常顺理成章。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//仅仅是对操作系统的Condvar的一个封装
pub struct Condvar {
    inner: sys::Condvar,
}

impl Condvar {
    
    pub fn new() -&gt; Condvar {
        Condvar { inner: sys::Condvar::new() }
    }

    // 等待信号通知，并可能进入阻塞,因为用MutexGuard, 解脱了与Mutex相互关联的复杂概念，
    // 且Mutex一定已经lock，且临界区数据包括在内，使得Condvar更易被理解及使用
    pub fn wait&lt;'a, T&gt;(&amp;self, guard: MutexGuard&lt;'a, T&gt;) -&gt; LockResult&lt;MutexGuard&lt;'a, T&gt;&gt; {
        let poisoned = unsafe {
            //获取关联的imp::Mutex
            let lock = mutex::guard_lock(&amp;guard);
            self.inner.wait(lock);
            //获取Mutex的poison
            mutex::guard_poison(&amp;guard).get()
        };
        if poisoned { Err(PoisonError::new(guard)) } else { Ok(guard) }
    }

    //函数式编程，将对临界区的操作封装在闭包中
    pub fn wait_while&lt;'a, T, F&gt;(
        &amp;self,
        mut guard: MutexGuard&lt;'a, T&gt;,
        mut condition: F,
    ) -&gt; LockResult&lt;MutexGuard&lt;'a, T&gt;&gt;
    where
        F: FnMut(&amp;mut T) -&gt; bool,
    {
        while condition(&amp;mut *guard) {
            guard = self.wait(guard)?;
        }
        Ok(guard)
    }

    // 简化以毫秒计数的超时等待
    pub fn wait_timeout_ms&lt;'a, T&gt;(
        &amp;self,
        guard: MutexGuard&lt;'a, T&gt;,
        ms: u32,
    ) -&gt; LockResult&lt;(MutexGuard&lt;'a, T&gt;, bool)&gt; {
        let res = self.wait_timeout(guard, Duration::from_millis(ms as u64));
        poison::map_result(res, |(a, b)| (a, !b.timed_out()))
    }

    // 超时等待
    pub fn wait_timeout&lt;'a, T&gt;(
        &amp;self,
        guard: MutexGuard&lt;'a, T&gt;,
        dur: Duration,
    ) -&gt; LockResult&lt;(MutexGuard&lt;'a, T&gt;, WaitTimeoutResult)&gt; {
        let (poisoned, result) = unsafe {
            let lock = mutex::guard_lock(&amp;guard);
            let success = self.inner.wait_timeout(lock, dur);
            (mutex::guard_poison(&amp;guard).get(), WaitTimeoutResult(!success))
        };
        if poisoned { Err(PoisonError::new((guard, result))) } else { Ok((guard, result)) }
    }

    //wait_while的超时版本
    pub fn wait_timeout_while&lt;'a, T, F&gt;(
        &amp;self,
        mut guard: MutexGuard&lt;'a, T&gt;,
        dur: Duration,
        mut condition: F,
    ) -&gt; LockResult&lt;(MutexGuard&lt;'a, T&gt;, WaitTimeoutResult)&gt;
    where
        F: FnMut(&amp;mut T) -&gt; bool,
    {
        let start = Instant::now();
        loop {
            if !condition(&amp;mut *guard) {
                return Ok((guard, WaitTimeoutResult(false)));
            }
            let timeout = match dur.checked_sub(start.elapsed()) {
                Some(timeout) =&gt; timeout,
                None =&gt; return Ok((guard, WaitTimeoutResult(true))),
            };
            guard = self.wait_timeout(guard, timeout)?.0;
        }
    }

    //信号通知，唤醒一个线程
    pub fn notify_one(&amp;self) {
        self.inner.notify_one()
    }

    //信号通知，唤醒所有线程
    pub fn notify_all(&amp;self) {
        self.inner.notify_all()
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="rwlockt分析"><a class="header" href="#rwlockt分析"><code>RWLock&lt;T&gt;</code>分析</a></h3>
<p>与<code>Mutex&lt;T&gt;</code>的设计采用了一致的设计思路：</p>
<p>代码分析如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//与Mutex&lt;T&gt;几乎同样的成员
pub struct RwLock&lt;T: ?Sized&gt; {
    inner: sys::MovableRwLock,
    poison: poison::Flag,
    data: UnsafeCell&lt;T&gt;,
}

unsafe impl&lt;T: ?Sized + Send&gt; Send for RwLock&lt;T&gt; {}
unsafe impl&lt;T: ?Sized + Send + Sync&gt; Sync for RwLock&lt;T&gt; {}

//用read锁后的借用封装类型结构
pub struct RwLockReadGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a RwLock&lt;T&gt;,
}

impl&lt;T: ?Sized&gt; !Send for RwLockReadGuard&lt;'_, T&gt; {}

unsafe impl&lt;T: ?Sized + Sync&gt; Sync for RwLockReadGuard&lt;'_, T&gt; {}

//用write锁后的借用封装类型结构
pub struct RwLockWriteGuard&lt;'a, T: ?Sized + 'a&gt; {
    lock: &amp;'a RwLock&lt;T&gt;,
    poison: poison::Guard,
}

impl&lt;T: ?Sized&gt; !Send for RwLockWriteGuard&lt;'_, T&gt; {}

unsafe impl&lt;T: ?Sized + Sync&gt; Sync for RwLockWriteGuard&lt;'_, T&gt; {}

impl&lt;T&gt; RwLock&lt;T&gt; {
    pub fn new(t: T) -&gt; RwLock&lt;T&gt; {
        RwLock {
            inner: sys::MovableRwLock::new(),
            poison: poison::Flag::new(),
            data: UnsafeCell::new(t),
        }
    }
}

impl&lt;T: ?Sized&gt; RwLock&lt;T&gt; {
    //读上锁，返回读锁的临界区借用封装
    pub fn read(&amp;self) -&gt; LockResult&lt;RwLockReadGuard&lt;'_, T&gt;&gt; {
        unsafe {
            self.inner.read();
            RwLockReadGuard::new(self)
        }
    }

    //不希望阻塞时做调用
    pub fn try_read(&amp;self) -&gt; TryLockResult&lt;RwLockReadGuard&lt;'_, T&gt;&gt; {
        unsafe {
            if self.inner.try_read() {
                Ok(RwLockReadGuard::new(self)?)
            } else {
                Err(TryLockError::WouldBlock)
            }
        }
    }

    //写锁，返回一个写锁的借用封装
    pub fn write(&amp;self) -&gt; LockResult&lt;RwLockWriteGuard&lt;'_, T&gt;&gt; {
        unsafe {
            self.inner.write();
            RwLockWriteGuard::new(self)
        }
    }

    //不希望阻塞时的写锁调用
    pub fn try_write(&amp;self) -&gt; TryLockResult&lt;RwLockWriteGuard&lt;'_, T&gt;&gt; {
        unsafe {
            if self.inner.try_write() {
                Ok(RwLockWriteGuard::new(self)?)
            } else {
                Err(TryLockError::WouldBlock)
            }
        }
    }

    //是否中毒
    pub fn is_poisoned(&amp;self) -&gt; bool {
        self.poison.get()
    }

    //消费掉锁，此时如果有读锁或写锁，编译器会告警
    pub fn into_inner(self) -&gt; LockResult&lt;T&gt;
    where
        T: Sized,
    {
        let data = self.data.into_inner();
        poison::map_result(self.poison.borrow(), |_| data)
    }

    //此时如果有读锁或写锁，编译器会告警,针对self
    pub fn get_mut(&amp;mut self) -&gt; LockResult&lt;&amp;mut T&gt; {
        let data = self.data.get_mut();
        poison::map_result(self.poison.borrow(), |_| data)
    }
}

// 读锁的借用封装结构
impl&lt;'rwlock, T: ?Sized&gt; RwLockReadGuard&lt;'rwlock, T&gt; {
    unsafe fn new(lock: &amp;'rwlock RwLock&lt;T&gt;) -&gt; LockResult&lt;RwLockReadGuard&lt;'rwlock, T&gt;&gt; {
        poison::map_result(lock.poison.borrow(), |_| RwLockReadGuard { lock })
    }
}

// 写锁的借用封装结构
impl&lt;'rwlock, T: ?Sized&gt; RwLockWriteGuard&lt;'rwlock, T&gt; {
    unsafe fn new(lock: &amp;'rwlock RwLock&lt;T&gt;) -&gt; LockResult&lt;RwLockWriteGuard&lt;'rwlock, T&gt;&gt; {
        poison::map_result(lock.poison.borrow(), |guard| RwLockWriteGuard { lock, poison: guard })
    }
}

impl&lt;T: ?Sized&gt; Deref for RwLockReadGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Deref for RwLockWriteGuard&lt;'_, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        unsafe { &amp;*self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; DerefMut for RwLockWriteGuard&lt;'_, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.lock.data.get() }
    }
}

impl&lt;T: ?Sized&gt; Drop for RwLockReadGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            self.lock.inner.read_unlock();
        }
    }
}

impl&lt;T: ?Sized&gt; Drop for RwLockWriteGuard&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        self.lock.poison.done(&amp;self.poison);
        unsafe {
            self.lock.inner.write_unlock();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>RwLock&lt;T&gt;</code>与<code>Mutex&lt;T&gt;</code>的代码逻辑基本一致，所以分析基本没有做。</p>
<h3 id="barrier-类型临界变量"><a class="header" href="#barrier-类型临界变量">Barrier 类型临界变量</a></h3>
<p>Barrier建立了一个多个线程同步的等待点，当所有的线程都到达这个点后，每个线程才能恢复执行，否则，就在该点等待。<br />
Barrier的实例：初始化的时候每一个线程负责不同的初始化内容，只有所有线程都完成了初始化之后，才能继续执行，否则会出现错误。此时，可以用Barrier建立同步点，每个线程完成初始化后就阻塞等待在这个点上，当所有线程都完成后，所有线程解除阻塞，继续运行。<br />
也可用于多个线程协同工作，需要设置一个协同点，每个线程在完成一部分工作后需要等在协同点等待其他线程也都完成工作，然后才能继续工作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Barrier {
    //BarrierState临界区数据 
    lock: Mutex&lt;BarrierState&gt;,
    //等待及解除等待
    cvar: Condvar,
    //线程计数
    num_threads: usize,
}

struct BarrierState {
    //等待的线程数量
    count: usize,
    //唤醒标志
    generation_id: usize,
}

//表明线程是否是唤醒其他线程的线程
pub struct BarrierWaitResult(bool);


impl Barrier {
    //指定Barrier能够做多少个线程的同步
    pub fn new(n: usize) -&gt; Barrier {
        Barrier {
            lock: Mutex::new(BarrierState { count: 0, generation_id: 0 }),
            cvar: Condvar::new(),
            num_threads: n,
        }
    }

    //等待在Barrier
    pub fn wait(&amp;self) -&gt; BarrierWaitResult {
        //获取临界区变量
        let mut lock = self.lock.lock().unwrap();
        let local_gen = lock.generation_id;
        //等待线程计数加1
        lock.count += 1;
        //判断是否已经有足够的线程
        if lock.count &lt; self.num_threads {
            //有可能被其他情况唤醒，如收到信号
            //此处用循环来完成此种情况下的再次进入等待
            //判断是否满足等待的条件
            while local_gen == lock.generation_id {
                //进入等待
                lock = self.cvar.wait(lock).unwrap();
                //被唤醒,有可能被信号唤醒
            }
            //线程已经到达数目，返回
            BarrierWaitResult(false)
        } else {
            //线程已经到达规定数目
            lock.count = 0;
            //唤醒标志
            lock.generation_id = lock.generation_id.wrapping_add(1);
            //唤醒所有其他阻塞线程
            self.cvar.notify_all();
            BarrierWaitResult(true)
        }
    }
}

impl BarrierWaitResult {
    //唤醒其他线程的线程
    pub fn is_leader(&amp;self) -&gt; bool {
        self.0
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="once-类型分析"><a class="header" href="#once-类型分析">Once 类型分析</a></h3>
<p>Once是对全局变量的初始化必须在多个线程中(例如，库)竞争执行且只需要执行一次时的需求的方案。<br />
C的pthread库实现了pthread_once来实现这个特性。RUST实现了自己的方案。Once的call_once方法使得可以用闭包的形式初始化全局变量，闭包内的代码不必考虑竞争，由Once确保线程安全且只初始化只被执行一次。<br />
代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Masked = ();

pub struct Once {
    //用一个变量即实现状态，又实现了等待队列的头节点
    //最后两位是Once的状态，前面是* const Waiter的裸指针地址
    //Waiter是4字节对齐，因此地址最后两位为0，
    //这个设计技巧不值得倡导,这里是为了效率考虑 
    state_and_queue: AtomicPtr&lt;Masked&gt;,
    //state_and_queue中包含了一个等待的头节点的裸指针
    _marker: marker::PhantomData&lt;*const Waiter&gt;,
}

//不能自动生成这两个trait
unsafe impl Sync for Once {}
unsafe impl Send for Once {}

impl UnwindSafe for Once {}

impl RefUnwindSafe for Once {}

pub struct OnceState {
    //闭包执行期间出现panic的标识
    poisoned: bool,
    //给初始化闭包使用，用来标识是否中毒，或者已经顺利完成
    set_state_on_drop_to: Cell&lt;*mut Masked&gt;,
}

//所有的静态变量可以使用ONCE_INIT进行赋值
pub const ONCE_INIT: Once = Once::new();

//闭包没有执行
const INCOMPLETE: usize = 0x0;
//闭包执行时线程panic
const POISONED: usize = 0x1;
//闭包正在执行
const RUNNING: usize = 0x2;
//初始化完成
const COMPLETE: usize = 0x3;

// 用来取出最后两位，用来做INCOMPLETE/POISONED/RUNNING/COMPLETE
const STATE_MASK: usize = 0x3;

//用来作为等待的线程队列节点，这些线程都对once做了闭包初始化的调用
#[repr(align(4))] //确保指针的地址的后2位无意义，可以用来作为状态，这是一个不值得推倡的技巧 
struct Waiter {
    //标识自身
    thread: Cell&lt;Option&lt;Thread&gt;&gt;,
    signaled: AtomicBool,
    //next的节点
    next: *const Waiter,
}

// 等待的队列.
struct WaiterQueue&lt;'a&gt; {
    //Once的state_and_queue的引用
    state_and_queue: &amp;'a AtomicPtr&lt;Masked&gt;,
    //初始化闭包的返回结果
    set_state_on_drop_to: *mut Masked,
}

impl Once {
    //一般直接使用ONCE_INIT
    pub const fn new() -&gt; Once {
        Once {
            //初始赋值
            state_and_queue: AtomicPtr::new(ptr::invalid_mut(INCOMPLETE)),
            _marker: marker::PhantomData,
        }
    }

    //例如ONCE_INIT.call_once(|| {}), 在函数体内，可以对全局变量执行初始化，不必考虑
    //线程间安全问题。
    pub fn call_once&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce(),
    {
        // 是否已经完成初始化
        if self.is_completed() {
            return;
        }
        
        //以下将FnOnce()转换为了FnMut(state)
        let mut f = Some(f);
        //需要处理panic情况
        self.call_inner(false, &amp;mut |_| f.take().unwrap()());
    }

    //不理会panic的初始化
    pub fn call_once_force&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce(&amp;OnceState),
    {
        if self.is_completed() {
            return;
        }

        let mut f = Some(f);
        self.call_inner(true, &amp;mut |p| f.take().unwrap()(p));
    }

    pub fn is_completed(&amp;self) -&gt; bool {
        self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE
    }

    fn call_inner(&amp;self, ignore_poisoning: bool, init: &amp;mut dyn FnMut(&amp;OnceState)) {
        let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);
        loop {
            //判断当前状态
            match state_and_queue.addr() {
                //没有等待线程且初始化完毕
                COMPLETE =&gt; break,
                //没有等待线程且已经POISONED，且不能忽视panic做初始化
                POISONED if !ignore_poisoning =&gt; {
                    // Panic to propagate the poison.
                    panic!(&quot;Once instance has previously been poisoned&quot;);
                }
                //没有等待线程，没有初始化，或者已经panic但可以初始化
                POISONED | INCOMPLETE =&gt; {
                    // 将状态转为RUNNING 
                    let exchange_result = self.state_and_queue.compare_exchange(
                        state_and_queue,
                        ptr::invalid_mut(RUNNING),
                        Ordering::Acquire,
                        Ordering::Acquire,
                    );
                    //判断是否出现竞争
                    if let Err(old) = exchange_result {
                        //有竞争者，再次做循环
                        state_and_queue = old;
                        continue;
                    }
                    // 本线程获得初始化权利, 后面这段代码不会有竞争出现
                    // 创建其他线程等待的队列
                    let mut waiter_queue = WaiterQueue {
                        //设置Once的state_and_que为队列头部
                        state_and_queue: &amp;self.state_and_queue,
                        //默认是POISONED
                        set_state_on_drop_to: ptr::invalid_mut(POISONED),
                    };
                    // 设置初始化状态
                    let init_state = OnceState {
                        poisoned: state_and_queue.addr() == POISONED,
                        //默认为COMPLETE
                        set_state_on_drop_to: Cell::new(ptr::invalid_mut(COMPLETE)),
                    };
                    //调用初始化函数
                    init(&amp;init_state);
                    //对等待队列中的状态进行更新, 如果初始化闭包不关心init_state(call_once), 则默认为COMPLETE
                    waiter_queue.set_state_on_drop_to = init_state.set_state_on_drop_to.get();
                    //waiter_queue被释放，调用drop
                    break;
                }
                _ =&gt; {
                    // RUNNING，进入阻塞状态 
                    assert!(state_and_queue.addr() &amp; STATE_MASK == RUNNING);
                    wait(&amp;self.state_and_queue, state_and_queue);
                    //阻塞被唤醒，重新获取新的状态并再次做判断循环
                    state_and_queue = self.state_and_queue.load(Ordering::Acquire);
                }
            }
        }
    }
}

//进入等待队列
fn wait(state_and_queue: &amp;AtomicPtr&lt;Masked&gt;, mut current_state: *mut Masked) {

    loop {
        //在不是初次循环的情况下，初始化结束后的竞争赋值
        //可能导致current_state被更新。
        if current_state.addr() &amp; STATE_MASK != RUNNING {
            return;
        }

        // 针对本线程创建一个等待队列的节点 
        let node = Waiter {
            thread: Cell::new(Some(thread::current())),
            signaled: AtomicBool::new(false),
            //将地址清零后两位后，得到Waiter节点的地址
            //如果是头节点，此处的偏移为0，next即是0
            next: current_state.with_addr(current_state.addr() &amp; !STATE_MASK) as *const Waiter,
        };
        //本身作为下一个节点时的地址
        let me = &amp;node as *const Waiter as *const Masked as *mut Masked;

        //更换当前的state_and_queue，将新创建的node作为队列头
        let exchange_result = state_and_queue.compare_exchange(
            current_state,
            //node的地址与状态做或操作，一个变量即是队列头，又是状态
            me.with_addr(me.addr() | RUNNING),
            Ordering::Release,
            Ordering::Relaxed,
        );
        //判断是否成功
        if let Err(old) = exchange_result {
            //不成功，更新current_state，再次循环
            //此时
            current_state = old;
            //此处node会被drop掉
            continue;
        }
        
        //下面的代码面对一个非常复杂的竞争冲突分析
        //作为一个课题留给读者

        while !node.signaled.load(Ordering::Acquire) {
            //如果没有发信号，则阻塞
            thread::park();
            //阻塞结束后，进入循环再次判断是否信号已经被接收
        }
        break;
    }
}

impl Drop for WaiterQueue&lt;'_&gt; {
    fn drop(&amp;mut self) {
        //更新Once的state_and_queue的值,并获取老值,
        //这个做法对规避竞争有很大的意义
        //即我的孩子我领走。
        let state_and_queue =
            self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);

        // 老值应该只可能是RUNNING状态
        assert_eq!(state_and_queue.addr() &amp; STATE_MASK, RUNNING);

        unsafe {
            //获取等待的队列头地址
            let mut queue =
                state_and_queue.with_addr(state_and_queue.addr() &amp; !STATE_MASK) as *const Waiter;
            while !queue.is_null() {
                //保存下一个节点信息
                let next = (*queue).next;
                //发送信号，唤醒等待的线程
                let thread = (*queue).thread.take().unwrap();
                (*queue).signaled.store(true, Ordering::Release);
                queue = next;
                thread.unpark();
            }
        }
    }
}

//留给初始化闭包函数使用。
impl OnceState {
    pub fn is_poisoned(&amp;self) -&gt; bool {
        self.poisoned
    }

    pub(crate) fn poison(&amp;self) {
        self.set_state_on_drop_to.set(ptr::invalid_mut(POISONED));
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="oncelock类型分析"><a class="header" href="#oncelock类型分析">OnceLock类型分析</a></h3>
<p><code>OnceLock&lt;T&gt;</code>是<code>OnceCell&lt;T&gt;</code>在多线程下的版本，也Once的一个具体的实例。
提供了多线程的情况下对变量做一次性初始化的解决方案。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OnceLock&lt;T&gt; {
    //保证多线程情况下仅做一次初始化
    once: Once,
    // 被仅初始化一次的变量 
    value: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,
    //因为value是MaybeUninit&lt;T&gt;，所以需要PhantomData向编译器提示
    //本结构负责T的释放，以便编译器进行drop check
    _marker: PhantomData&lt;T&gt;,
}

impl&lt;T&gt; OnceLock&lt;T&gt; {
    //创建函数
    pub const fn new() -&gt; OnceLock&lt;T&gt; {
        OnceLock {
            once: Once::new(),
            //获得正确的内存
            value: UnsafeCell::new(MaybeUninit::uninit()),
            _marker: PhantomData,
        }
    }

    //直接获取内部变量的引用
    unsafe fn get_unchecked(&amp;self) -&gt; &amp;T {
        debug_assert!(self.is_initialized());
        //请参考UnsafeCell的内容
        (&amp;*self.value.get()).assume_init_ref()
    }

    //直接获取内部变量的可变引用
    unsafe fn get_unchecked_mut(&amp;mut self) -&gt; &amp;mut T {
        debug_assert!(self.is_initialized());
        (&amp;mut *self.value.get()).assume_init_mut()
    }

    //仅在初始化过后才能返回内部引用
    pub fn get(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.is_initialized() {
            // Safe b/c checked is_initialized
            Some(unsafe { self.get_unchecked() })
        } else {
            None
        }
    }

    //仅在初始化过后才能返回内部变量可变引用
    pub fn get_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        if self.is_initialized() {
            // Safe b/c checked is_initialized and we have a unique access
            Some(unsafe { self.get_unchecked_mut() })
        } else {
            None
        }
    }

    //如果已经初始化，返回内部变量引用，
    //否则，调用f进行初始化，然后返回内部变量引用
    pub fn get_or_init&lt;F&gt;(&amp;self, f: F) -&gt; &amp;T
    where
        F: FnOnce() -&gt; T,
    {
        //Ok::&lt;T,!&gt;(f())将FnOnce()-&gt;T转换成了
        //FnOnce()-&gt;Result&lt;T,!&gt;, 
        //并且只可能返回Ok()的值
        match self.get_or_try_init(|| Ok::&lt;T, !&gt;(f())) {
            Ok(val) =&gt; val,
            //编译器分析出不会返回Err，
        }
    }

    //可能不成功
    pub fn get_or_try_init&lt;F, E&gt;(&amp;self, f: F) -&gt; Result&lt;&amp;T, E&gt;
    where
        F: FnOnce() -&gt; Result&lt;T, E&gt;,
    {
        // 如果已经初始化完成，则返回
        if let Some(value) = self.get() {
            return Ok(value);
        }
        //见后继方法的分析
        self.initialize(f)?;

        debug_assert!(self.is_initialized());

        //再次获得内部变量引用并返回
        Ok(unsafe { self.get_unchecked() })
    }

    //上面方法的支持方法
    fn initialize&lt;F, E&gt;(&amp;self, f: F) -&gt; Result&lt;(), E&gt;
    where
        F: FnOnce() -&gt; Result&lt;T, E&gt;,
    {
        let mut res: Result&lt;(), E&gt; = Ok(());
        let slot = &amp;self.value;

        //利用once实现仅初始化一次
        self.once.call_once_force(|p| {
            match f() {
                Ok(value) =&gt; {
                    //实现对value的赋值
                    unsafe { (&amp;mut *slot.get()).write(value) };
                }
                Err(e) =&gt; {
                    res = Err(e);

                    //设置once状态为POSIONED
                    p.poison();
                }
            }
        });
        res
    }

    //修改内部变量的值,这个方法的编码技巧值得学习
    pub fn set(&amp;self, value: T) -&gt; Result&lt;(), T&gt; {
        //用Some来做是否成功的判断
        let mut value = Some(value);
        //此处仅当赋值成功时才会调用value.take().unwrap()
        self.get_or_init(|| value.take().unwrap());
        match value {
            //成功设置了值
            None =&gt; Ok(()),
            //内部变量已经初始化过了
            Some(value) =&gt; Err(value),
        }
    }


    //对一个Pin&lt;&amp;Self&gt;做初始化
    pub(crate) fn get_or_init_pin&lt;F, G&gt;(self: Pin&lt;&amp;Self&gt;, f: F, g: G) -&gt; Pin&lt;&amp;T&gt;
    where
        F: FnOnce() -&gt; T,
        G: FnOnce(Pin&lt;&amp;mut T&gt;),
    {
        //判断是否初始化完毕
        if let Some(value) = self.get_ref().get() {
            //初始化完毕，创建一个Pin返回
            return unsafe { Pin::new_unchecked(value) };
        }

        let slot = &amp;self.value;

        self.once.call_once_force(|_| {
            let value = f();
            let value: &amp;mut T = unsafe { (&amp;mut *slot.get()).write(value) };
            //初始化成功后，调用回调函数g,完成进一步初始化
            g(unsafe { Pin::new_unchecked(value) });
        });

        //创建Pin返回
        unsafe { Pin::new_unchecked(self.get_ref().get_unchecked()) }
    }

    //消费掉self，返回内部变量
    pub fn into_inner(mut self) -&gt; Option&lt;T&gt; {
        //见后继分析
        self.take()
    }

    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.is_initialized() {
            //重新创建一个Once
            self.once = Once::new();
            //将内部变量读出，并将value设置为默认值
            unsafe { Some((&amp;mut *self.value.get()).assume_init_read()) }
        } else {
            None
        }
    }

    fn is_initialized(&amp;self) -&gt; bool {
        self.once.is_completed()
    }

}
<span class="boring">}</span></code></pre></pre>
<h3 id="lazylock类型分析"><a class="header" href="#lazylock类型分析">LazyLock类型分析</a></h3>
<p><code>LazyLock&lt;T&gt;</code>是<code>Lazy&lt;T&gt;</code>的多线程版本</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//惰性，在解引用时进行初始化
pub struct LazyLock&lt;T, F = fn() -&gt; T&gt; {
    //初始化的目的类型
    cell: OnceLock&lt;T&gt;,
    //保存初始化闭包
    init: Cell&lt;Option&lt;F&gt;&gt;,
}

impl&lt;T, F&gt; LazyLock&lt;T, F&gt; {
    pub const fn new(f: F) -&gt; LazyLock&lt;T, F&gt; {
        LazyLock { cell: OnceLock::new(), init: Cell::new(Some(f)) }
    }
}

impl&lt;T, F: FnOnce() -&gt; T&gt; LazyLock&lt;T, F&gt; {
    //执行初始化
    pub fn force(this: &amp;LazyLock&lt;T, F&gt;) -&gt; &amp;T {
        //利用OnceLock及闭包进行初始化
        this.cell.get_or_init(|| match this.init.take() {
            Some(f) =&gt; f(),
            None =&gt; panic!(&quot;Lazy instance has previously been poisoned&quot;),
        })
    }
}

//在此方法进行初始化
impl&lt;T, F: FnOnce() -&gt; T&gt; Deref for LazyLock&lt;T, F&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        LazyLock::force(self)
    }
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="线程管理分析"><a class="header" href="#线程管理分析">线程管理分析</a></h2>
<p>RUST的线程主要由以下几部分组成：</p>
<ol>
<li>线程属性设置，线程创建，join，销毁等,是操作系统系统调用的RUST延伸</li>
<li>线程局部存储, 是操作系统系统调用的RUST延伸</li>
<li>线程运行时及panic管理, 是RUST的异常处理方案一部分</li>
<li>RUST运行时</li>
<li>为在线程中借用环境变量的Scope方案，是RUST语言自身的特性</li>
</ol>
<h3 id="基于操作系统调用封装的底层线程结构"><a class="header" href="#基于操作系统调用封装的底层线程结构">基于操作系统调用封装的底层线程结构</a></h3>
<p>均以linux为例，wasi与linux基本相同</p>
<h4 id="线程类型结构"><a class="header" href="#线程类型结构">线程类型结构</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Thread结构，pthread函数需要用此结构作为参数调用pthread的API
// 这里 id没有象fd那样实现RawFd, OwnedFd, BorrowedFd
pub struct Thread {
    id: libc::pthread_t,
}

// Thread当然应该支持Send 及 Sync
unsafe impl Send for Thread {}
unsafe impl Sync for Thread {}

impl Thread {
    // 熟悉C语言的会发现这个函数很容易理解，基本和C的同类型函数
    // 可以一一映射。大量的libc的调用直接导致用unsafe标记这个函数 
    pub unsafe fn new(stack: usize, p: Box&lt;dyn FnOnce()&gt;) -&gt; io::Result&lt;Thread&gt; {
        //申请一个堆内存存放Box&lt;dyn FnOnce()&gt;, 并解封，将p直接置为申请的堆内存地址
        // p就是线程函数指针
        let p = Box::into_raw(box p);
        //等于pthread_t native = 0;
        let mut native: libc::pthread_t = mem::zeroed();
        let mut attr: libc::pthread_attr_t = mem::zeroed();
        //pthread_attr_init出错是有可能的，此处标准库偷了懒
        assert_eq!(libc::pthread_attr_init(&amp;mut attr), 0);

        //对线程栈进行设置，一般不必设置
        {
            //线程栈不能小于允许最小的栈，实际上最大栈也应该有限制
            let stack_size = cmp::max(stack, min_stack_size(&amp;attr));

            //设置线程栈大小
            match libc::pthread_attr_setstacksize(&amp;mut attr, stack_size) {
                0 =&gt; {}
                n =&gt; {
                    assert_eq!(n, libc::EINVAL);
                    // 仅在参数不是内存页整数倍的情况会执行下面代码,重新调整栈空间,并设置，
                    // 此时的设置不应该再出错
                    let page_size = os::page_size();
                    let stack_size =
                        (stack_size + page_size - 1) &amp; (-(page_size as isize - 1) as usize - 1);
                    assert_eq!(libc::pthread_attr_setstacksize(&amp;mut attr, stack_size), 0);
                }
            };
        }

        //创建线程，thread_start是线程主函数，见后面分析
        //输入的闭包p作为thread_start的参数，attr当前只处理栈大小，成功后native会被赋值
        let ret = libc::pthread_create(&amp;mut native, &amp;attr, thread_start, p as *mut _);
        // attr任务完成，释放其申请的资源，C编程的时候这一步经常被忽略，这也是RUST的一个安全体现
        // 此处RUST认为不会失败 
        assert_eq!(libc::pthread_attr_destroy(&amp;mut attr), 0);

        return if ret != 0 {
            // 失败
            // 重新建立Box以便释放申请的堆内存
            drop(Box::from_raw(p));
            //获取操作系统的错误
            Err(io::Error::from_raw_os_error(ret))
        } else {
            //成功，创建Thread返回
            Ok(Thread { id: native })
        };

        //所有RUST线程的主函数
        extern &quot;C&quot; fn thread_start(main: *mut libc::c_void) -&gt; *mut libc::c_void {
            unsafe {
                // 这个是线程栈保护机制，如果线程出现栈溢出，可以用这个机制探测到， 
                // 这个是C语言编写大的服务器应用如数据库等积累下来的经验
                // 对C来说必要性是很大的，具体的代码分析略
                let _handler = stack_overflow::Handler::new();
                // 先将传入的堆内存重组为Box，然后自动解双层引用消费掉两个Box并运行真正的
                //线程函数 
                Box::from_raw(main as *mut Box&lt;dyn FnOnce()&gt;)();
            }
            //C函数的返回值
            ptr::null_mut()
        }
    }

    pub fn yield_now() {
        //让出CPU
        let ret = unsafe { libc::sched_yield() };
        debug_assert_eq!(ret, 0);
    }

    pub fn set_name(name: &amp;CStr) {
        const PR_SET_NAME: libc::c_int = 15;
        // 更改线程名字，具体的系统调用请参考libc库 
        unsafe {
            libc::prctl(
                PR_SET_NAME,
                name.as_ptr(),
                0 as libc::c_ulong,
                0 as libc::c_ulong,
                0 as libc::c_ulong,
            );
        }
    }

    //线程睡眠,可以认为是glibc的sleep函数的RUST版本
    pub fn sleep(dur: Duration) {
        let mut secs = dur.as_secs();
        let mut nsecs = dur.subsec_nanos() as _;

        unsafe {
            //一次睡不到位就多睡几次, 另外也可能被中途打断，那需要再接着睡，
            // 以下这段代码值得注意，nanosleep让以前简单的调用一次usleep的我深感惭愧
            while secs &gt; 0 || nsecs &gt; 0 {
                //准备C语言时间变量
                let mut ts = libc::timespec {
                    tv_sec: cmp::min(libc::time_t::MAX as u64, secs) as libc::time_t,
                    tv_nsec: nsecs,
                };
                secs -= ts.tv_sec as u64;
                let ts_ptr = &amp;mut ts as *mut _;
                if libc::nanosleep(ts_ptr, ts_ptr) == -1 {
                    assert_eq!(os::errno(), libc::EINTR);
                    //中途被打断的话，ts_ptr会放置还剩余的时间
                    //因此要把时间重新加入，下一次循环再睡
                    //真的是容易被忽视的返回值
                    secs += ts.tv_sec as u64;
                    nsecs = ts.tv_nsec;
                } else {
                    //重新置值
                    nsecs = 0;
                }
            }
        }
    }

    //等待目标线程结束
    pub fn join(self) {
        unsafe {
            let ret = libc::pthread_join(self.id, ptr::null_mut());
            //默认是非join，此处的作用是取消drop导致的默认pthread_detach调用
            mem::forget(self);
            assert!(ret == 0, &quot;failed to join thread: {}&quot;, io::Error::from_raw_os_error(ret));
        }
    }

    pub fn id(&amp;self) -&gt; libc::pthread_t {
        //此处所有权没有转移。一般用于做pthread的系统调用临时使用
        //但不能用这个返回的id调用pthread_detach或者pthread_join及类似功能的pthread
        //C函数
        self.id
    }

    pub fn into_id(self) -&gt; libc::pthread_t {
        let id = self.id;
        //pthread_detach应该由调用此函数的代码负责。
        //所有权已经转移
        mem::forget(self);
        id
    }
}

impl Drop for Thread {
    //主要用于父线程不必等待子线程结束的情况，默认为不等待
    fn drop(&amp;mut self) {
        let ret = unsafe { libc::pthread_detach(self.id) };
        debug_assert_eq!(ret, 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="线程堆栈溢出守卫及运行时"><a class="header" href="#线程堆栈溢出守卫及运行时">线程堆栈溢出守卫及运行时</a></h4>
<p>RUST在操作系统线程的基础上，实现了线程栈内存的溢出检查:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//线程栈溢出守卫
pub mod guard {
    // 内存页大小
    static PAGE_SIZE: AtomicUsize = AtomicUsize::new(0);

    pub type Guard = Range&lt;usize&gt;;

    //获取线程栈栈底(栈溢出)内存地址，
    unsafe fn get_stack_start() -&gt; Option&lt;*mut libc::c_void&gt; {
        //以下实际上可以认为是一个使用了RUST语法的C函数,
        //具体的pthread函数请参观相关手册 
        let mut ret = None;
        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();
        let e = libc::pthread_getattr_np(libc::pthread_self(), &amp;mut attr);
        if e == 0 {
            let mut stackaddr = crate::ptr::null_mut();
            let mut stacksize = 0;
            assert_eq!(libc::pthread_attr_getstack(&amp;attr, &amp;mut stackaddr, &amp;mut stacksize), 0);
            ret = Some(stackaddr);
        }
        if e == 0 {
            assert_eq!(libc::pthread_attr_destroy(&amp;mut attr), 0);
        }
        ret
    }

    // 获取从线程栈栈底(地址小的一侧)找到的第一个内存页对齐的地址
    unsafe fn get_stack_start_aligned() -&gt; Option&lt;*mut libc::c_void&gt; {
        let page_size = PAGE_SIZE.load(Ordering::Relaxed);
        assert!(page_size != 0);
        let stackptr = get_stack_start()?;
        let stackaddr = stackptr.addr();

        // 以下计算从栈底向栈顶方向找到第一个对齐地址
        let remainder = stackaddr % page_size;
        Some(if remainder == 0 {
            stackptr
        } else {
            stackptr.with_addr(stackaddr + page_size - remainder)
        })
    }

    pub unsafe fn init() -&gt; Option&lt;Guard&gt; {
        //获得内存页大小
        let page_size = os::page_size();
        PAGE_SIZE.store(page_size, Ordering::Relaxed);

        {
            // Linux 内核已经做了栈守护，所以使用内核的机制
            let stackptr = get_stack_start_aligned()?;
            let stackaddr = stackptr.addr();
            Some(stackaddr - page_size..stackaddr)
        } 
    }
    //获取当前栈守护地址
    pub unsafe fn current() -&gt; Option&lt;Guard&gt; {
        let mut ret = None;
        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();
        let e = libc::pthread_getattr_np(libc::pthread_self(), &amp;mut attr);
        if e == 0 {
            let mut guardsize = 0;
            assert_eq!(libc::pthread_attr_getguardsize(&amp;attr, &amp;mut guardsize), 0);
            if guardsize == 0 {
                    panic!(&quot;there is no guard page&quot;);
            }
            let mut stackptr = crate::ptr::null_mut::&lt;libc::c_void&gt;();
            let mut size = 0;
            assert_eq!(libc::pthread_attr_getstack(&amp;attr, &amp;mut stackptr, &amp;mut size), 0);

            let stackaddr = stackptr.addr();
            let ret = {
                Some(stackaddr - guardsize..stackaddr + guardsize)
            }
        }
        ret
    }
}

fn min_stack_size(attr: *const libc::pthread_attr_t) -&gt; usize {
    //用动态链接获取库函数
    dlsym!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -&gt; libc::size_t);

    match __pthread_get_minstack.get() {
        None =&gt; libc::PTHREAD_STACK_MIN,
        Some(f) =&gt; unsafe { f(attr) },
    }
}
//以上的代码对于C程序员，是比较容易理解的，因为涉及到大量的pthread的库函数

// 专用于处理栈溢出的结构及实现
pub struct Handler {
    data: *mut libc::c_void,
}

impl Handler {
    pub unsafe fn new() -&gt; Handler {
        //主要用于完成溢出处理函数的栈处置
        make_handler()
    }

    fn null() -&gt; Handler {
        Handler { data: crate::ptr::null_mut() }
    }
}

impl Drop for Handler {
    fn drop(&amp;mut self) {
        unsafe {
            drop_handler(self.data);
        }
    }
}

//stack_overflow模块
mod imp {
    // 对SIGSEGV及SIGBUS的信号处理函数。这两个函数会在线程出现栈溢出时被触发
    unsafe extern &quot;C&quot; fn signal_handler(
        signum: libc::c_int,
        info: *mut libc::siginfo_t,
        _data: *mut libc::c_void,
    ) {
        let guard = thread_info::stack_guard().unwrap_or(0..0);
        let addr = (*info).si_addr() as usize;

        // 判断是否访问了栈保护端的地址，如果是，则输出告警信息
        if guard.start &lt;= addr &amp;&amp; addr &lt; guard.end {
            rtprintpanic!(
                &quot;\nthread '{}' has overflowed its stack\n&quot;,
                thread::current().name().unwrap_or(&quot;&lt;unknown&gt;&quot;)
            );
            rtabort!(&quot;stack overflow&quot;);
        } else {
            // 否则执行默认操作.
            let mut action: sigaction = mem::zeroed();
            action.sa_sigaction = SIG_DFL;
            sigaction(signum, &amp;action, ptr::null_mut());
        }
    }

    static MAIN_ALTSTACK: AtomicPtr&lt;libc::c_void&gt; = AtomicPtr::new(ptr::null_mut());
    static NEED_ALTSTACK: AtomicBool = AtomicBool::new(false);

    //初始化信号函数注册，此函数似乎,在sys::init中被调用
    pub unsafe fn init() {
        let mut action: sigaction = mem::zeroed();
        for &amp;signal in &amp;[SIGSEGV, SIGBUS] {
            sigaction(signal, ptr::null_mut(), &amp;mut action);
            // 配置保护内存访问的信号处理函数.
            if action.sa_sigaction == SIG_DFL {
                action.sa_flags = SA_SIGINFO | SA_ONSTACK;
                action.sa_sigaction = signal_handler as sighandler_t;
                sigaction(signal, &amp;action, ptr::null_mut());
                NEED_ALTSTACK.store(true, Ordering::Relaxed);
            }
        }

        let handler = make_handler();
        MAIN_ALTSTACK.store(handler.data, Ordering::Relaxed);
        mem::forget(handler);
    }

    pub unsafe fn cleanup() {
        drop_handler(MAIN_ALTSTACK.load(Ordering::Relaxed));
    }

    //下面这段函数是将段保护的内存设置成用户态写入会触发缺页中断，从而触发信号
    unsafe fn get_stackp() -&gt; *mut libc::c_void {
        let flags = MAP_PRIVATE | MAP_ANON | libc::MAP_STACK;
        //mmap一段内存作为信号处理函数的栈，额外一个page用作保护
        let stackp =
            mmap(ptr::null_mut(), SIGSTKSZ + page_size(), PROT_READ | PROT_WRITE, flags, -1, 0);
        if stackp == MAP_FAILED {
            panic!(&quot;failed to allocate an alternative stack: {}&quot;, io::Error::last_os_error());
        }
        // 最低的一个page用来作为保护
        let guard_result = libc::mprotect(stackp, page_size(), PROT_NONE);
        if guard_result != 0 {
            panic!(&quot;failed to set up alternative stack guard page: {}&quot;, io::Error::last_os_error());
        }
        // 真正的栈从底部向上一个page开始
        stackp.add(page_size())
    }

    unsafe fn get_stack() -&gt; libc::stack_t {
        libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }
    }

    //用于对每个线程设置线程信号处理的栈
    pub unsafe fn make_handler() -&gt; Handler {
        if !NEED_ALTSTACK.load(Ordering::Relaxed) {
            return Handler::null();
        }
        let mut stack = mem::zeroed();
        sigaltstack(ptr::null(), &amp;mut stack);
        // 设置信号处理函数的栈 
        if stack.ss_flags &amp; SS_DISABLE != 0 {
            //设置用于信号处理的栈
            stack = get_stack();
            // 设置栈，长度为SIGSTKSZ
            sigaltstack(&amp;stack, ptr::null_mut());
            Handler { data: stack.ss_sp as *mut libc::c_void }
        } else {
            Handler::null()
        }
    }

    pub unsafe fn drop_handler(data: *mut libc::c_void) {
        if !data.is_null() {
            let stack = libc::stack_t {
                ss_sp: ptr::null_mut(),
                ss_flags: SS_DISABLE,
                ss_size: SIGSTKSZ,
            };
            //删除信号处理函数专用栈
            sigaltstack(&amp;stack, ptr::null_mut());
            // unmap用于信号处理的内存.
            munmap(data.sub(page_size()), SIGSTKSZ + page_size());
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<h4 id="线程局部变量类型"><a class="header" href="#线程局部变量类型">线程局部变量类型</a></h4>
<p>线程的本地全局变量Thread Local Key的实现。线程的本地存储解决一类问题如下：
在线程代码中，有时希望多个线程共享同一个变量名的全局变量，以简化编码。但希望这个变量在不同的线程有各自的拷贝，彼此不影响。典型的例子就是前文的线程栈guard空间。如果每个线程都共享同一个变量名，那代码会少很多啰嗦。
具体的代码分析如下:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//pthread_key_t请参考libc的pthread编程手册
pub type Key = libc::pthread_key_t;

//dtor用于对创建的key做释放操作, 返回的Key可以被进程中的线程共享使用
pub unsafe fn create(dtor: Option&lt;unsafe extern &quot;C&quot; fn(*mut u8)&gt;) -&gt; Key {
    let mut key = 0;
    assert_eq!(libc::pthread_key_create(&amp;mut key, mem::transmute(dtor)), 0);
    key
}

// 各线程可以将key设置成自己需要的内存块，这个内存块的所有权属于Key，
// 这是个代码规定，编译器不知道，所以安全上需要程序员负责
pub unsafe fn set(key: Key, value: *mut u8) {
    let r = libc::pthread_setspecific(key, value as *mut _);
    debug_assert_eq!(r, 0);
}

// 用key将内存块获得，实际上是获得一个引用
pub unsafe fn get(key: Key) -&gt; *mut u8 {
    libc::pthread_getspecific(key) as *mut u8
}

// 删除掉key，需要所有线程都删除，调用此函数会导致调用内存块的dtor函数，也即drop
pub unsafe fn destroy(key: Key) {
    let r = libc::pthread_key_delete(key);
    debug_assert_eq!(r, 0);
}

<span class="boring">}</span></code></pre></pre>
<h3 id="标准库线程支持层代码分析"><a class="header" href="#标准库线程支持层代码分析">标准库线程支持层代码分析</a></h3>
<p>代码路径：library/std/src/sys_common/thread.rs<br />
library/std/src/sys_common/thread_local.rs
library/std/src/sys_common/thread_info.rs</p>
<p>在操作系统的线程概念与RUST作为API提供的线程之间的一层代码。主要处理一些RUST的语法导致的一些需要额外在操作系统的线程结构做一些包装的基础层。</p>
<p>对Thread Local Key做类型封装，以屏蔽不同操作系统除API外的差异。<br />
代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//适用与作为静态变量的Thread Local Key结构
pub struct StaticKey {
    /// 仅仅是一个数值，为0的时候代表此时无意义
    key: AtomicUsize,
    ///对key的析构函数 
    dtor: Option&lt;unsafe extern &quot;C&quot; fn(*mut u8)&gt;,
}

//一般作为StaticKey的初始化赋值
pub const INIT: StaticKey = StaticKey::new(None);

impl StaticKey {
    pub const fn new(dtor: Option&lt;unsafe extern &quot;C&quot; fn(*mut u8)&gt;) -&gt; StaticKey {
        //key为0，代表此时没有创建thread local key
        StaticKey { key: atomic::AtomicUsize::new(0), dtor }
    }

    //如果没有创建thread local key, 此方法会创建一个
    pub unsafe fn get(&amp;self) -&gt; *mut u8 {
        //获取key的指针
        //调用self.key会在无thread local key时创建一个
        imp::get(self.key())
    }

    //如果没有创建thread local key, 此方法会创建一个
    pub unsafe fn set(&amp;self, val: *mut u8) {
        imp::set(self.key(), val)
    }

    //获得thread local key的key值
    unsafe fn key(&amp;self) -&gt; imp::Key {
        match self.key.load(Ordering::Relaxed) {
            //如果为0，表示thread local key没有创建，需要创建一个
            0 =&gt; self.lazy_init() as imp::Key,
            //不为0，则返回key
            n =&gt; n as imp::Key,
        }
    }

    //创建一个thread local key
    unsafe fn lazy_init(&amp;self) -&gt; usize {
        // 为特殊的操作系统准备
        if imp::requires_synchronized_create() {
            // 需要加锁保护，因为保护静态变量，所以要使用StaticMutex
            // INIT_LOCK所有线程共享
            static INIT_LOCK: StaticMutex = StaticMutex::new();
            let _guard = INIT_LOCK.lock();
            let mut key = self.key.load(Ordering::SeqCst);
            if key == 0 {
                //创建Key
                key = imp::create(self.dtor) as usize;
                self.key.store(key, Ordering::SeqCst);
            }
            rtassert!(key != 0);
            return key;
            //_guard生命周期结束会释放INIT_LOCK
        }

        //unix系统有可能分配为0的thread local key
        let key1 = imp::create(self.dtor);
        let key = if key1 != 0 {
            key1
        } else {
            //如果是0，需要重新再申请一个新的key
            let key2 = imp::create(self.dtor);
            imp::destroy(key1);
            key2
        };
        rtassert!(key != 0);
        match self.key.compare_exchange(0, key as usize, Ordering::SeqCst, Ordering::SeqCst) {
            //这里也作为方法的返回
            Ok(_) =&gt; key as usize,
            // 如果有其他的值，那就用那个值， 
            Err(n) =&gt; {
                imp::destroy(key);
                n
            }
        }
    }
}

//非静态变量的Thread Local Key
pub struct Key {
    key: imp::Key,
}

impl Key {
    // 创建一个thread local key
    pub fn new(dtor: Option&lt;unsafe extern &quot;C&quot; fn(*mut u8)&gt;) -&gt; Key {
        Key { key: unsafe { imp::create(dtor) } }
    }

    // 获取key相关的内存，可能为空，
    pub fn get(&amp;self) -&gt; *mut u8 {
        unsafe { imp::get(self.key) }
    }

    //设置key相关的内存
    pub fn set(&amp;self, val: *mut u8) {
        unsafe { imp::set(self.key, val) }
    }
}

impl Drop for Key {
    fn drop(&amp;mut self) {
        // Right now Windows doesn't support TLS key destruction, but this also
        // isn't used anywhere other than tests, so just leak the TLS key.
        // unsafe { imp::destroy(self.key) }
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="标准库线程局部变量外部接口thread-local"><a class="header" href="#标准库线程局部变量外部接口thread-local">标准库线程局部变量外部接口(Thread Local)</a></h3>
<p>操作系统的Thread Local Key使用起来明显非常繁琐，且很容易出错。RUST标准库对其进行了符合<code>rust</code>的类型封装。这一类型需要完成的工作如下：</p>
<ol>
<li>对所有的Thread Local Key存放的真正的数据类型需要声明key时做定义。</li>
<li>向使用者屏蔽key的创建及销毁过程，key与真实数据的捆绑与获取过程，使得key的使用类似于通用类型结构的使用。</li>
</ol>
<p>RUST采用了宏及数据类型相结合的方案，下面的代码说明了RUST的local key的使用。</p>
<pre><pre class="playground"><code class="language-rust"> use std::cell::RefCell;
 thread_local! {
     pub static FOO: RefCell&lt;u32&gt; = RefCell::new(1);

     static BAR: RefCell&lt;f32&gt; = RefCell::new(1.0);
 }
 fn main() {FOO.with(|f|{*f.borrow_mut() = 2})}</code></pre></pre>
<p>以上的<code>thread_local</code>将一个普通的变量定义转换为Thread Local Key的变量. 并且可以在随后的with方法内可以正常的的使用该普通变量。用这种方法，RUST使得Thread Local Key的变量使用与普通变量基本上做到了相一致。 (其他语言多用set(),get()方法完成Thread local的操作，RUST采用了更近一步的设计)<br />
具体的代码实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//LocalKey只能用于静态变量
pub struct LocalKey&lt;T: 'static&gt; {
    //只能用于静态变量
    //inner是一个支持泛型的函数类型
    inner: unsafe fn(Option&lt;&amp;mut Option&lt;T&gt;&gt;) -&gt; Option&lt;&amp;'static T&gt;,
}

pub struct AccessError;

impl Error for AccessError {}

impl&lt;T: 'static&gt; LocalKey&lt;T&gt; {
    // 这里仅仅做一个内存占位
    pub const unsafe fn new(
        inner: unsafe fn(Option&lt;&amp;mut Option&lt;T&gt;&gt;) -&gt; Option&lt;&amp;'static T&gt;,
    ) -&gt; LocalKey&lt;T&gt; {
        LocalKey { inner }
    }

    //所有的Thread Local的操作都在witch参数的闭包中，
    // with会将Thread Local的可变引用输入闭包的参数
    pub fn with&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R
    where
        F: FnOnce(&amp;T) -&gt; R,
    {
        self.try_with(f).expect(
            &quot;cannot access a Thread Local Storage value \
             during or after destruction&quot;,
        )
    }

    pub fn try_with&lt;F, R&gt;(&amp;'static self, f: F) -&gt; Result&lt;R, AccessError&gt;
    where
        F: FnOnce(&amp;T) -&gt; R,
    {
        unsafe {
            //获取Thread Local内存指针后，调用闭包
            let thread_local = (self.inner)(None).ok_or(AccessError)?;
            Ok(f(thread_local))
        }
    }

    //对Thread Local做初始化，然后再执行操作
    fn initialize_with&lt;F, R&gt;(&amp;'static self, init: T, f: F) -&gt; R
    where
        F: FnOnce(Option&lt;T&gt;, &amp;T) -&gt; R,
    {
        unsafe {
            let mut init = Some(init);
            let reference = (self.inner)(Some(&amp;mut init)).expect(
                &quot;cannot access a Thread Local Storage value \
                 during or after destruction&quot;,
            );
            f(init, reference)
        }
    }
}

//LocalKey通常会与内部可变性变量配合,设计方法来简化使用者的代码
impl&lt;T: 'static&gt; LocalKey&lt;Cell&lt;T&gt;&gt; {
    //对内部可变性变量赋值
    pub fn set(&amp;'static self, value: T) {
        self.initialize_with(Cell::new(value), |value, cell| {
            if let Some(value) = value {
                // value输入的Cell变量参数，cell是Thread Local的引用
                // 对cell做出更新,并消费掉value.
                cell.set(value.into_inner());
            }
        });
    }

    //只能在T实现Copy trait的情况下支持，否则会出现
    //双份所有权
    pub fn get(&amp;'static self) -&gt; T
    where
        T: Copy,
    {
        self.with(|cell| cell.get())
    }

    //获取Thread Local的变量所有权，并将Thread Local置为默认
    pub fn take(&amp;'static self) -&gt; T
    where
        T: Default,
    {
        self.with(|cell| cell.take())
    }

    //替换
    pub fn replace(&amp;'static self, value: T) -&gt; T {
        self.with(|cell| cell.replace(value))
    }
}

//提供Thread Local是内部可变性的基础
impl&lt;T: 'static&gt; LocalKey&lt;RefCell&lt;T&gt;&gt; {
    //borrow的对应简化
    pub fn with_borrow&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R
    where
        F: FnOnce(&amp;T) -&gt; R,
    {
        self.with(|cell| f(&amp;cell.borrow()))
    }

    //borrow_mut的对应简化
    pub fn with_borrow_mut&lt;F, R&gt;(&amp;'static self, f: F) -&gt; R
    where
        F: FnOnce(&amp;mut T) -&gt; R,
    {
        self.with(|cell| f(&amp;mut cell.borrow_mut()))
    }

    //修改值
    pub fn set(&amp;'static self, value: T) {
        self.initialize_with(RefCell::new(value), |value, cell| {
            if let Some(value) = value {
                *cell.borrow_mut() = value.into_inner();
            }
        });
    }

    //获取所有权
    pub fn take(&amp;'static self) -&gt; T
    where
        T: Default,
    {
        self.with(|cell| cell.take())
    }

    //替换
    pub fn replace(&amp;'static self, value: T) -&gt; T {
        self.with(|cell| cell.replace(value))
    }
}

/// 惰性初始化.
mod lazy {
    use crate::cell::UnsafeCell;
    use crate::hint;
    use crate::mem;

    pub struct LazyKeyInner&lt;T&gt; {
        //None作为未初始化的标志
        inner: UnsafeCell&lt;Option&lt;T&gt;&gt;,
    }

    impl&lt;T&gt; LazyKeyInner&lt;T&gt; {
        //new一个未初始化变量
        pub const fn new() -&gt; LazyKeyInner&lt;T&gt; {
            LazyKeyInner { inner: UnsafeCell::new(None) }
        }

        pub unsafe fn get(&amp;self) -&gt; Option&lt;&amp;'static T&gt; {
            // 返回内部变量的引用
            unsafe { (*self.inner.get()).as_ref() }
        }

        // 真正的初始化
        pub unsafe fn initialize&lt;F: FnOnce() -&gt; T&gt;(&amp;self, init: F) -&gt; &amp;'static T {
            let value = init();
            let ptr = self.inner.get();

            // 如果用*ptr = Some(value)，会导致编译器对上一个变量做drop处理,对Thread Local
            // 的drop实际上有些复杂，所以此处用一个replace
            unsafe {
                let _ = mem::replace(&amp;mut *ptr, Some(value));
            }

            unsafe {
                // 返回Some内变量的引用.
                match *ptr {
                    Some(ref x) =&gt; x,
                    None =&gt; hint::unreachable_unchecked(),
                }
            }
        }

        //take语义
        pub unsafe fn take(&amp;mut self) -&gt; Option&lt;T&gt; {
            unsafe { (*self.inner.get()).take() }
        }
    }
}

//利用llvm的Thread Local方案，不直接使用操作系统系统调用的thread local key
pub mod fast {
    use super::lazy::LazyKeyInner;
    use crate::cell::Cell;
    use crate::fmt;
    use crate::mem;
    use crate::sys::thread_local_dtor::register_dtor;

    #[derive(Copy, Clone)]
    enum DtorState {
        //没有初始化
        Unregistered,
        //已经初始化完成
        Registered,
        //Local Key已经被destroy
        RunningOrHasRun,
    }

    pub struct Key&lt;T&gt; {
        //  放置key存储的变量, None表示变量没有初始化。与dtor_state配合完成对
        //  Key的状态判断
        inner: LazyKeyInner&lt;T&gt;,

        // Local Key的destroy函数状态 
        dtor_state: Cell&lt;DtorState&gt;,
    }


    impl&lt;T&gt; Key&lt;T&gt; {
        pub const fn new() -&gt; Key&lt;T&gt; {
            //实际做内存占位
            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }
        }

        // 证明仍然使用操作系统的thread local key的destory机制 
        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern &quot;C&quot; fn(*mut u8)) {
            unsafe {
                register_dtor(a, dtor);
            }
        }

        pub unsafe fn get&lt;F: FnOnce() -&gt; T&gt;(&amp;self, init: F) -&gt; Option&lt;&amp;'static T&gt; {
            // 如果已经初始化，则取用值
            // 如果没有初始化，则进行初始化
            unsafe {
                match self.inner.get() {
                    Some(val) =&gt; Some(val),
                    None =&gt; self.try_initialize(init),
                }
            }
        }

        #[inline(never)]
        unsafe fn try_initialize&lt;F: FnOnce() -&gt; T&gt;(&amp;self, init: F) -&gt; Option&lt;&amp;'static T&gt; {
            if !mem::needs_drop::&lt;T&gt;() || unsafe { self.try_register_dtor() } {
                // 只用变量不需要drop，或者注册destroy函数成功的情况下才做初始化.
                Some(unsafe { self.inner.initialize(init) })
            } else {
                None
            }
        }

        unsafe fn try_register_dtor(&amp;self) -&gt; bool {
            match self.dtor_state.get() {
                DtorState::Unregistered =&gt; {
                    // 注册destroy函数
                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::&lt;T&gt;) };
                    self.dtor_state.set(DtorState::Registered);
                    true
                }
                DtorState::Registered =&gt; {
                    // 被递归初始化
                    true
                }
                DtorState::RunningOrHasRun =&gt; false,
            }
        }
    }

    unsafe extern &quot;C&quot; fn destroy_value&lt;T&gt;(ptr: *mut u8) {
        let ptr = ptr as *mut Key&lt;T&gt;;

        unsafe {
            //将变量所有权获得
            let value = (*ptr).inner.take();
            //设置destroy状态
            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);
            //对变量做drop
            drop(value);
        }
    }
}

//利用操作系统的StaticKey
pub mod os {
    use super::lazy::LazyKeyInner;
    use crate::cell::Cell;
    use crate::fmt;
    use crate::marker;
    use crate::ptr;
    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;

    pub struct Key&lt;T&gt; {
        // 操作系统的静态Key.
        os: OsStaticKey,
        //指示本结构有一个Cell&lt;T&gt;的所有权
        marker: marker::PhantomData&lt;Cell&lt;T&gt;&gt;,
    }

    unsafe impl&lt;T&gt; Sync for Key&lt;T&gt; {}

    struct Value&lt;T: 'static&gt; {
        inner: LazyKeyInner&lt;T&gt;,
        key: &amp;'static Key&lt;T&gt;,
    }

    impl&lt;T: 'static&gt; Key&lt;T&gt; {
        pub const fn new() -&gt; Key&lt;T&gt; {
            //创建一个StaticKey
            Key { os: OsStaticKey::new(Some(destroy_value::&lt;T&gt;)), marker: marker::PhantomData }
        }

        pub unsafe fn get(&amp;'static self, init: impl FnOnce() -&gt; T) -&gt; Option&lt;&amp;'static T&gt; {
            // thread local key的get操作.
            let ptr = unsafe { self.os.get() as *mut Value&lt;T&gt; };
            if ptr.addr() &gt; 1 {
                //有值
                if let Some(ref value) = unsafe { (*ptr).inner.get() } {
                    return Some(value);
                }
            }
            // 进行初始化.
            unsafe { self.try_initialize(init) }
        }

        unsafe fn try_initialize(&amp;'static self, init: impl FnOnce() -&gt; T) -&gt; Option&lt;&amp;'static T&gt; {
            let ptr = unsafe { self.os.get() as *mut Value&lt;T&gt; };
            if ptr.addr() == 1 {
                // 被destroy了
                return None;
            }

            let ptr = if ptr.is_null() {
                // 从堆上申请内存.
                let ptr: Box&lt;Value&lt;T&gt;&gt; = box Value { inner: LazyKeyInner::new(), key: self };
                //获取申请的堆内存地址
                let ptr = Box::into_raw(ptr);
                // 将地址与操作系统的key相关联
                unsafe {
                    self.os.set(ptr as *mut u8);
                }
                ptr
            } else {
                // 递归初始化，返回已有的ptr 
                ptr
            };

            // 初始化变量.
            unsafe { Some((*ptr).inner.initialize(init)) }
        }
    }

    unsafe extern &quot;C&quot; fn destroy_value&lt;T: 'static&gt;(ptr: *mut u8) {
        unsafe {
            //恢复Box以便释放堆内存
            let ptr = Box::from_raw(ptr as *mut Value&lt;T&gt;);
            let key = ptr.key;
            //将thread local key设置为1
            key.os.set(ptr::invalid_mut(1));
            //释放Box
            drop(ptr);
            // key可以重新用于与新的内存相关
            key.os.set(ptr::null_mut());
        }
    }
}
pub use self::local::fast::Key as __FastLocalKeyInner;
pub use self::local::os::Key as __OsLocalKeyInner;

// Thread Local声明宏
macro_rules! thread_local {
    // empty (base case for the recursion)
    () =&gt; {};

    // init 是一个const 修饰的block
    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }; $($rest:tt)*) =&gt; (
        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);
        $crate::thread_local!($($rest)*);
    );

    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }) =&gt; (
        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);
    );

    //  init不是block
    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) =&gt; (
        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);
        $crate::thread_local!($($rest)*);
    );

    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) =&gt; (
        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);
    );
}

macro_rules! __thread_local_inner {
    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) =&gt; {
        //定义了一个LocalKey的变量
        $(#[$attr])* $vis const $name: $crate::thread::LocalKey&lt;$t&gt; =
            $crate::__thread_local_inner!(@key $t, $($init)*);
    }
    //对const init的处理
    (@key $t:ty, const $init:expr) =&gt; {{
        //LocalKey的创建函数
        unsafe fn __getit(
            _init: $crate::option::Option&lt;&amp;mut $crate::option::Option&lt;$t&gt;&gt;,
        ) -&gt; $crate::option::Option&lt;&amp;'static $t&gt; {
            //不可变变量定义
            const INIT_EXPR: $t = $init;

            {
                #[thread_local]
                //静态全局变量, 应用llvm的Thread Local Storage, 需要操作系统支持
                static mut VAL: $t = INIT_EXPR;

                // 判断是否需要有drop函数
                if !$crate::mem::needs_drop::&lt;$t&gt;() {
                    //如果不需要drop，返回VAL的引用即可
                    unsafe {
                        return $crate::option::Option::Some(&amp;VAL)
                    }
                }

                // 0 == dtor not registered
                // 1 == dtor registered, dtor not run
                // 2 == dtor registered and is running or has run
                #[thread_local]
                //释放函数注册状态
                static mut STATE: $crate::primitive::u8 = 0;

                //释放函数
                unsafe extern &quot;C&quot; fn destroy(ptr: *mut $crate::primitive::u8) {
                    let ptr = ptr as *mut $t;

                    unsafe {
                        $crate::debug_assert_eq!(STATE, 1);
                        STATE = 2;
                        $crate::ptr::drop_in_place(ptr);
                    }
                }

                unsafe {
                    match STATE {
                        // 0 == 需要注册释放函数.
                        0 =&gt; {
                            //fast::Key::register_dtor，见下文分析
                            $crate::thread::__FastLocalKeyInner::&lt;$t&gt;::register_dtor(
                                $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,
                                destroy,
                            );
                            STATE = 1;
                            $crate::option::Option::Some(&amp;VAL)
                        }
                        // 1 == 释放函数已经注册，直接返回Key
                        1 =&gt; $crate::option::Option::Some(&amp;VAL),
                        // 释放函数已经运行，返回.
                        _ =&gt; $crate::option::Option::None,
                    }
                }
            }
        }

        unsafe {
            //生成LocalKey
            $crate::thread::LocalKey::new(__getit)
        }
    }};

    // 非const的init的处理
    (@key $t:ty, $init:expr) =&gt; {
        {
            fn __init() -&gt; $t { $init }

            //LocalKey的创建函数
            unsafe fn __getit(
                init: $crate::option::Option&lt;&amp;mut $crate::option::Option&lt;$t&gt;&gt;,
            ) -&gt; $crate::option::Option&lt;&amp;'static $t&gt; {
                //利用llvm编译器属性定义变量为thread local变量
                #[thread_local]
                static __KEY: $crate::thread::__FastLocalKeyInner&lt;$t&gt; =
                    $crate::thread::__FastLocalKeyInner::new();


                //初始化 
                unsafe {
                    __KEY.get(move || {
                        if let $crate::option::Option::Some(init) = init {
                            if let $crate::option::Option::Some(value) = init.take() {
                                return value;
                            } else if $crate::cfg!(debug_assertions) {
                                $crate::unreachable!(&quot;missing default value&quot;);
                            }
                        }
                        __init()
                    })
                }
            }

            unsafe {
                $crate::thread::LocalKey::new(__getit)
            }
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Thread Local的RUST标准库内容颇为复杂，但提供了非常方便的对外使用。</p>
<h3 id="thread-info-分析"><a class="header" href="#thread-info-分析">Thread Info 分析</a></h3>
<p>Thead Info利用Thread Local存储一些Thread的信息。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ThreadInfo {
    stack_guard: Option&lt;Guard&gt;,
    thread: Thread,
}

thread_local! { static THREAD_INFO: RefCell&lt;Option&lt;ThreadInfo&gt;&gt; = const { RefCell::new(None) } }

impl ThreadInfo {
    fn with&lt;R, F&gt;(f: F) -&gt; Option&lt;R&gt;
    where
        F: FnOnce(&amp;mut ThreadInfo) -&gt; R,
    {
        THREAD_INFO
            .try_with(move |thread_info| {
                let mut thread_info = thread_info.borrow_mut();
                let thread_info = thread_info.get_or_insert_with(|| ThreadInfo {
                    stack_guard: None,
                    thread: Thread::new(None),
                });
                f(thread_info)
            })
            .ok()
    }
}

pub fn current_thread() -&gt; Option&lt;Thread&gt; {
    ThreadInfo::with(|info| info.thread.clone())
}

pub fn stack_guard() -&gt; Option&lt;Guard&gt; {
    ThreadInfo::with(|info| info.stack_guard.clone()).and_then(|o| o)
}

pub fn set(stack_guard: Option&lt;Guard&gt;, thread: Thread) {
    THREAD_INFO.with(move |thread_info| {
        let mut thread_info = thread_info.borrow_mut();
        rtassert!(thread_info.is_none());
        *thread_info = Some(ThreadInfo { stack_guard, thread });
    });
}

<span class="boring">}</span></code></pre></pre>
<h3 id="标准库线程外部接口分析"><a class="header" href="#标准库线程外部接口分析">标准库线程外部接口分析</a></h3>
<p>RUST在操作系统的线程支持之上，实现了语言自身的线程概念，首要的，就是为每一个线程分配一个ID做标识。
即ThreadId, 代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//用一个非零的64位整数
pub struct ThreadId(NonZeroU64);

impl ThreadId {
    // 分配一个新的线程ID 
    fn new() -&gt; ThreadId {
        // 线程ID是一个全局静态变量，且是一个临界区访问，此处只能用StaticMutex锁
        static GUARD: mutex::StaticMutex = mutex::StaticMutex::new();
        //声明静态变量,是全局的静态变量，但声明在这里限制对其的访问, 初始值为1
        static mut COUNTER: u64 = 1;

        unsafe {
            //防止竞争
            let guard = GUARD.lock();

            // 加入到达最大值，panic处理。这里默认一个进程不可能创建超过u64::MAX的线程.
            // 这个稍微有些不严谨，因为即使线程终止，ID也不能重用。可以认为，一个进程不可能运行到这个时间
            if COUNTER == u64::MAX {
                drop(guard); //panic之前显式drop，以避免影响其他线程 
                //错误处理
                panic!(&quot;failed to generate unique thread ID: bitspace exhausted&quot;);
            }

            //分配新线程ID
            let id = COUNTER;
            COUNTER += 1;

            ThreadId(NonZeroU64::new(id).unwrap())
            //guard生命周期结束，会调用drop()
        }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Thread park的实现，Thread park是一种将线程自身陷入阻塞，等待别的线程做唤醒的机制。是一种比较简单的多个线程间的同步机制，通常用于线程指令执行过程中有顺序要求但不必临界区的情况</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PARKED: i32 = -1;
const EMPTY: i32 = 0;
const NOTIFIED: i32 = 1;

pub struct Parker {
    state: AtomicI32,
}

// Parker 利用原子变量操作中的内存顺序规则完成.
impl Parker {
    #[inline]
    pub const fn new() -&gt; Self {
        Parker { state: AtomicI32::new(EMPTY) }
    }

    //只被本线程调用
    pub unsafe fn park(&amp;self) {
        // 利用Acquire顺序获取当前状态 
        if self.state.fetch_sub(1, Acquire) == NOTIFIED {
            return;
        }
        loop {
            // 如果state是PARKED，阻塞等待 
            futex_wait(&amp;self.state, PARKED, None);
            // 被唤醒，将状态重新置为EMPTY,并检测是否为NOTIFIED.
            if self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Acquire).is_ok() {
                return;
            } else {
                // 应该是语法要求，逻辑上不应该进入此分支，因为不应该有其他线程调用park.
            }
        }
    }

    // 超时.
    pub unsafe fn park_timeout(&amp;self, timeout: Duration) {
        if self.state.fetch_sub(1, Acquire) == NOTIFIED {
            return;
        }
        // 直接等待，设置超时，此时不再循环，因为循环会导致超时不准.
        futex_wait(&amp;self.state, PARKED, Some(timeout));
        if self.state.swap(EMPTY, Acquire) == NOTIFIED {
            // 被unpark()唤醒
        } else {
            // 超时或者其他唤醒.
        }
    }

    pub fn unpark(&amp;self) {
        // 将state更换到NOTIFIED
        if self.state.swap(NOTIFIED, Release) == PARKED {
            //唤醒阻塞的线程
            futex_wake(&amp;self.state);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST标准库的Thread的对外结构:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 事实上的Thread结构
struct Inner {
    name: Option&lt;CString&gt;, //需要与外部语言库交互 
    id: ThreadId,
    // 用于park
    parker: Parker,
}

//Thread的管理类型
#[derive(Clone)]
pub struct Thread {
    //需要被多个线程共享
    inner: Arc&lt;Inner&gt;,
}

impl Thread {
    // 仅创建一个结构用于管理，此时尚没有与线程相关联.
    pub(crate) fn new(name: Option&lt;CString&gt;) -&gt; Thread {
        Thread { inner: Arc::new(Inner { name, id: ThreadId::new(), parker: Parker::new() }) }
    }

    //对thread做unpark操作，使得park的thread结束阻塞。
    pub fn unpark(&amp;self) {
        self.inner.parker.unpark();
    }

    pub fn id(&amp;self) -&gt; ThreadId {
        self.inner.id
    }

    pub fn name(&amp;self) -&gt; Option&lt;&amp;str&gt; {
        self.cname().map(|s| unsafe { str::from_utf8_unchecked(s.to_bytes()) })
    }

    fn cname(&amp;self) -&gt; Option&lt;&amp;CStr&gt; {
        self.inner.name.as_deref()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST的进程创建返回类型 JoinHandle：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct JoinInner&lt;'scope, T&gt; {
    native: imp::Thread,
    thread: Thread,
    packet: Arc&lt;Packet&lt;'scope, T&gt;&gt;,
}

impl&lt;'scope, T&gt; JoinInner&lt;'scope, T&gt; {
    fn join(mut self) -&gt; Result&lt;T&gt; {
        //等待线程退出
        self.native.join();
        //获取线程退出的结果或者异常信息
        Arc::get_mut(&amp;mut self.packet).unwrap().result.get_mut().take().unwrap()
    }
}

//调用spawn后返回JoinHandle，JoinHandle作为线程外部对该线程操作的标识类型结构,如park，join等
pub struct JoinHandle&lt;T&gt;(JoinInner&lt;'static, T&gt;);

unsafe impl&lt;T&gt; Send for JoinHandle&lt;T&gt; {}
unsafe impl&lt;T&gt; Sync for JoinHandle&lt;T&gt; {}


impl&lt;T&gt; JoinHandle&lt;T&gt; {
    //获取线程的Thread结构引用
    pub fn thread(&amp;self) -&gt; &amp;Thread {
        &amp;self.0.thread
    }

    //等待线程结束
    pub fn join(self) -&gt; Result&lt;T&gt; {
        self.0.join()
    }

    //判断线程是否已经终止
    pub fn is_finished(&amp;self) -&gt; bool {
        Arc::strong_count(&amp;self.0.packet) == 1
    }
}

<span class="boring">}</span></code></pre></pre>
<p>RUST线程创建工厂类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//用于非默认属性的线程创建
pub struct Builder {
    // 名字，线程默认没有名字
    name: Option&lt;String&gt;,
    // 线程堆栈大小，默认堆栈为2M bytes
    stack_size: Option&lt;usize&gt;,
}

// 线程创建方法实现
impl Builder {
    //创建一个默认的builder，一般的，用于需要对name及stack_size做修改
    pub fn new() -&gt; Builder {
        Builder { name: None, stack_size: None }
    }

    //给线程设置名称，目前仅用于线程panic时的信息输出
    pub fn name(mut self, name: String) -&gt; Builder {
        self.name = Some(name);
        self
    }

    //设置线程的堆栈空间
    pub fn stack_size(mut self, size: usize) -&gt; Builder {
        self.stack_size = Some(size);
        self
    }

    // 利用Builder属性参数创建一个新线程。如果不是在主线程执行这个函数，
    // 新线程的生命周期可能长于创建它的线程，此时创建线程可以用JoinHandle来等待
    // 新线程结束。
    pub fn spawn&lt;F, T&gt;(self, f: F) -&gt; io::Result&lt;JoinHandle&lt;T&gt;&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
    {
        unsafe { self.spawn_unchecked(f) }
    }

    //不安全的spawn
    pub unsafe fn spawn_unchecked&lt;'a, F, T&gt;(self, f: F) -&gt; io::Result&lt;JoinHandle&lt;T&gt;&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'a,
        T: Send + 'a,
    {
        Ok(JoinHandle(unsafe { self.spawn_unchecked_(f, None) }?))
    }

    //真正的spawn执行函数，此处与进程的spawn函数有些类似
    unsafe fn spawn_unchecked_&lt;'a, 'scope, F, T&gt;(
        self,
        f: F,
        scope_data: Option&lt;&amp;'scope scoped::ScopeData&gt;,
    ) -&gt; io::Result&lt;JoinInner&lt;'scope, T&gt;&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'a,
        T: Send + 'a,
        'scope: 'a,
    {
        let Builder { name, stack_size } = self;

        //不能小于规定的最小堆栈
        let stack_size = stack_size.unwrap_or_else(thread::min_stack);

        //创建一个Thread的变量
        let my_thread = Thread::new(name.map(|name| {
            CString::new(name).expect(&quot;thread name may not contain interior null bytes&quot;)
        }));
        //增加Arc计数，用于转移到创建的线程代码
        let their_thread = my_thread.clone();

        let my_packet: Arc&lt;Packet&lt;'scope, T&gt;&gt; =
            Arc::new(Packet { scope: scope_data, result: UnsafeCell::new(None) });
        //Arc计数增加，子线程写，父线程读
        let their_packet = my_packet.clone();

        //捕获panic输出的缓存空间设置,是Thread Local变量
        let output_capture = crate::io::set_output_capture(None);
        crate::io::set_output_capture(output_capture.clone());

        //所有线程的主函数, 可以认为是线程的runtime
        let main = move || {
            //their_thread已经转移到创建线程
            if let Some(name) = their_thread.cname() {
                //设置线程名字
                imp::Thread::set_name(name);
            }

            //设置本线程的panic捕获空间
            crate::io::set_output_capture(output_capture);

            // 完成thread_info的线程本地初始化.
            thread_info::set(unsafe { imp::guard::current() }, their_thread);
            // 执行f，如果f内部发生panic，调用栈会输出
            let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {
                crate::sys_common::backtrace::__rust_begin_short_backtrace(f)
            }));
            //  将线程退出信息设置到their_packet中
            unsafe { *their_packet.result.get() = Some(try_result) };
        };

        if let Some(scope_data) = scope_data {
            scope_data.increment_num_running_threads();
        }

        //真正的创建线程
        Ok(JoinInner {
            //创建线程
            native: unsafe {
                imp::Thread::new(
                    stack_size,
                    mem::transmute::&lt;Box&lt;dyn FnOnce() + 'a&gt;, Box&lt;dyn FnOnce() + 'static&gt;&gt;(
                        Box::new(main),
                    ),
                )?
            },
            thread: my_thread,
            packet: my_packet,
        })
    }
}

//无须指定参数的简易线程启动函数
pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new().spawn(f).expect(&quot;failed to spawn thread&quot;)
}

//线程自身的结构变量获取
pub fn current() -&gt; Thread {
    thread_info::current_thread().expect(
        &quot;use of std::thread::current() is not possible \
         after the thread's local data has been destroyed&quot;,
    )
}

//出让CPU
pub fn yield_now() {
    imp::Thread::yield_now()
}

//本线程是否已经panic
pub fn panicking() -&gt; bool {
    panicking::panicking()
}

//阻塞，等待其他线程唤醒
pub fn park() {
    unsafe {
        current().inner.parker.park();
    }
}

pub fn park_timeout(dur: Duration) {
    unsafe {
        current().inner.parker.park_timeout(dur);
    }
}

pub type Result&lt;T&gt; = crate::result::Result&lt;T, Box&lt;dyn Any + Send + 'static&gt;&gt;;

// 用来获取线程的退出值
// 需要在线程间共享
struct Packet&lt;'scope, T&gt; {
    scope: Option&lt;&amp;'scope scoped::ScopeData&gt;,
    result: UnsafeCell&lt;Option&lt;Result&lt;T&gt;&gt;&gt;,
}

// 使用了UnsafeCell， 需要声明实现Sync
unsafe impl&lt;'scope, T: Sync&gt; Sync for Packet&lt;'scope, T&gt; {}

impl&lt;'scope, T&gt; Drop for Packet&lt;'scope, T&gt; {
    fn drop(&amp;mut self) {
        // If this packet was for a thread that ran in a scope, the thread
        // panicked, and nobody consumed the panic payload, we make sure
        // the scope function will panic.
        let unhandled_panic = matches!(self.result.get_mut(), Some(Err(_)));
        // Drop the result without causing unwinding.
        // This is only relevant for threads that aren't join()ed, as
        // join() will take the `result` and set it to None, such that
        // there is nothing left to drop here.
        // If this panics, we should handle that, because we're outside the
        // outermost `catch_unwind` of our thread.
        // We just abort in that case, since there's nothing else we can do.
        // (And even if we tried to handle it somehow, we'd also need to handle
        // the case where the panic payload we get out of it also panics on
        // drop, and so on. See issue #86027.)
        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| {
            *self.result.get_mut() = None;
        })) {
            rtabort!(&quot;thread result panicked on drop&quot;);
        }
        // Book-keeping so the scope knows when it's done.
        if let Some(scope) = self.scope {
            // 在scope spawn线程时，在此处保证唤醒park的主线程
            scope.decrement_num_running_threads(unhandled_panic);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST线程 scope 结构,因为线程的主函数是闭包函数，对所有环境变量都是以借用引入，这会导致
因为线程不知道何时结束而出现环境变量的生命周期问题，利用scope使得线程闭包可以正常借用环境变量</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Scope&lt;'scope, 'env: 'scope&gt; {
    //主要用来做生命周期的保证
    data: ScopeData,
    //指示线程的生命周期
    scope: PhantomData&lt;&amp;'scope mut &amp;'scope ()&gt;,
    //指示环境变量的生命周期
    env: PhantomData&lt;&amp;'env mut &amp;'env ()&gt;,
}

/// JoinHandle的scoped 版本
pub struct ScopedJoinHandle&lt;'scope, T&gt;(JoinInner&lt;'scope, T&gt;);

pub(super) struct ScopeData {
    num_running_threads: AtomicUsize,
    a_thread_panicked: AtomicBool,
    main_thread: Thread,
}

impl ScopeData {
    pub(super) fn increment_num_running_threads(&amp;self) {
        //spawn线程时增加计数
        if self.num_running_threads.fetch_add(1, Ordering::Relaxed) &gt; usize::MAX / 2 {
            self.decrement_num_running_threads(false);
            panic!(&quot;too many running threads in thread scope&quot;);
        }
    }
    pub(super) fn decrement_num_running_threads(&amp;self, panic: bool) {
        if panic {
            self.a_thread_panicked.store(true, Ordering::Relaxed);
        }
        //减少线程计数
        if self.num_running_threads.fetch_sub(1, Ordering::Release) == 1 {
            //唤醒主线程
            self.main_thread.unpark();
        }
    }
}

// socpe内部创建的线程可以借用非静态变量
// 其中，'env是环境变量的生命周期，'scope是线程的生命周期
pub fn scope&lt;'env, F, T&gt;(f: F) -&gt; T
where
    F: for&lt;'scope&gt; FnOnce(&amp;'scope Scope&lt;'scope, 'env&gt;) -&gt; T,
{
    let scope = Scope {
        data: ScopeData {
            num_running_threads: AtomicUsize::new(0),
            main_thread: current(),
            a_thread_panicked: AtomicBool::new(false),
        },
        env: PhantomData,
        scope: PhantomData,
    };

    // Run `f`, but catch panics so we can make sure to wait for all the threads to join.
    let result = catch_unwind(AssertUnwindSafe(|| f(&amp;scope)));

    // 等待所有的线程都退出，保证线程的生命周期小于本函数的生命周期.
    while scope.data.num_running_threads.load(Ordering::Acquire) != 0 {
        park();
    }

    // Throw any panic from `f`, or the return value of `f` if no thread panicked.
    match result {
        Err(e) =&gt; resume_unwind(e),
        Ok(_) if scope.data.a_thread_panicked.load(Ordering::Relaxed) =&gt; {
            panic!(&quot;a scoped thread panicked&quot;)
        }
        Ok(result) =&gt; result,
    }
}

impl&lt;'scope, 'env&gt; Scope&lt;'scope, 'env&gt; {
    //用于在scope中创建新线程
    pub fn spawn&lt;F, T&gt;(&amp;'scope self, f: F) -&gt; ScopedJoinHandle&lt;'scope, T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'scope,
        T: Send + 'scope,
    {
        Builder::new()
            .spawn_scoped(self, f)
            .expect(&quot;failed to spawn thread&quot;)
    }
}

impl Builder {
    // 在scope情况下创建线程
    pub fn spawn_scoped&lt;'scope, 'env, F, T&gt;(
        self,
        scope: &amp;'scope Scope&lt;'scope, 'env&gt;,
        f: F,
    ) -&gt; io::Result&lt;ScopedJoinHandle&lt;'scope, T&gt;&gt;
    where
        //设置了生命周期，使得f可以使用环境变量引用
        F: FnOnce() -&gt; T + Send + 'scope,
        T: Send + 'scope,
    {
        Ok(ScopedJoinHandle(unsafe {
            self.spawn_unchecked_(f, Some(&amp;scope.data))
        }?))
    }
}

//利用生命周期的标注来使用环境变量引用
impl&lt;'scope, T&gt; ScopedJoinHandle&lt;'scope, T&gt; {
    
    pub fn thread(&amp;self) -&gt; &amp;Thread {
        &amp;self.0.thread
    }

    pub fn join(self) -&gt; Result&lt;T&gt; {
        self.0.join()
    }

    pub fn is_finished(&amp;self) -&gt; bool {
        Arc::strong_count(&amp;self.0.packet) == 1
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust线程间消息通信"><a class="header" href="#rust线程间消息通信">RUST线程间消息通信</a></h2>
<p>在网络操作系统中，线程间使用消息通信被广泛采用，甚至线程间通信仅使用消息机制。主要因为如果线程之间仅使用消息机制的话，即基本可以保证没有临界区，从而减少内存安全问题的情况。一般的，针对每个线程创建一个多个生产者，单个消费者的消息队列，消费者绑定在这个线程上，其他需要与此线程通信的线程是生产者。这种系统一般会确定一个通用的消息协议格式。
消息通信的方式需要尽量规避过长的消息内容。</p>
<p>代码路径：library/std/src/sync/mpsc/<em>.</em></p>
<p>本书将只讨论mpsc这一机制，spsc的分析留给读者。<br />
RUST将通信分成了三种情况：</p>
<ol>
<li>最初建立连接时，默认为仅做一次发送，接收，即oneshot通道形式</li>
<li>如果发送多于一个包，但收线程及发线程都固定为同一个，则升级为stream通道形式</li>
<li>如果发送线程多于一个，则升级为shared通道形式</li>
</ol>
<p>采用如此复杂的情况，虽然有合理的成分，但感觉标准库的作者实际上是在炫技，并且不想被人轻易的理解其思路及想法。实际上，统一使用shared的形式即可靠，又简单。因为升级这个过程实际上极易引发问题。
mpsc模块中复杂的主要结构类型如下：</p>
<ol>
<li>Queue结构，用于消费者及接受者之间存储消息的队列，是满足Sync的类型结构</li>
<li>SignalToken/WaitToken结构，用于解除接收线程的阻塞信号</li>
<li><code>oneshot::Packet&lt;T&gt;</code> oneshot类型的channel机制</li>
<li><code>shared::Packet&lt;T&gt;</code> shared类型的channel机制</li>
<li><code>Sender&lt;Flavor&lt;T&gt;&gt;</code>, <code>Receiver&lt;Flavor&lt;T&gt;&gt;</code>是接收及发送的端口</li>
</ol>
<p>我们将分节对其进行介绍</p>
<h3 id="消息队列数据结构实现"><a class="header" href="#消息队列数据结构实现">消息队列数据结构实现</a></h3>
<p>多于一个消息包的时候，需要消息队列，RUST用于消息包的队列结构是一个无锁的，无阻塞的临界区队列，非常巧妙的设计，是需要牢记在心的, 充分体现了RUST标准库开发人员高超的编程技巧。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//以下是简单的FIFO的队列实现
pub enum PopResult&lt;T&gt; {
    //返回队列成员
    Data(T),
    //队列为空
    Empty,
    //在有些时刻会出现瞬间的不一致情况
    Inconsistent,
}

//节点结构
struct Node&lt;T&gt; {
    //next指针,利用原子指针实现多线程的Sync，值得牢记
    next: AtomicPtr&lt;Node&lt;T&gt;&gt;,
    value: Option&lt;T&gt;,
}

///  能够被多个线程操作的队列
pub struct Queue&lt;T&gt; {
    //利用原子指针操作实现多线程的Sync，极大简化了代码
    head: AtomicPtr&lt;Node&lt;T&gt;&gt;,
    //从后面的代码看，这里实际上是队列的头部，这个Queue的代码搞得奇怪
    tail: UnsafeCell&lt;*mut Node&lt;T&gt;&gt;,
}

unsafe impl&lt;T: Send&gt; Send for Queue&lt;T&gt; {}
unsafe impl&lt;T: Send&gt; Sync for Queue&lt;T&gt; {}

impl&lt;T&gt; Node&lt;T&gt; {
    unsafe fn new(v: Option&lt;T&gt;) -&gt; *mut Node&lt;T&gt; {
        //申请堆内存后，将堆内存的指针提取出来
        Box::into_raw(box Node { next: AtomicPtr::new(ptr::null_mut()), value: v })
    }
}

impl&lt;T&gt; Queue&lt;T&gt; {
    pub fn new() -&gt; Queue&lt;T&gt; {
        let stub = unsafe { Node::new(None) };
        //生成一个空元素的节点列表
        Queue { head: AtomicPtr::new(stub), tail: UnsafeCell::new(stub) }
    }

    //在头部
    pub fn push(&amp;self, t: T) {
        unsafe {
            let n = Node::new(Some(t));
            //换成C的话，就是head-&gt;next = n; head = n
            //对于空队列来说，是tail = head; head-&gt;next = n; head = n; 
            //现在tail实际上是队列头部，head是尾部。tail的next是第一个有意义的成员 
            let prev = self.head.swap(n, Ordering::AcqRel);
            //要考虑在两个赋值中间加入了其他线程的操作是否会出问题,
            //这里面有一个复杂的分析，
            //假设原队列为head, 有两个线程分别插入新节点n,m
            //当n先执行，而m在这个代码位置插入，则m插入前prev_n = pre_head, head = n
            //m插入后，prev_m = n, head = m。如果n先执行下面的语句，执行完后 
            // pre_head-&gt;next = n, n-&gt;next = null，然后m执行完下面语句
            // pre_head-&gt;next = n, n-&gt;next = m, head = m，队列是正确的。
            // 如果m先执行，执行完后 pre_head-&gt;next = null, n-&gt;next = m, head = m;
            // 然后n执行，执行完成后 pre_head-&gt;next = n, n-&gt;next = m, head =m， 队列是正确的。
            // 换成多个线程实际上也一样是正确的。这个地方处理十分巧妙，这是系统级编程语言的魅
            //力, 当然，实际上是裸指针编程的魅力  
            //当然，在这个过程中会出现Inconsistent          
            (*prev).next.store(n, Ordering::Release);
            
        }
    }

    //仅有一个线程在pop
    pub fn pop(&amp;self) -&gt; PopResult&lt;T&gt; {
        unsafe {
            //tail实际上是队列头，value是None
            let tail = *self.tail.get();
            //tail的next是第一个有意义的成员
            let next = (*tail).next.load(Ordering::Acquire);

            //next如果为空，说明队列是空队列
            if !next.is_null() {
                //此处原tail会被drop，tail被赋成next
                //因为push只可能改变next，所以这里不会有线程冲突问题
                //这个语句完成后，队列是完整及一致的 
                *self.tail.get() = next;
                assert!((*tail).value.is_none());
                assert!((*next).value.is_some());
                //将value的所有权转移出来，*next的value又重新置为None
                //当tail == head的时候 就又都是stub了
                let ret = (*next).value.take().unwrap();
                //恢复Box，以便以后释放堆内存
                let _: Box&lt;Node&lt;T&gt;&gt; = Box::from_raw(tail);
                return Data(ret);
            }

            // 此时如果head不是tail，一般说明有线程正在push，出现了不一致的情况,但这个不一致
            // 随着另一线程插入的结束会终结
            if self.head.load(Ordering::Acquire) == tail { Empty } else { Inconsistent }
        }
    }
}

impl&lt;T&gt; Drop for Queue&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            //空队列的stub也要释放
            let mut cur = *self.tail.get();
            while !cur.is_null() {
                let next = (*cur).next.load(Ordering::Relaxed);
                //恢复Box并消费掉，释放堆内存
                let _: Box&lt;Node&lt;T&gt;&gt; = Box::from_raw(cur);
                cur = next;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="线程间简单的阻塞及唤醒信号机制"><a class="header" href="#线程间简单的阻塞及唤醒信号机制">线程间简单的阻塞及唤醒信号机制</a></h3>
<p>消息通信时，消息发送端需要有一个机制通知消息接收端消息已经发出。Condvar可以完成这一工作，但RUST的消息机制决定用无锁设计，所以做了新的实现。<br />
下面的设计具有通用性，正如上节的Queue。基本思路是：</p>
<ol>
<li>设计多个线程间的信号结构, 只允许一个线程等待在信号上，可以有多个线程触发信号解锁 </li>
<li>利用原子变量的变化来做等待及信号等待</li>
</ol>
<p>代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//线程间共享的信号结构
struct Inner {
    //指明执行信号等待的线程
    thread: Thread,
    //标志解除等待信号发送
    woken: AtomicBool,
}

unsafe impl Send for Inner {}
unsafe impl Sync for Inner {}

//信号发送端结构
pub struct SignalToken {
    inner: Arc&lt;Inner&gt;,
}

//信号接收端结构
pub struct WaitToken {
    inner: Arc&lt;Inner&gt;,
}

impl !Send for WaitToken {}

impl !Sync for WaitToken {}

//信号对创建函数,由信号等待端线程创建
pub fn tokens() -&gt; (WaitToken, SignalToken) {
    //初始为无信号
    let inner = Arc::new(Inner { thread: thread::current(), woken: AtomicBool::new(false) });
    // wait由线程本身使用
    let wait_token = WaitToken { inner: inner.clone() };
    // signal由其他线程使用
    let signal_token = SignalToken { inner };
    (wait_token, signal_token)
}

impl SignalToken {
    //发送信号以便唤醒等待线程
    pub fn signal(&amp;self) -&gt; bool {
        //更改原子变量，看是否处于等待信号状态
        let wake = self
            .inner
            .woken
            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
            .is_ok();
        if wake {
            //更改成功，接收线程会调用park阻塞，unpark解除接收线程阻塞
            self.inner.thread.unpark();
        }
        wake
    }
   
    //传递给其他线程以便用来生成SignalToken，此处只能用
    //裸指针，这里是传递没有被智能指针封装的堆内存指针
    pub unsafe fn to_raw(self) -&gt; *mut u8 {
        Arc::into_raw(self.inner) as *mut u8
    }
    
    //从to_raw生成的堆内存指针恢复为SignalToken,由发送线程完成
    pub unsafe fn from_raw(signal_ptr: *mut u8) -&gt; SignalToken {
        SignalToken { inner: Arc::from_raw(signal_ptr as *mut Inner) }
    }
}

impl WaitToken {
    //接收线程等待发送端信号
    pub fn wait(self) {
        //必须先对woken做过设置
        while !self.inner.woken.load(Ordering::SeqCst) {
            thread::park()
        }
    }

    //设置超时的等待, 请参考线程锁那一节的park内容
    pub fn wait_max_until(self, end: Instant) -&gt; bool {
        while !self.inner.woken.load(Ordering::SeqCst) {
            let now = Instant::now();
            if now &gt;= end {
                return false;
            }
            thread::park_timeout(end - now)
        }
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="oneshot通道机制实现"><a class="header" href="#oneshot通道机制实现">oneshot通道机制实现</a></h3>
<p>oneshot专门为收发一次消息包而优化的结构。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//以下用于标识通道的状态
//没有数据包
const EMPTY: *mut u8 = ptr::invalid_mut::&lt;u8&gt;(0); 
//有数据包等待被接收
const DATA: *mut u8 = ptr::invalid_mut::&lt;u8&gt;(1); 
//中断
const DISCONNECTED: *mut u8 = ptr::invalid_mut::&lt;u8&gt;(2); 
// 其他值(ptr)代表接收者信号结构变量的指针, 说明有接收者在等待接收

//消息包结构, 因为只有一次收及一次发，所以结构中除state外
//其他不涉及数据竞争
pub struct Packet&lt;T&gt; {
    // 通道状态，取值为EMPTY/DATA/DISCONNECTED/ptr
    state: AtomicPtr&lt;u8&gt;,
    // 通道内的数据, 此数据需要从发送者拷贝到此处，再拷贝到接受者，但因为仅有一个包
    // 所以性能不是关注要点
    data: UnsafeCell&lt;Option&lt;T&gt;&gt;,
    // 当发送第二个包，或者对Sender做clone时，需要进行升级,此处放置新的通道接收Receiver结构
    // 拥有所有权
    upgrade: UnsafeCell&lt;MyUpgrade&lt;T&gt;&gt;,
}

//接收时发生的错误类型结构
pub enum Failure&lt;T&gt; {
    //空错误
    Empty,
    //连接中断
    Disconnected,
    //升级中,发送线程会把ReceiverT发送过来
    Upgraded(Receiver&lt;T&gt;),
}

pub enum UpgradeResult {
    //已经成功升级为其他类型的通道
    UpSuccess,
    // 升级遇到Disconnected
    UpDisconnected,
    //接收线程阻塞及期望接收的信号
    UpWoke(SignalToken),
}

enum MyUpgrade&lt;T&gt; {
    //通道内没有包，可以不升级
    NothingSent,
    //通道内已经发送过包，需要考虑升级
    SendUsed,
    //通道已经被通知需要升级，升级后的端口在参数中
    GoUp(Receiver&lt;T&gt;),
}

impl&lt;T&gt; Packet&lt;T&gt; {
    //创建一个通道,所有的内容都是初始化值
    pub fn new() -&gt; Packet&lt;T&gt; {
        Packet {
            data: UnsafeCell::new(None),
            upgrade: UnsafeCell::new(NothingSent),
            state: AtomicPtr::new(EMPTY),
        }
    }

    //发送线程通过Sender端口发送包,发送线程应保证只调用一次 
    pub fn send(&amp;self, t: T) -&gt; Result&lt;(), T&gt; {
        unsafe {
            //检查是否已经有包发过了 
            match *self.upgrade.get() {
                //没有包发送过，则继续执行
                NothingSent =&gt; {}
                //不应该执行到此处，应该先升级再发送
                _ =&gt; panic!(&quot;sending on a oneshot that's already sent on &quot;),
            }
            assert!((*self.data.get()).is_none());
            //拷贝消息包内容
            ptr::write(self.data.get(), Some(t));
            //设置upgrade为已经发送过包，
            ptr::write(self.upgrade.get(), SendUsed);

            //更新state
            match self.state.swap(DATA, Ordering::SeqCst) {
                // 此时可以正常发送, state设置为有数据状态
                EMPTY =&gt; Ok(()),

                // 表明接收端已经destroy通道，
                DISCONNECTED =&gt; {
                    //需要state恢复成中断
                    self.state.swap(DISCONNECTED, Ordering::SeqCst);
                    //需要恢复upgrade，
                    ptr::write(self.upgrade.get(), NothingSent);
                    //需要将消息包数据回收,并返回发送出错
                    Err((&amp;mut *self.data.get()).take().unwrap())
                }

                // 不应该到达这一步 
                DATA =&gt; unreachable!(),

                // 有线程等待接收.
                ptr =&gt; {
                    //通知接收线程解除阻塞
                    SignalToken::from_raw(ptr).signal();
                    Ok(())
                }
            }
        }
    }

    // 测试是否已经发过消息包
    pub fn sent(&amp;self) -&gt; bool {
        unsafe { !matches!(*self.upgrade.get(), NothingSent) }
    }

    //接收线程通过Receiver接收
    pub fn recv(&amp;self, deadline: Option&lt;Instant&gt;) -&gt; Result&lt;T, Failure&lt;T&gt;&gt; {
        // 尽量不阻塞线程
        if self.state.load(Ordering::SeqCst) == EMPTY {
            //消息为空, 需要阻塞，生成信号通知对
            let (wait_token, signal_token) = blocking::tokens();
            //获取信号发送端的堆内存
            let ptr = unsafe { signal_token.to_raw() };

            // 设置状态为有线程在等待接收
            if self.state.compare_exchange(EMPTY, ptr, Ordering::SeqCst, Ordering::SeqCst).is_ok() {
                //设置成功，判断是否有超时
                if let Some(deadline) = deadline {
                    //设置超时，阻塞
                    let timed_out = !wait_token.wait_max_until(deadline);
                    // 判断是否超时
                    if timed_out {
                        //如果超时，做清理，如果发送端通知升级，则形成Upgraded(Receiver&lt;T&gt;)
                        // 这里的map_err(Upgraded)构建了Upgraded(Receiver&lt;T&gt;)，需要记住
                        self.abort_selection().map_err(Upgraded)?;
                    }
                    //被接收线程唤醒
                } else {
                    //没有设置超时，一直阻塞等待
                    wait_token.wait();
                    debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);
                }
            } else {
                //失败，清理信号
                drop(unsafe { SignalToken::from_raw(ptr) });
            }
            //wait_token及signal_token都生命周期终止
        }

        //此时已经有数据了
        self.try_recv()
    }

    pub fn try_recv(&amp;self) -&gt; Result&lt;T, Failure&lt;T&gt;&gt; {
        unsafe {
            match self.state.load(Ordering::SeqCst) {
                //数据为空，返回错误
                EMPTY =&gt; Err(Empty),

                //发现数据
                DATA =&gt; {
                    //修改state为EMPTY
                    let _ = self.state.compare_exchange(
                        DATA,
                        EMPTY,
                        Ordering::SeqCst,
                        Ordering::SeqCst,
                    );
                    //将数据读出
                    match (&amp;mut *self.data.get()).take() {
                        Some(data) =&gt; Ok(data),
                        None =&gt; unreachable!(),
                    }
                }

                //中断状态时，可能此通道已经被升级，要检查是否还有数据
                DISCONNECTED =&gt; match (&amp;mut *self.data.get()).take() {
                    //有数据,读出数据即可
                    Some(data) =&gt; Ok(data),
                    //没有数据，更新upgrade状态
                    None =&gt; match ptr::replace(self.upgrade.get(), SendUsed) {
                        //不是通知升级，则发送端已经关闭，返回Disconnected信息 
                        SendUsed | NothingSent =&gt; Err(Disconnected),
                        //通知升级,将Receiver&lt;T&gt;包装到返回变量返回 
                        GoUp(upgrade) =&gt; Err(Upgraded(upgrade)),
                    },
                },

                // 不可能的分支
                _ =&gt; unreachable!(),
            }
        }
    }

    // 升级管道到其他类型，由发送线程调用 
    pub fn upgrade(&amp;self, up: Receiver&lt;T&gt;) -&gt; UpgradeResult {
        unsafe {
            let prev = match *self.upgrade.get() {
                //可正常升级
                NothingSent =&gt; NothingSent,
                SendUsed =&gt; SendUsed,
                //其他状态表示已经升级完成
                _ =&gt; panic!(&quot;upgrading again&quot;),
            };
            // 将升级到的Receiver写入self.upgrade 
            ptr::write(self.upgrade.get(), GoUp(up));

            //后继不会再使用self传递消息，更新状态为DISCONNECTED
            match self.state.swap(DISCONNECTED, Ordering::SeqCst) {
                // 原状态为DATA及EMPTY，返回升级成功
                // 此时有可能消息还没有被接收
                // 返回后，发送端端口Sender会生命周期终结
                DATA | EMPTY =&gt; UpSuccess,

                //  如果已经DISCONNECT，则需要撤回本次请求
                DISCONNECTED =&gt; {
                    ptr::replace(self.upgrade.get(), prev);
                    // 升级时通道已经中断
                    UpDisconnected
                }

                // 如果有线程在等待接收， 需要将唤醒信号返回
                ptr =&gt; UpWoke(SignalToken::from_raw(ptr)),
            }
        }
    }

    //删除通道, 由发送线程在Sender被drop时调用
    pub fn drop_chan(&amp;self) {
        //更新状态
        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {
            //原状态为下面的值可以不做操作
            DATA | DISCONNECTED | EMPTY =&gt; {}

            // 如果有等待线程，则发送信号唤醒
            ptr =&gt; unsafe {
                SignalToken::from_raw(ptr).signal();
            },
        }
    }

    //删除端口,由接收线程在Receiver被drop时调用
    pub fn drop_port(&amp;self) {
        //更新状态
        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {
            DISCONNECTED | EMPTY =&gt; {}

            // 如果有数据，需要删除它
            DATA =&gt; unsafe {
                (&amp;mut *self.data.get()).take().unwrap();
                //数据包生命周期终止
            },

            // 接收线程才能调用这个函数
            _ =&gt; unreachable!(),
        }
    }

    // 阻塞超时处理.
    pub fn abort_selection(&amp;self) -&gt; Result&lt;bool, Receiver&lt;T&gt;&gt; {
        //获取state
        let state = match self.state.load(Ordering::SeqCst) {
            // 这些状态不用处理 
            s @ (EMPTY | DATA | DISCONNECTED) =&gt; s,

            // ptr是本线程设置的，切换回EMPTY状态, 并把信号指针带回
            ptr =&gt; self
                .state
                .compare_exchange(ptr, EMPTY, Ordering::SeqCst, Ordering::SeqCst)
                .unwrap_or_else(|x| x),
        };

        match state {
            //不应该出现这个情况
            EMPTY =&gt; unreachable!(),
            //有数据 
            DATA =&gt; Ok(true),

            // 发送端中断
            DISCONNECTED =&gt; unsafe {
                //收到数据
                if (*self.data.get()).is_some() {
                    Ok(true)
                } else {
                    //看是否需要升级
                    match ptr::replace(self.upgrade.get(), SendUsed) {
                        //升级调用，返回升级到的端口Reciver&lt;T&gt;
                        GoUp(port) =&gt; Err(port),
                        _ =&gt; Ok(true),
                    }
                }
            },

            // 没有其他线程发送数据
            ptr =&gt; unsafe {
                //删除信号
                drop(SignalToken::from_raw(ptr));
                //没有接收数据
                Ok(false)
            },
        }
    }
}

impl&lt;T&gt; Drop for Packet&lt;T&gt; {
    fn drop(&amp;mut self) {
        assert_eq!(self.state.load(Ordering::SeqCst), DISCONNECTED);
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="shared的通道"><a class="header" href="#shared的通道">Shared的通道</a></h3>
<p>当oneshot的tx做clone操作时，oneshot的通道升级到Shared类型通道:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//用发送包的技术来表示通道的状态
//通道中断计数标志
const DISCONNECTED: isize = isize::MIN;
//最大能支持的通道数
const FUDGE: isize = 1024;
const MAX_REFCOUNT: usize = (isize::MAX) as usize;
//最多能计数的无阻塞收包数目
const MAX_STEALS: isize = 1 &lt;&lt; 20;
const EMPTY: *mut u8 = ptr::null_mut(); // initial state: no data, no blocked receiver

pub struct Packet&lt;T&gt; {
    //消息包的queue
    queue: mpsc::Queue&lt;T&gt;,
    //发送的包总数,每次阻塞或接收包数目到达限值会设置为-1。
    // -1作为有阻塞，需要发送信号的标记
    cnt: AtomicIsize,
    //接收的包总数,每次阻塞，或接收包数目达到限值会清零
    steals: UnsafeCell&lt;isize&gt;,
    //唤醒的信号SingleToken指针

    //接收线程阻塞时期待的信号量
    to_wake: AtomicPtr&lt;u8&gt;,

    //初始最少有两个使用者,每多一个发送线程就加1
    channels: AtomicUsize,

    //接收端关闭通道的标志
    port_dropped: AtomicBool,
    //发送端发现接收端中断，确定清理线程的辅助结构
    sender_drain: AtomicIsize,

    //使用单元类型的Mutex，将Mutex仅做锁的场景，不包含临界区,通常这个锁的临界区是一段代码操作
    select_lock: Mutex&lt;()&gt;,
}

pub enum Failure {
    Empty,
    Disconnected,
}

enum StartResult {
    Installed,
    Abort,
}

impl&lt;T&gt; Packet&lt;T&gt; {
    //新建一个通道，随后必须紧跟postinit_lock及inherit_blocker后才能做其他
    //通道操作
    pub fn new() -&gt; Packet&lt;T&gt; {
        Packet {
            //包队列
            queue: mpsc::Queue::new(),
            //发送的包总数,每次阻塞或接收包数目到达限值会清零。 
            cnt: AtomicIsize::new(0),
            //接收的包总数,每次阻塞，或接收包数目达到限值会清零
            steals: UnsafeCell::new(0),
            //唤醒接收线程的信号
            to_wake: AtomicPtr::new(EMPTY),
            //初始最少有两个使用者,每多一个发送线程就加1
            channels: AtomicUsize::new(2),
            //接收端关闭通道的标志
            port_dropped: AtomicBool::new(false),
            //发送端发现接收端中断，确定清理线程的辅助结构
            sender_drain: AtomicIsize::new(0),
            //用于创建时的临界区代码保户
            select_lock: Mutex::new(()),
        }
    }

    // 必须在new之后第一时间调用，在封装self的Arc还没有clone之前
    pub fn postinit_lock(&amp;self) -&gt; MutexGuard&lt;'_, ()&gt; {
        self.select_lock.lock().unwrap()
    }

    // 这个函数处理升级前的通道遗留的阻塞线程场景,guard是调用postinit_lock的返回
    pub fn inherit_blocker(&amp;self, token: Option&lt;SignalToken&gt;, guard: MutexGuard&lt;'_, ()&gt;) {
        //判断是否有接收线程阻塞
        if let Some(token) = token {
            assert_eq!(self.cnt.load(Ordering::SeqCst), 0);
            assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);
            //将阻塞信号设置到to_wake中
            self.to_wake.store(unsafe { token.to_raw() }, Ordering::SeqCst);
            //有接收线程阻塞，导致发第一个包的时候，才会去唤醒接收线程，接收线程才可能
            //做升级，然后才能接收数据包。这个-1作为阻塞的标志
            //这个设计方式过于复杂，不是一个好的设计，
            self.cnt.store(-1, Ordering::SeqCst);

            unsafe {
                // cnt为-1，steals也需要设置为-1
                *self.steals.get() = -1;
            }
        }

        //解锁
        drop(guard);
    }

    pub fn send(&amp;self, t: T) -&gt; Result&lt;(), T&gt; {
        //看接收端口Receiver是否已经关闭
        if self.port_dropped.load(Ordering::SeqCst) {
            return Err(t);
        }

        //判断通道是否中断,因为每个线程发送都可能会造成计数加1，所以最大值
        //是DISCONNECTED+FUDGE,这个区间可认为通道已经被设置为中断
        if self.cnt.load(Ordering::SeqCst) &lt; DISCONNECTED + FUDGE {
            return Err(t);
        }

        //消息入队列
        self.queue.push(t);
        //增加队列计数,每次push队列都要先对cnt增加值来反映此操作
        //但此时此时接收端口Receiver可能生命周期终止，导致cnt被设置为DISCONNECT
        match self.cnt.fetch_add(1, Ordering::SeqCst) {
            //原值为-1，是发送的第一个包，且接收端在等待信号
            //其他线程不会得到-1, 只有-1的发送线程来发送信号
            -1 =&gt; {
                //发信号通知接收线程退出阻塞,工作结束,
                //这个机制搞的有些复杂
                self.take_to_wake().signal();
            }

            // 消息入队列后，通道被中断，此时需要把数据包撤回.
            n if n &lt; DISCONNECTED + FUDGE =&gt; {
                //重新设置cnt为中断状态
                self.cnt.store(DISCONNECTED, Ordering::SeqCst);

                //判断我们是否是第一个sender_drain
                if self.sender_drain.fetch_add(1, Ordering::SeqCst) == 0 {
                    //是，负责删除队列里面的所有消息包
                    loop {
                        //循环直到queue为空
                        loop {
                            match self.queue.pop() {
                                mpsc::Data(..) =&gt; {}
                                mpsc::Empty =&gt; break,
                                mpsc::Inconsistent =&gt; thread::yield_now(),
                            }
                        }
                        
                        if self.sender_drain.fetch_sub(1, Ordering::SeqCst) == 1 {
                            //确定所有线程都已经被处理
                            break;
                        }
                        //还有其他线程做了sender_drain的add，那再循环
                    }

                    // 本线程push到queue的包确定已经删除
                }
            }

            _ =&gt; {}
        }

        Ok(())
    }

    pub fn recv(&amp;self, deadline: Option&lt;Instant&gt;) -&gt; Result&lt;T, Failure&gt; {
        //尽量不阻塞
        match self.try_recv() {
            Err(Empty) =&gt; {}
            data =&gt; return data,
        }

        //需要阻塞
        //生成通知信号
        let (wait_token, signal_token) = blocking::tokens();
        //因为try_recv到此处可能会有其他线程发包，需要做些
        //处理看是否需要阻塞
        if self.decrement(signal_token) == Installed {
            //确定要阻塞
            if let Some(deadline) = deadline {
                //有超时要去,做一个超时等待
                let timed_out = !wait_token.wait_max_until(deadline);
                if timed_out {
                    //如果超时，需要做清理工作
                    self.abort_selection(false);
                }
            } else {
                //阻塞至包来到
                wait_token.wait();
            }
        }

        //当前已经有数据包
        match self.try_recv() {
            data @ Ok(..) =&gt; unsafe {
                //反应阻塞收包统计,try_recv会加1,这里减掉
                //有可能没有阻塞，但按照阻塞来计算
                //这里是为了对冲在阻塞时对cnt多减1
                //无论如何，利用这个来实现对阻塞与否的判断我认为不是一个好主意
                *self.steals.get() -= 1;
                data
            },
            data =&gt; data,
        }
    }

    //判断是否应该阻塞
    fn decrement(&amp;self, token: SignalToken) -&gt; StartResult {
        unsafe {
            assert_eq!(
                self.to_wake.load(Ordering::SeqCst),
                EMPTY,
                &quot;This is a known bug in the Rust standard library. See https://github.com/rust-lang/rust/issues/39364&quot;
            );
            // 设置收线程阻塞信号到通道
            let ptr = token.to_raw();
            self.to_wake.store(ptr, Ordering::SeqCst);

            //进入阻塞时对steals做清零
            let steals = ptr::replace(self.steals.get(), 0);

            //cnt需要把上次阻塞到本次阻塞之间的收包数目减掉，然后再减1,以便cnt成为-1
            match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {
                //如果减法之前发送侧已经中断
                DISCONNECTED =&gt; {
                    //将cnt恢复为中断
                    self.cnt.store(DISCONNECTED, Ordering::SeqCst);
                }
                
                //不是中断，原来至少应该发送过一个包，cnt应该不小于0
                n =&gt; {
                    assert!(n &gt;= 0);
                    //在两次取值间可能有其他通道已经发包过来，那不应该阻塞
                    //如果没有其他包，则阻塞
                    //发送的包减掉接收的包不大于0，表示没有线程竞争发包
                    if n - steals &lt;= 0 {
                        //正常阻塞
                        return Installed;
                    }
                }
            }

            //此时队列已经有包或者DISCONNECT了，不需要阻塞
            //撤掉信号
            self.to_wake.store(EMPTY, Ordering::SeqCst);
            drop(SignalToken::from_raw(ptr));
            Abort
        }
    }

    //接收数据包
    pub fn try_recv(&amp;self) -&gt; Result&lt;T, Failure&gt; {
        //从队列取得一个包
        let ret = match self.queue.pop() {
            //成功
            mpsc::Data(t) =&gt; Some(t),
            //不成功
            mpsc::Empty =&gt; None,

            // 此时处于一个临界状态.可以做个自旋等待一下
            mpsc::Inconsistent =&gt; {
                let data;
                //默认为肯定会获得数据
                loop {
                    //这里等待一个操作系统调度周期
                    //试图让发送线程工作
                    //但等待时间不定
                    thread::yield_now();
                    match self.queue.pop() {
                        //收到数据
                        mpsc::Data(t) =&gt; {
                            data = t;
                            break;
                        }
                        //不应有这种情况
                        mpsc::Empty =&gt; panic!(&quot;inconsistent =&gt; empty&quot;),
                        //继续等待
                        mpsc::Inconsistent =&gt; {}
                    }
                }
                Some(data)
            }
        };
        match ret {
            //接收到数据
            Some(data) =&gt; unsafe {
                //如果非阻塞收包已经大于MAX_STEALS
                if *self.steals.get() &gt; MAX_STEALS {
                    //将cnt清零
                    match self.cnt.swap(0, Ordering::SeqCst) {
                        //原cnt是DISCONNECTED
                        DISCONNECTED =&gt; {
                            //重新置为DISCONNECTED
                            self.cnt.store(DISCONNECTED, Ordering::SeqCst);
                        }
                        n =&gt; {
                            //这里在cnt及steals上共同减去两者之间小者
                            //取值小者
                            let m = cmp::min(n, *self.steals.get());
                            //steals及cnt都减去最小值
                            *self.steals.get() -= m;
                            //实际上是原cnt减去m
                            self.bump(n - m);
                        }
                    }
                    assert!(*self.steals.get() &gt;= 0);
                }
                //steals增加
                *self.steals.get() += 1;
                Ok(data)
            },

            //没有收到数据
            None =&gt; {
                match self.cnt.load(Ordering::SeqCst) {
                    //如果通道没有中断，返回异常的队列空
                    n if n != DISCONNECTED =&gt; Err(Empty),
                    //其他 只可能是DISCONNECTED
                    _ =&gt; {
                        //再接收一次
                        match self.queue.pop() {
                            //没有对self.steals做操作
                            mpsc::Data(t) =&gt; Ok(t),
                            //空，认为已经中断
                            mpsc::Empty =&gt; Err(Disconnected),
                            // 不应有这种情况
                            mpsc::Inconsistent =&gt; unreachable!(),
                        }
                        //丢弃这个包，所以不必更新计数
                    }
                }
            }
        }
    }

    // Sender&lt;T&gt;做clone时的支撑函数 
    pub fn clone_chan(&amp;self) {
        //channel数目增加
        let old_count = self.channels.fetch_add(1, Ordering::SeqCst);

        if old_count &gt; MAX_REFCOUNT {
            abort();
        }
    }

    // 发送线程关闭通道
    pub fn drop_chan(&amp;self) {
        //减少channel计数
        match self.channels.fetch_sub(1, Ordering::SeqCst) {
            //需要做清理
            1 =&gt; {}
            //还有其他发送线程，不必处理
            n if n &gt; 1 =&gt; return,
            //不应该发生这种情况
            n =&gt; panic!(&quot;bad number of channels left {n}&quot;),
        }

        //所有发送线程均已关闭，发端置中断状态
        match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {
            // 有接收线程阻塞
            -1 =&gt; {
                //发信号解除阻塞
                self.take_to_wake().signal();
            }
            DISCONNECTED =&gt; {}
            n =&gt; {
                assert!(n &gt;= 0);
            }
        }
    }

    //接收线程关闭通道
    pub fn drop_port(&amp;self) {
        //置标志
        self.port_dropped.store(true, Ordering::SeqCst);
        //获取上次阻塞以来接收的数据包
        let mut steals = unsafe { *self.steals.get() };
        while {
            //这个block是while的条件语句
            //当发送数据包与接收数据包相同时，设置中断
            match self.cnt.compare_exchange(
                steals,
                DISCONNECTED,
                Ordering::SeqCst,
                Ordering::SeqCst,
            ) {
                //成功,退出循环
                Ok(_) =&gt; false,
                //old是DISCONNECT时，退出循环，否则进入循环
                Err(old) =&gt; old != DISCONNECTED,
            }
        } {
            //这个循环把队列清空
            loop {
                //收包
                match self.queue.pop() {
                    mpsc::Data(..) =&gt; {
                        steals += 1;
                    }
                    mpsc::Empty | mpsc::Inconsistent =&gt; break,
                }
                //生命周期终结，释放包
            }
        }
    }

    // 重组阻塞信号结构 
    fn take_to_wake(&amp;self) -&gt; SignalToken {
        let ptr = self.to_wake.load(Ordering::SeqCst);
        self.to_wake.store(EMPTY, Ordering::SeqCst);
        assert!(ptr != EMPTY);
        unsafe { SignalToken::from_raw(ptr) }
    }

    //一次性给cnt增加若干值
    fn bump(&amp;self, amt: isize) -&gt; isize {
        //一次增加cnt输入参数
        match self.cnt.fetch_add(amt, Ordering::SeqCst) {
            //如果原值是DISCONNECT
            DISCONNECTED =&gt; {
                //cnt恢复为DISCONNECT
                self.cnt.store(DISCONNECTED, Ordering::SeqCst);
                DISCONNECTED
            }
            n =&gt; n,
        }
    }

    //接收线程阻塞超时时做处理
    pub fn abort_selection(&amp;self, _was_upgrade: bool) -&gt; bool {
        //加锁，保护下面的临界区代码
        {
            let _guard = self.select_lock.lock().unwrap();
        }

        let steals = {
            //这个程序员愿意用block作为表达式结果
            //获取cnt
            let cnt = self.cnt.load(Ordering::SeqCst);
            //发送端没有中断，cnt应该是阻塞超时的次数
            //只能是-1或者0
            if cnt &lt; 0 &amp;&amp; cnt != DISCONNECTED { -cnt } else { 0 }
        };
        //cnt增加，清除超时,每次超时如果有包，则steals加1
        let prev = self.bump(steals + 1);

        //发送端已经中断
        if prev == DISCONNECTED {
            //更新等待信号为空, 
            assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);
            //后继退出收包
            true
        } else {
            //当前的发包计数
            let cur = prev + steals + 1;
            assert!(cur &gt;= 0);
            if prev &lt; 0 {
                //没有发包导致，drop掉接收等待信号
                drop(self.take_to_wake());
            } else {
                //发送端马上应该发送信号，等一下
                while self.to_wake.load(Ordering::SeqCst) != EMPTY {
                    thread::yield_now();
                }
            }
            unsafe {
                let old = self.steals.get();
                //steals只可能是0或1
                assert!(*old == 0 || *old == -1);
                //更新self.steals,实际上是steals加1
                *old = steals;
                prev &gt;= 0
            }
        }
    }
}

impl&lt;T&gt; Drop for Packet&lt;T&gt; {
    fn drop(&amp;mut self) {
        //确保Packet已经清理完毕
        assert_eq!(self.cnt.load(Ordering::SeqCst), DISCONNECTED);
        assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);
        assert_eq!(self.channels.load(Ordering::SeqCst), 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>shared 类型的通道设计最奇怪的地方是用了复杂的发包计数来作为阻塞标记。导致该处代码不易理解。</p>
<h3 id="mpsc的对外函数及接口"><a class="header" href="#mpsc的对外函数及接口">mpsc的对外函数及接口</a></h3>
<p>通道相关的类型结构及函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn channel&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {
    //初始时创建oneshot的通道
    let a = Arc::new(oneshot::Packet::new());
    //对onshot通道做clone，然后创建Sender及Receiver
    (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))
}

//发送端端口
pub struct Sender&lt;T&gt; {
    inner: UnsafeCell&lt;Flavor&lt;T&gt;&gt;,
}

//接收端端口
pub struct Receiver&lt;T&gt; {
    inner: UnsafeCell&lt;Flavor&lt;T&gt;&gt;,
}

//用来实现可升级的通道，因为有带参数的成员，RUST没有使用dyn trait这种设计
//对于认为以后通道类型不会再扩张时，采用enum的设计方式更易控制
//但如果预计后继还会有很多通道方式，则应该采用dyn Packet&lt;T&gt;的设计方式
enum Flavor&lt;T&gt; {
    //只发送单一通信包的通道
    Oneshot(Arc&lt;oneshot::Packet&lt;T&gt;&gt;),
    //一对一的多通信包的通道,当发端发送第二个包的时候
    //要创建并切换到这个通道
    Stream(Arc&lt;stream::Packet&lt;T&gt;&gt;),
    //多对一的通道，当发端做clone操作的时候
    //要创建并切换到这个通道
    Shared(Arc&lt;shared::Packet&lt;T&gt;&gt;),
    //同步通道，本书不分析
    Sync(Arc&lt;sync::Packet&lt;T&gt;&gt;),
}

//Sender及Receiver内部访问支持trait
trait UnsafeFlavor&lt;T&gt; {
    fn inner_unsafe(&amp;self) -&gt; &amp;UnsafeCell&lt;Flavor&lt;T&gt;&gt;;
    unsafe fn inner_mut(&amp;self) -&gt; &amp;mut Flavor&lt;T&gt; {
        &amp;mut *self.inner_unsafe().get()
    }
    unsafe fn inner(&amp;self) -&gt; &amp;Flavor&lt;T&gt; {
        &amp;*self.inner_unsafe().get()
    }
}
impl&lt;T&gt; UnsafeFlavor&lt;T&gt; for Sender&lt;T&gt; {
    fn inner_unsafe(&amp;self) -&gt; &amp;UnsafeCell&lt;Flavor&lt;T&gt;&gt; {
        &amp;self.inner
    }
}
impl&lt;T&gt; UnsafeFlavor&lt;T&gt; for Receiver&lt;T&gt; {
    fn inner_unsafe(&amp;self) -&gt; &amp;UnsafeCell&lt;Flavor&lt;T&gt;&gt; {
        &amp;self.inner
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Sender的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Sender&lt;T&gt; {
    //创建包含通道的Sender
    fn new(inner: Flavor&lt;T&gt;) -&gt; Sender&lt;T&gt; {
        Sender { inner: UnsafeCell::new(inner) }
    }

    //发送一个数据包
    pub fn send(&amp;self, t: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {
        //相当于新创建了一个Flavor的变量, 此时要注意drop是否发生了两次
        //这里对解引用的match因为没有引发赋值，不会导致所有权转移
        let (new_inner, ret) = match *unsafe { self.inner() } {
            //必须是ref，否则会导致所有权转移
            Flavor::Oneshot(ref p) =&gt; {
                //判断是否还能发送包，此时只能发一个包
                if !p.sent() {
                    return p.send(t).map_err(SendError);
                } else {
                    //多于一个包，创建stream的通道来进行升级
                    let a = Arc::new(stream::Packet::new());
                    //基于新的通道创建新的Receiver
                    let rx = Receiver::new(Flavor::Stream(a.clone()));
                    //通知rx端进行升级操作
                    match p.upgrade(rx) {
                        //升级成功
                        oneshot::UpSuccess =&gt; {
                            //发送报文
                            let ret = a.send(t);
                            //将新的通道赋值
                            (a, ret)
                        }
                        //接收已经DISCONNECT，将数据包及新通道共同返回
                        oneshot::UpDisconnected =&gt; (a, Err(t)),
                        //接收线程阻塞,需要做唤醒
                        oneshot::UpWoke(token) =&gt; {
                            //先将包发送
                            a.send(t).ok().unwrap();
                            //唤醒接收线程
                            token.signal();
                            //返回新通道
                            (a, Ok(()))
                        }
                    }
                }
            }
            //已经是Stream，正常发送包的逻辑，直接返回，不修改self
            Flavor::Stream(ref p) =&gt; return p.send(t).map_err(SendError),
            //已经是Shared，正常的发送逻辑，直接返回，不修改self
            Flavor::Shared(ref p) =&gt; return p.send(t).map_err(SendError),
            //不可能到达这个代码位置
            Flavor::Sync(..) =&gt; unreachable!(),
        };

        unsafe {
            //只有oneshot会进入此处
            //新建Sender，并将新的Sender及老的Sender进行内存替换
            //此处要注意，enum的不同成员不保证内存相同，但这里是没有问题的
            let tmp = Sender::new(Flavor::Stream(new_inner));
            mem::swap(self.inner_mut(), tmp.inner_mut());
            //此处,tmp会生命周期终结，tmp当前是oneshot的类型。
            //要注意收端是怎么终结的
        }
        ret.map_err(SendError)
    }
}

impl&lt;T&gt; Clone for Sender&lt;T&gt; {
    /// clone代表进入了多发一收的模式，需要升级到shared类型的通道 
    fn clone(&amp;self) -&gt; Sender&lt;T&gt; {
        let packet = match *unsafe { self.inner() } {
            Flavor::Oneshot(ref p) =&gt; {
                //创建shared类型通道
                let a = Arc::new(shared::Packet::new());
                {
                    //创建后首先lock
                    let guard = a.postinit_lock();
                    //创建Receiver
                    let rx = Receiver::new(Flavor::Shared(a.clone()));
                    //进行升级
                    let sleeper = match p.upgrade(rx) {
                        oneshot::UpSuccess | oneshot::UpDisconnected =&gt; None,
                        oneshot::UpWoke(task) =&gt; Some(task),
                    };
                    //完成通道设置
                    a.inherit_blocker(sleeper, guard);
                }
                //置值
                a
            }
            //进入一对一的多包发送
            Flavor::Stream(ref p) =&gt; {
                //仍然创建shared类型通道
                let a = Arc::new(shared::Packet::new());
                {
                    //首先lock
                    let guard = a.postinit_lock();
                    //创建Receiver
                    let rx = Receiver::new(Flavor::Shared(a.clone()));
                    //升级
                    let sleeper = match p.upgrade(rx) {
                        stream::UpSuccess | stream::UpDisconnected =&gt; None,
                        stream::UpWoke(task) =&gt; Some(task),
                    };
                    //完成通道设置
                    a.inherit_blocker(sleeper, guard);
                }
                //置值
                a
            }
            Flavor::Shared(ref p) =&gt; {
                //先做clone_chan
                p.clone_chan();
                //创建新的Sender,并返回
                return Sender::new(Flavor::Shared(p.clone()));
            }
            //不会到达这个地方
            Flavor::Sync(..) =&gt; unreachable!(),
        };

        unsafe {
            //创建新的Sender
            let tmp = Sender::new(Flavor::Shared(packet.clone()));
            //替换现有的Sender
            mem::swap(self.inner_mut(), tmp.inner_mut());
            //原有的Flavor生命周期终止并被drop
        }
        //创建新的Sender,并返回
        Sender::new(Flavor::Shared(packet))
    }
}

impl&lt;T&gt; Drop for Sender&lt;T&gt; {
    fn drop(&amp;mut self) {
        //行为一致，都是中断通道
        match *unsafe { self.inner() } {
            Flavor::Oneshot(ref p) =&gt; p.drop_chan(),
            Flavor::Stream(ref p) =&gt; p.drop_chan(),
            Flavor::Shared(ref p) =&gt; p.drop_chan(),
            Flavor::Sync(..) =&gt; unreachable!(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Receiver的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Receiver&lt;T&gt; {
    fn new(inner: Flavor&lt;T&gt;) -&gt; Receiver&lt;T&gt; {
        Receiver { inner: UnsafeCell::new(inner) }
    }

    //不阻塞的收包
    pub fn try_recv(&amp;self) -&gt; Result&lt;T, TryRecvError&gt; {
        loop {
            let new_port = match *unsafe { self.inner() } {
                Flavor::Oneshot(ref p) =&gt; match p.try_recv() {
                    //非升级的情况都直接返回
                    Ok(t) =&gt; return Ok(t),
                    Err(oneshot::Empty) =&gt; return Err(TryRecvError::Empty),
                    Err(oneshot::Disconnected) =&gt; return Err(TryRecvError::Disconnected),
                    //升级的情况将rx置值到new_port
                    Err(oneshot::Upgraded(rx)) =&gt; rx,
                },
                Flavor::Stream(ref p) =&gt; match p.try_recv() {
                    //非升级的情况都直接返回
                    Ok(t) =&gt; return Ok(t),
                    Err(stream::Empty) =&gt; return Err(TryRecvError::Empty),
                    Err(stream::Disconnected) =&gt; return Err(TryRecvError::Disconnected),
                    //升级的情况将rx置值到new_port
                    Err(stream::Upgraded(rx)) =&gt; rx,
                },
                Flavor::Shared(ref p) =&gt; match p.try_recv() {
                    Ok(t) =&gt; return Ok(t),
                    Err(shared::Empty) =&gt; return Err(TryRecvError::Empty),
                    Err(shared::Disconnected) =&gt; return Err(TryRecvError::Disconnected),
                    //不应该出现升级的情况
                },
                Flavor::Sync(ref p) =&gt; match p.try_recv() {
                    Ok(t) =&gt; return Ok(t),
                    Err(sync::Empty) =&gt; return Err(TryRecvError::Empty),
                    Err(sync::Disconnected) =&gt; return Err(TryRecvError::Disconnected),
                },
            };
            unsafe {
                //直接用new_port替换原来的Flavor
                mem::swap(self.inner_mut(), new_port.inner_mut());
            }
            //new_port生命周期终结，原有的Flavor被调用drop
        }
    }

    //阻塞收包，替换逻辑与try_recv相同
    pub fn recv(&amp;self) -&gt; Result&lt;T, RecvError&gt; {
        loop {
            let new_port = match *unsafe { self.inner() } {
                Flavor::Oneshot(ref p) =&gt; match p.recv(None) {
                    Ok(t) =&gt; return Ok(t),
                    Err(oneshot::Disconnected) =&gt; return Err(RecvError),
                    Err(oneshot::Upgraded(rx)) =&gt; rx,
                    Err(oneshot::Empty) =&gt; unreachable!(),
                },
                Flavor::Stream(ref p) =&gt; match p.recv(None) {
                    Ok(t) =&gt; return Ok(t),
                    Err(stream::Disconnected) =&gt; return Err(RecvError),
                    Err(stream::Upgraded(rx)) =&gt; rx,
                    Err(stream::Empty) =&gt; unreachable!(),
                },
                Flavor::Shared(ref p) =&gt; match p.recv(None) {
                    Ok(t) =&gt; return Ok(t),
                    Err(shared::Disconnected) =&gt; return Err(RecvError),
                    Err(shared::Empty) =&gt; unreachable!(),
                },
                Flavor::Sync(ref p) =&gt; return p.recv(None).map_err(|_| RecvError),
            };
            unsafe {
                mem::swap(self.inner_mut(), new_port.inner_mut());
            }
        }
    }

    //设置超时的阻塞收包
    pub fn recv_timeout(&amp;self, timeout: Duration) -&gt; Result&lt;T, RecvTimeoutError&gt; {
        // Do an optimistic try_recv to avoid the performance impact of
        // Instant::now() in the full-channel case.
        match self.try_recv() {
            Ok(result) =&gt; Ok(result),
            Err(TryRecvError::Disconnected) =&gt; Err(RecvTimeoutError::Disconnected),
            //没有包的时候才进入超时
            Err(TryRecvError::Empty) =&gt; match Instant::now().checked_add(timeout) {
                //调用超时接收
                Some(deadline) =&gt; self.recv_deadline(deadline),
                None =&gt; self.recv().map_err(RecvTimeoutError::from),
            },
        }
    }

    //真正的超时接收,与recv基本相同，仅增加了超时参数
    pub fn recv_deadline(&amp;self, deadline: Instant) -&gt; Result&lt;T, RecvTimeoutError&gt; {
        use self::RecvTimeoutError::*;

        loop {
            let port_or_empty = match *unsafe { self.inner() } {
                Flavor::Oneshot(ref p) =&gt; match p.recv(Some(deadline)) {
                    Ok(t) =&gt; return Ok(t),
                    Err(oneshot::Disconnected) =&gt; return Err(Disconnected),
                    Err(oneshot::Upgraded(rx)) =&gt; Some(rx),
                    Err(oneshot::Empty) =&gt; None,
                },
                Flavor::Stream(ref p) =&gt; match p.recv(Some(deadline)) {
                    Ok(t) =&gt; return Ok(t),
                    Err(stream::Disconnected) =&gt; return Err(Disconnected),
                    Err(stream::Upgraded(rx)) =&gt; Some(rx),
                    Err(stream::Empty) =&gt; None,
                },
                Flavor::Shared(ref p) =&gt; match p.recv(Some(deadline)) {
                    Ok(t) =&gt; return Ok(t),
                    Err(shared::Disconnected) =&gt; return Err(Disconnected),
                    Err(shared::Empty) =&gt; None,
                },
                Flavor::Sync(ref p) =&gt; match p.recv(Some(deadline)) {
                    Ok(t) =&gt; return Ok(t),
                    Err(sync::Disconnected) =&gt; return Err(Disconnected),
                    Err(sync::Empty) =&gt; None,
                },
            };

            if let Some(new_port) = port_or_empty {
                unsafe {
                    mem::swap(self.inner_mut(), new_port.inner_mut());
                }
            }

            // If we're already passed the deadline, and we're here without
            // data, return a timeout, else try again.
            if Instant::now() &gt;= deadline {
                return Err(Timeout);
            }
        }
    }

    //函数式编程，用iterator来简化rx的动作
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { rx: self }
    }

    //不会阻塞的iterator
    pub fn try_iter(&amp;self) -&gt; TryIter&lt;'_, T&gt; {
        TryIter { rx: self }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>针对Receiver的迭代器举例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//只是为了函数式编程及利用Iterator的基础设施
pub struct Iter&lt;'a, T: 'a&gt; {
    rx: &amp;'a Receiver&lt;T&gt;,
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.rx.recv().ok()
    }
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust的runtime"><a class="header" href="#rust的runtime">RUST的RUNTIME</a></h1>
<p>RUST的runtime及程序的主线程初始化<br />
路径：library/std/src/rt.rs：<br />
library/std/src/unix/mod.rs<br />
library/std/src/panic.rs<br />
library/std/src/panicking.rs<br />
library/std/src/panic/*.rs<br />
RUST程序execv以后，最初是由std::rt::lang_start进入RUST的RUNTIME    :
代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//RUST应用的代码入口点
fn lang_start&lt;T: crate::process::Termination + 'static&gt;(
    main: fn() -&gt; T,
    argc: isize,
    argv: *const *const u8,
) -&gt; isize {
    //调用了lang_start_internal
    let Ok(v) = lang_start_internal(
        //__rust_begin_short_backtrace(main)标识栈顶,同时也调用了main
        &amp;move || crate::sys_common::backtrace::__rust_begin_short_backtrace(main).report().to_i32(),
        argc,
        argv,
    );
    v
}

fn lang_start_internal(
    main: &amp;(dyn Fn() -&gt; i32 + Sync + crate::panic::RefUnwindSafe),
    argc: isize,
    argv: *const *const u8,
) -&gt; Result&lt;isize, !&gt; {
    use crate::{mem, panic};
    let rt_abort = move |e| {
        mem::forget(e);
        rtabort!(&quot;initialization or cleanup bug&quot;);
    };
    //完成执行main之前的准备,具体见后面的init函数，用catch_unwind捕获init函数执行中的panic信息
    panic::catch_unwind(move || unsafe { init(argc, argv) }).map_err(rt_abort)?;
    //执行main函数，同样，用catch_unwind捕获所有可能的panic信息
    let ret_code = panic::catch_unwind(move || panic::catch_unwind(main).unwrap_or(101) as isize)
        .map_err(move |e| {
            mem::forget(e);
            rtabort!(&quot;drop of the panic payload panicked&quot;);
        });
    //完成所有的清理工作,一样的catch_unwind
    panic::catch_unwind(cleanup).map_err(rt_abort)?;
    ret_code
}
<span class="boring">}</span></code></pre></pre>
<p>进入main函数之前的初始化内容</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//此函数在main函数之前被调用完成标准输入/输出/错误，线程栈保护等设置，
//然后控制权交给main
unsafe fn init(argc: isize, argv: *const *const u8) {
    unsafe {
        //见下面的代码分析，完成进入main的各项初始化
        sys::init(argc, argv);

        //以下是对主线程的线程runtime的初始化,可对比线程的spawn函数
        //设置主线程的栈保护
        let main_guard = sys::thread::guard::init();
        //设置当前的线程为主线程
        let thread = Thread::new(Some(rtunwrap!(Ok, CString::new(&quot;main&quot;))));
        //设置栈保护地址与线程的信息, 使用了thread_local_key的方式使得此info仅与当前线程相关
        thread_info::set(main_guard, thread);
    }
}

//linux系统的上文sys::init实现
pub unsafe fn init(argc: isize, argv: *const *const u8) {
    // 见下文说明.
    sanitize_standard_fds();

    // 将 SIGPIPE 设置为ignore
    reset_sigpipe();

    //进程栈溢出初始化,系统调用sigaltstack()支持设置一个内存空间，当访问这个空间地址的时候
    //发送一个信号给进程，stack_overflow即利用这个机制完成了对当前线程的该信号的设置及处理
    //这个对所有线程的堆栈溢出的处理做了初始化
    stack_overflow::init();
    //对命令行的输入完成RUST的结构转化
    args::init(argc, argv);

    unsafe fn sanitize_standard_fds() {
        //仅linux
        {
            {
                use crate::sys::os::errno;
                //轮询stdin,stdout,stderr的文件描述符
                let pfds: &amp;mut [_] = &amp;mut [
                    libc::pollfd { fd: 0, events: 0, revents: 0 },
                    libc::pollfd { fd: 1, events: 0, revents: 0 },
                    libc::pollfd { fd: 2, events: 0, revents: 0 },
                ];
                //从poll结果获得文件描述符是否已经关闭
                while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {
                    if errno() == libc::EINTR {
                        continue;
                    }
                    //此处说明未知错误需要退出
                    libc::abort();
                }
                for pfd in pfds {
                    if pfd.revents &amp; libc::POLLNVAL == 0 {
                        //文件描述符已经打开
                        continue;
                    }
                    //文件描述符关闭, 则用/dev/null作为文件描述符，注意下面直接用str转换为CStr的
                    //代码,因为此循环的fd最小，所以下面这个open如果调用成功，返回的fd即为当前的///被关闭的fd.从而达到了重新将标准输入/输出/错误文件描述符打开的目的
                    if libc::open(&quot;/dev/null\0&quot;.as_ptr().cast(), libc::O_RDWR, 0) == -1 {
                        // 无法打开文件，则应退出程序
                        libc::abort();
                    }
                }
            } 
        }
    }

    //设置对SIGPIPE的处理为IGNORE
    unsafe fn reset_sigpipe() {
        rtassert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对panic的捕获函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//对f的panic做unwind操作并捕获
pub fn catch_unwind&lt;F: FnOnce() -&gt; R + UnwindSafe, R&gt;(f: F) -&gt; Result&lt;R&gt; {
    //编译器的try catch机制
    unsafe { panicking::r#try(f) }
}

//常用于前面已经调用过catch_unwind，但需要继续panic过程
pub fn resume_unwind(payload: Box&lt;dyn Any + Send&gt;) -&gt; ! {
    panicking::rust_panic_without_hook(payload)
}
<span class="boring">}</span></code></pre></pre>
<p>RUST的RUNTIME主要是完成一些安全机制及异常处理机制。了解RUNTIME可以使得我们对如何构建一个强健的，易于排查错误的应用有更深的了解。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准库文件系统模块分析"><a class="header" href="#标准库文件系统模块分析">标准库文件系统模块分析</a></h1>
<p>文件模块将集中在操作系统中除文件读写之外的操作：包括创建，删除，属性查看及修改，目录操作等
文件读写的部分将统一放在后继的IO部分去分析</p>
<h2 id="linux的操作系统的文件系统实现"><a class="header" href="#linux的操作系统的文件系统实现">linux的操作系统的文件系统实现</a></h2>
<p>以下是rust在linux适配层提供的文件操作API, 基本上与C语言的标准库实现了一一对应：</p>
<p>目录相关的类型结构及方法，函数</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//创建目录类型，准备读
pub fn readdir(p: &amp;Path) -&gt; io::Result&lt;ReadDir&gt; {
    let root = p.to_path_buf();
    let p = cstr(p)?;
    unsafe {
        //调用libc函数获得libc::DIR的指针
        let ptr = libc::opendir(p.as_ptr());
        if ptr.is_null() {
            Err(Error::last_os_error())
        } else {
            //对C函数的返回值完成RUST的初步封装
            let inner = InnerReadDir { dirp: Dir(ptr), root };
            //创建多线程安全的RUST目录读类型结构ReadDir
            Ok(ReadDir {
                inner: Arc::new(inner),
            })
        }
    }
}

//类似OwnedFd, 拥有了C语言返回的目录的所有权
struct Dir(*mut libc::DIR);
//将目录类型与路径字符串相联系
struct InnerReadDir {
    //C函数返回的目录句柄
    dirp: Dir,
    //目录路径字符串
    root: PathBuf,
}

//对目录结构的多线程封装结构,用于读目录
pub struct ReadDir {
    inner: Arc&lt;InnerReadDir&gt;,
}

//目录下的每个条目的类型结构
pub struct DirEntry {
    dir: Arc&lt;InnerReadDir&gt;,
    entry: dirent64_min,
    // We need to store an owned copy of the entry name on platforms that use
    // readdir() (not readdir_r()), because a) struct dirent may use a flexible
    // array to store the name, b) it lives only until the next readdir() call.
    name: CString,
}

// 针对linux的dirent的部分的存储
struct dirent64_min {
    d_ino: u64,
    d_type: u8,
}

//针对目录读实现Iterator以简化操作
impl Iterator for ReadDir {
    type Item = io::Result&lt;DirEntry&gt;;

    //将复杂的C语言操作用next自然的呈现
    fn next(&amp;mut self) -&gt; Option&lt;io::Result&lt;DirEntry&gt;&gt; {
        unsafe {
            loop {
                //linux已经保证了readdir的线程安全性
                //readdir64会读取下一个
                super::os::set_errno(0);
                let entry_ptr = readdir64(self.inner.dirp.0);
                if entry_ptr.is_null() {
                    //系统调用出错处理
                    return match super::os::errno() {
                        0 =&gt; None,
                        e =&gt; Some(Err(Error::from_raw_os_error(e))),
                    };
                }

                // 以下从C调用返回的结构创建DirEntry结构.
                // 具体细节请参考相关的C语言dirent64的手册
                // 因为不能直接对entry_ptr做解引用，所以用一个
                // 局部变量将需要的内容拷贝出来
                let mut copy: dirent64 = mem::zeroed();
                
                let copy_bytes = &amp;mut copy as *mut _ as *mut u8;
                let copy_name = &amp;mut copy.d_name as *mut _ as *mut u8;
                let name_offset = copy_name.offset_from(copy_bytes) as usize;
                let entry_bytes = entry_ptr as *const u8;
                let entry_name = entry_bytes.add(name_offset);
                ptr::copy_nonoverlapping(entry_bytes, copy_bytes, name_offset);

                //获取需要的值
                let entry = dirent64_min {
                    d_ino: copy.d_ino as u64,
                    d_type: copy.d_type as u8,
                };

                let ret = DirEntry {
                    entry,
                    name: CStr::from_ptr(entry_name as *const _).to_owned(),
                    dir: Arc::clone(&amp;self.inner),
                };
                //去掉目录中的 ./及../
                if ret.name_bytes() != b&quot;.&quot; &amp;&amp; ret.name_bytes() != b&quot;..&quot; {
                    return Some(Ok(ret));
                }
            }
        }
    }

}

//实现对目录的关闭，进行资源释放
impl Drop for Dir {
    fn drop(&amp;mut self) {
        let r = unsafe { libc::closedir(self.0) };
        debug_assert_eq!(r, 0);
    }
}

//针对目录下每个条目的操作
impl DirEntry {
    //用目录名及entry的名字连接形成新的path字符串
    pub fn path(&amp;self) -&gt; PathBuf {
        self.dir.root.join(self.file_name_os_str())
    }

    //获取Entry的名称字符串
    pub fn file_name(&amp;self) -&gt; OsString {
        self.file_name_os_str().to_os_string()
    }

    //利用文件属性操作获取Entry的属性数据
    pub fn metadata(&amp;self) -&gt; io::Result&lt;FileAttr&gt; {
        let fd = cvt(unsafe { dirfd(self.dir.dirp.0) })?;
        let name = self.name_cstr().as_ptr();

            //见try_statx解析
            if let Some(ret) = unsafe { try_statx(
                fd,
                name,
                libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,
                libc::STATX_ALL,
            ) } {
                return ret;
            }

        let mut stat: stat64 = unsafe { mem::zeroed() };
        cvt(unsafe { fstatat64(fd, name, &amp;mut stat, libc::AT_SYMLINK_NOFOLLOW) })?;
        Ok(FileAttr::from_stat64(stat))
    }

    //entry的文件类型
    pub fn file_type(&amp;self) -&gt; io::Result&lt;FileType&gt; {
        match self.entry.d_type {
            //以下是设备文件
            libc::DT_CHR =&gt; Ok(FileType { mode: libc::S_IFCHR }),
            libc::DT_FIFO =&gt; Ok(FileType { mode: libc::S_IFIFO }),
            libc::DT_LNK =&gt; Ok(FileType { mode: libc::S_IFLNK }),
            libc::DT_REG =&gt; Ok(FileType { mode: libc::S_IFREG }),
            libc::DT_SOCK =&gt; Ok(FileType { mode: libc::S_IFSOCK }),
            libc::DT_DIR =&gt; Ok(FileType { mode: libc::S_IFDIR }),
            libc::DT_BLK =&gt; Ok(FileType { mode: libc::S_IFBLK }),
            //DirEntry的文件类型
            _ =&gt; self.metadata().map(|m| m.file_type()),
        }
    }

    //以下为entry结构内部成员获取

    pub fn ino(&amp;self) -&gt; u64 {
        self.entry.d_ino as u64
    }

    fn name_bytes(&amp;self) -&gt; &amp;[u8] {
        self.name_cstr().to_bytes()
    }

    fn name_cstr(&amp;self) -&gt; &amp;CStr {
        &amp;self.name
    }

    pub fn file_name_os_str(&amp;self) -&gt; &amp;OsStr {
        OsStr::from_bytes(self.name_bytes())
    }
}
//没有实现对DirEntry的Drop trait

//删除目录下所有项目的实现
pub use remove_dir_impl::remove_dir_all;

mod remove_dir_impl {
    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};
    use crate::ffi::CStr;
    use crate::io;
    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};
    use crate::os::unix::prelude::{OwnedFd, RawFd};
    use crate::path::{Path, PathBuf};
    use crate::sync::Arc;
    use crate::sys::{cvt, cvt_r};

    use libc::{fdopendir, openat, unlinkat};

    //将目录按照文件打开
    pub fn openat_nofollow_dironly(parent_fd: Option&lt;RawFd&gt;, p: &amp;CStr) -&gt; io::Result&lt;OwnedFd&gt; {
        let fd = cvt_r(|| unsafe {
            openat(
                parent_fd.unwrap_or(libc::AT_FDCWD),
                p.as_ptr(),
                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,
            )
        })?;
        //返回一个文件描述符
        Ok(unsafe { OwnedFd::from_raw_fd(fd) })
    }

    //用已有的目录的文件描述符打开目录
    fn fdreaddir(dir_fd: OwnedFd) -&gt; io::Result&lt;(ReadDir, RawFd)&gt; {
        //映射到C语言调用
        let ptr = unsafe { fdopendir(dir_fd.as_raw_fd()) };
        if ptr.is_null() {
            return Err(io::Error::last_os_error());
        }

        //以下形成RUST的目录类型结构

        let dirp = Dir(ptr);
        // 这里容易出错，因为Dir会关闭fd，所以此次OwnedFd不应再存在
        // 否则其生命周期终结会导致也调用fd的关闭操作。
        // 这里是RUST底层编程因为其所有权额外增加程序负担的情况 
        let new_parent_fd = dir_fd.into_raw_fd();
        // 无法获取完整路径，此函数不能用于需要获取完整路径的操作
        let dummy_root = PathBuf::new();
        Ok((
            ReadDir {
                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),
            },
            new_parent_fd,
        ))
    }

    //判断目录下的条目是否为目录
    fn is_dir(ent: &amp;DirEntry) -&gt; Option&lt;bool&gt; {
        match ent.entry.d_type {
            libc::DT_UNKNOWN =&gt; None,
            libc::DT_DIR =&gt; Some(true),
            _ =&gt; Some(false),
        }
    }

    //递归的删除目录下所有条目
    fn remove_dir_all_recursive(parent_fd: Option&lt;RawFd&gt;, path: &amp;CStr) -&gt; io::Result&lt;()&gt; {
        // 用文件描述符打开目录
        let fd = match openat_nofollow_dironly(parent_fd, &amp;path) {
            Err(err) if err.raw_os_error() == Some(libc::ENOTDIR) =&gt; {
                return match parent_fd {
                    // 删除文件 unlink...
                    Some(parent_fd) =&gt; {
                        cvt(unsafe { unlinkat(parent_fd, path.as_ptr(), 0) }).map(drop)
                    }
                    // ...unless this was supposed to be the deletion root directory
                    None =&gt; Err(err),
                };
            }
            result =&gt; result?,
        };

        // 打开目录 
        let (dir, fd) = fdreaddir(fd)?;
        // 用Iterator遍历
        for child in dir {
            let child = child?;
            let child_name = child.name_cstr();
            //判断child是否为目录
            match is_dir(&amp;child) {
                Some(true) =&gt; {
                    //递归调用
                    remove_dir_all_recursive(Some(fd), child_name)?;
                }
                Some(false) =&gt; {
                    //删除文件
                    cvt(unsafe { unlinkat(fd, child_name.as_ptr(), 0) })?;
                }
                None =&gt; {
                    //有些操作系统需要
                    remove_dir_all_recursive(Some(fd), child_name)?;
                }
            }
        }

        cvt(unsafe {
            //删除本身
            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), path.as_ptr(), libc::AT_REMOVEDIR)
        })?;
        Ok(())
    }

    fn remove_dir_all_modern(p: &amp;Path) -&gt; io::Result&lt;()&gt; {
        let attr = lstat(p)?;
        //判断是否是link
        if attr.file_type().is_symlink() {
            crate::fs::remove_file(p)
        } else {
            //能够满足文件及目录需求
            remove_dir_all_recursive(None, &amp;cstr(p)?)
        }
    }

    pub fn remove_dir_all(p: &amp;Path) -&gt; io::Result&lt;()&gt; {
        remove_dir_all_modern(p)
    }
}

<span class="boring">}</span></code></pre></pre>
<p>操作系统的每一个资源都是文件，这些资源即满足文件的统一操作，又具备自己的独特性。目录是一个典型的例子。</p>
<p>文件相关的类型结构及方法，函数：
创建一个文件的函数代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//以创建的方式打开一个文件并设置权限
fn open_to_and_set_permissions(
    to: &amp;Path,
    reader_metadata: crate::fs::Metadata,
) -&gt; io::Result&lt;(crate::fs::File, crate::fs::Metadata)&gt; {
    use crate::fs::OpenOptions;
    use crate::os::unix::fs::{OpenOptionsExt, PermissionsExt};

    let perm = reader_metadata.permissions();
    //利用OpenOptions打开一个文件
    let writer = OpenOptions::new()
        //见OpenOptions说明 
        .mode(perm.mode())
        //可写
        .write(true)
        //没有则创建
        .create(true)
        .truncate(true)
        .open(to)?;
    let writer_metadata = writer.metadata()?;
    if writer_metadata.is_file() {
        // 设置文件权限 
        writer.set_permissions(perm)?;
    }
    Ok((writer, writer_metadata))
}

//打开文件
fn open_from(from: &amp;Path) -&gt; io::Result&lt;(crate::fs::File, crate::fs::Metadata)&gt; {
    use crate::fs::File;
    use crate::sys_common::fs::NOT_FILE_ERROR;

    //此File::open是RUST标准库对外接口，与下面的File不是一个
    //实质是OpenOptions::new().read(true).open(from.as_ref());
    let reader = File::open(from)?;
    //获取文件属性
    let metadata = reader.metadata()?;
    //判断是否是文件
    if !metadata.is_file() {
        //不是，返回错误
        return Err(NOT_FILE_ERROR);
    }
    Ok((reader, metadata))
}
<span class="boring">}</span></code></pre></pre>
<p>以上实际上是文件类型结构及方法的应用起始点，相关的类型结构及方法如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//此类型结构主要用于设置文件open的选择项
//此类型结构对libc的open的属性参数做了总结，
//更友好的生成open的属性参数。否则，每次调用open都需要重新看man手册
//此类型结构可以处理一些文件打开时的矛盾选项，提升安全
pub struct OpenOptions {
    // 可读
    read: bool,
    //可写
    write: bool,
    //添加到尾部
    append: bool,
    //删除文件内容
    truncate: bool,
    //创建文件
    create: bool,
    //创建一个新的文件
    create_new: bool,
    //具体操作系统相关 
    custom_flags: i32,
    //
    mode: mode_t,
}
impl OpenOptions {
    pub fn new() -&gt; OpenOptions {
        //默认的属性
        OpenOptions {
            // generic
            read: false,
            write: false,
            append: false,
            truncate: false,
            create: false,
            create_new: false,
            // system-specific
            custom_flags: 0,
            //linux的文件权限
            mode: 0o666,
        }
    }

    //以下设置文件打开属性

    pub fn read(&amp;mut self, read: bool) {
        self.read = read;
    }
    pub fn write(&amp;mut self, write: bool) {
        self.write = write;
    }
    pub fn append(&amp;mut self, append: bool) {
        self.append = append;
    }
    pub fn truncate(&amp;mut self, truncate: bool) {
        self.truncate = truncate;
    }
    pub fn create(&amp;mut self, create: bool) {
        self.create = create;
    }
    pub fn create_new(&amp;mut self, create_new: bool) {
        self.create_new = create_new;
    }

    pub fn custom_flags(&amp;mut self, flags: i32) {
        self.custom_flags = flags;
    }
    pub fn mode(&amp;mut self, mode: u32) {
        self.mode = mode as mode_t;
    }

    //文件属性转化为libc的open函数中的文件模式参数读写位
    //可以看到，此函数将以前的经验做了总结。
    fn get_access_mode(&amp;self) -&gt; io::Result&lt;c_int&gt; {
        match (self.read, self.write, self.append) {
            (true, false, false) =&gt; Ok(libc::O_RDONLY),
            (false, true, false) =&gt; Ok(libc::O_WRONLY),
            (true, true, false) =&gt; Ok(libc::O_RDWR),
            (false, _, true) =&gt; Ok(libc::O_WRONLY | libc::O_APPEND),
            (true, _, true) =&gt; Ok(libc::O_RDWR | libc::O_APPEND),
            (false, false, false) =&gt; Err(Error::from_raw_os_error(libc::EINVAL)),
        }
    }

    //文件属性转化为libc的open函数中的文件模式参数创建位
    fn get_creation_mode(&amp;self) -&gt; io::Result&lt;c_int&gt; {
        //矛盾判断
        match (self.write, self.append) {
            (true, false) =&gt; {}
            //不允许写即不允许创建文件
            (false, false) =&gt; {
                if self.truncate || self.create || self.create_new {
                    return Err(Error::from_raw_os_error(libc::EINVAL));
                }
            }
            //与truncate矛盾
            (_, true) =&gt; {
                if self.truncate &amp;&amp; !self.create_new {
                    return Err(Error::from_raw_os_error(libc::EINVAL));
                }
            }
        }

        Ok(match (self.create, self.truncate, self.create_new) {
            (false, false, false) =&gt; 0,
            //创建文件
            (true, false, false) =&gt; libc::O_CREAT,
            //原有文件内容清零
            (false, true, false) =&gt; libc::O_TRUNC,
            //没有文件就创建，文件存在则清零
            (true, true, false) =&gt; libc::O_CREAT | libc::O_TRUNC,
            //没有文件就创建，文件存在则返回失败
            (_, _, true) =&gt; libc::O_CREAT | libc::O_EXCL,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>OpenOption在细节上体现了RUST的程序员友好，将原本libc::open函数中的属性参数的学习负担清除掉了。 </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 操作系统无关界面接口File类型结构
pub struct File(FileDesc);

//创建文件的方法实现
impl File {
    //打开文件，创建新文件也用此函数
    pub fn open(path: &amp;Path, opts: &amp;OpenOptions) -&gt; io::Result&lt;File&gt; {
        //linux中，需要把Path转换成C字符串
        let path = cstr(path)?;
        File::open_c(&amp;path, opts)
    }

    //利用libc::open打开及创建文件
    pub fn open_c(path: &amp;CStr, opts: &amp;OpenOptions) -&gt; io::Result&lt;File&gt; {
        //创建文件时最复杂的是flags的生成,
        //RUST利用OpenOptions比较直观的完成了这个工作
        let flags = libc::O_CLOEXEC
            | opts.get_access_mode()?
            | opts.get_creation_mode()?
            | (opts.custom_flags as c_int &amp; !libc::O_ACCMODE);
        //不同的操作系统还是有些区别，但不必关注这个细节了
        let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;
        //创建File变量，unsafe表明了fd的不安全的特性
        Ok(File(unsafe { FileDesc::from_raw_fd(fd) }))
    }

    ...
    ...
}

//路径名类型结构，必须用OsStr来实现
//此处没有repr(transparent)，但Path的内存布局与OsStr是一致的
pub struct Path {
    inner: OsStr,
}

impl Path {
    //能够转换为OsStr引用的类型都能够转换为Path的引用
    //Path的内存布局与OsStr是一致的。
    pub fn new&lt;S: AsRef&lt;OsStr&gt; + ?Sized&gt;(s: &amp;S) -&gt; &amp;Path {
        unsafe { &amp;*(s.as_ref() as *const OsStr as *const Path) }
    }
}

//Path一般用于引用，PathBuf拥有所有权
//本质上Path与PathBuf的关系就是OsStr与OsString的关系
pub struct PathBuf {
    inner: OsString,
}

impl PathBuf {
    pub fn new() -&gt; PathBuf {
        PathBuf { inner: OsString::new() }
    }
    ...
    ...
}

<span class="boring">}</span></code></pre></pre>
<p>以上是RUST中文件类型结构典型的创建的过程。
下面是文件拷贝函数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//拷贝文件
pub fn copy(from: &amp;Path, to: &amp;Path) -&gt; io::Result&lt;u64&gt; {
    let (mut reader, reader_metadata) = open_from(from)?;
    let max_len = u64::MAX;
    //注意这个文件属性的传递
    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;

    use super::kernel_copy::{copy_regular_files, CopyResult};

    match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {
        CopyResult::Ended(bytes) =&gt; Ok(bytes),
        CopyResult::Error(e, _) =&gt; Err(e),
        CopyResult::Fallback(written) =&gt; match io::copy::generic_copy(&amp;mut reader, &amp;mut writer) {
            Ok(bytes) =&gt; Ok(bytes + written),
            Err(e) =&gt; Err(e),
        },
    }
}

<span class="boring">}</span></code></pre></pre>
<p>其他RUST的文件操作，操作系统相关模块提供的对外接口, 基本都是直接调用libc的同名函数，解释略:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//删除文件及连接
pub fn unlink(p: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let p = cstr(p)?;
    cvt(unsafe { libc::unlink(p.as_ptr()) })?;
    Ok(())
}

pub fn rename(old: &amp;Path, new: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let old = cstr(old)?;
    let new = cstr(new)?;
    cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })?;
    Ok(())
}

pub fn symlink(original: &amp;Path, link: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let original = cstr(original)?;
    let link = cstr(link)?;
    cvt(unsafe { libc::symlink(original.as_ptr(), link.as_ptr()) })?;
    Ok(())
}

pub fn chown(path: &amp;Path, uid: u32, gid: u32) -&gt; io::Result&lt;()&gt; {
    let path = cstr(path)?;
    cvt(unsafe { libc::chown(path.as_ptr(), uid as libc::uid_t, gid as libc::gid_t) })?;
    Ok(())
}

pub fn fchown(fd: c_int, uid: u32, gid: u32) -&gt; io::Result&lt;()&gt; {
    cvt(unsafe { libc::fchown(fd, uid as libc::uid_t, gid as libc::gid_t) })?;
    Ok(())
}

pub fn lchown(path: &amp;Path, uid: u32, gid: u32) -&gt; io::Result&lt;()&gt; {
    let path = cstr(path)?;
    cvt(unsafe { libc::lchown(path.as_ptr(), uid as libc::uid_t, gid as libc::gid_t) })?;
    Ok(())
}

pub fn chroot(dir: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let dir = cstr(dir)?;
    cvt(unsafe { libc::chroot(dir.as_ptr()) })?;
    Ok(())
}

//创建一个文件链接
pub fn link(original: &amp;Path, link: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let original = cstr(original)?;
    let link = cstr(link)?;
        {
            // Where we can, use `linkat` instead of `link`; see the comment above
            // this one for details on why.
            cvt(unsafe { libc::linkat(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;
        }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>以下接口函数需要对libc的函数做些适配工作</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//设置文件权限， FilePermission见下面结构
pub fn set_perm(p: &amp;Path, perm: FilePermissions) -&gt; io::Result&lt;()&gt; {
    let p = cstr(p)?;
    cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) })?;
    Ok(())
}

//linux的文件权限
pub struct FilePermissions {
    mode: mode_t,
}


//获取文件属性, FileAttr见后面的代码分析
pub fn stat(p: &amp;Path) -&gt; io::Result&lt;FileAttr&gt; {
    let p = cstr(p)?;

        //try_statx将后面的分析
        if let Some(ret) = unsafe { try_statx(
            libc::AT_FDCWD,
            p.as_ptr(),
            libc::AT_STATX_SYNC_AS_STAT,
            libc::STATX_ALL,
        ) } {
            //如果成功，已经用statx方式获取
            //返回
            return ret;
        }

    //否则，用stat64方式获取属性
    let mut stat: stat64 = unsafe { mem::zeroed() };
    cvt(unsafe { stat64(p.as_ptr(), &amp;mut stat) })?;
    Ok(FileAttr::from_stat64(stat))
}


//相关的
pub struct FileType {
    mode: mode_t,
}

pub struct FileAttr {
    stat: stat64,
    statx_extra_fields: Option&lt;StatxExtraFields&gt;,
}

impl FileAttr {
    fn from_stat64(stat: stat64) -&gt; Self {
        Self { stat, statx_extra_fields: None }
    }

    pub fn size(&amp;self) -&gt; u64 {
        self.stat.st_size as u64
    }
    pub fn perm(&amp;self) -&gt; FilePermissions {
        FilePermissions { mode: (self.stat.st_mode as mode_t) }
    }

    pub fn file_type(&amp;self) -&gt; FileType {
        FileType { mode: self.stat.st_mode as mode_t }
    }
}

impl FileAttr {
    //修改时间
    pub fn modified(&amp;self) -&gt; io::Result&lt;SystemTime&gt; {
        Ok(SystemTime::from(libc::timespec {
            tv_sec: self.stat.st_mtime as libc::time_t,
            tv_nsec: self.stat.st_mtime_nsec as _,
        }))
    }

    //创建时间
    pub fn created(&amp;self) -&gt; io::Result&lt;SystemTime&gt; {
            if let Some(ext) = &amp;self.statx_extra_fields {
                return if (ext.stx_mask &amp; libc::STATX_BTIME) != 0 {
                    Ok(SystemTime::from(libc::timespec {
                        tv_sec: ext.stx_btime.tv_sec as libc::time_t,
                        tv_nsec: ext.stx_btime.tv_nsec as _,
                    }))
                } else {
                    Err(io::const_io_error!(
                        io::ErrorKind::Uncategorized,
                        &quot;creation time is not available for the filesystem&quot;,
                    ))
                };
            }

        Err(io::const_io_error!(
            io::ErrorKind::Unsupported,
            &quot;creation time is not available on this platform \
                            currently&quot;,
        ))
    }
}


struct StatxExtraFields {
    stx_mask: u32,
    stx_btime: libc::statx_timestamp,
}

//linux上，statx包含了最全面的信息
unsafe fn try_statx(
    fd: c_int,
    path: *const c_char,
    flags: i32,
    mask: u32,
) -&gt; Option&lt;io::Result&lt;FileAttr&gt;&gt; {
    use crate::sync::atomic::{AtomicU8, Ordering};

    syscall! {
        fn statx(
            fd: c_int,
            pathname: *const c_char,
            flags: c_int,
            mask: libc::c_uint,
            statxbuf: *mut libc::statx
        ) -&gt; c_int
    }

    let mut buf: libc::statx = mem::zeroed();
    if let Err(err) = cvt(statx(fd, path, flags, mask, &amp;mut buf)) {
        return Some(Err(err));
    }

    // 需要用stat64返回，以下从stat翻译到stat64.
    let mut stat: stat64 = mem::zeroed();
    // `c_ulong` on gnu-mips, `dev_t` otherwise
    stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;
    stat.st_ino = buf.stx_ino as libc::ino64_t;
    stat.st_nlink = buf.stx_nlink as libc::nlink_t;
    stat.st_mode = buf.stx_mode as libc::mode_t;
    stat.st_uid = buf.stx_uid as libc::uid_t;
    stat.st_gid = buf.stx_gid as libc::gid_t;
    stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;
    stat.st_size = buf.stx_size as off64_t;
    stat.st_blksize = buf.stx_blksize as libc::blksize_t;
    stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;
    stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;
    // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.
    stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;
    stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;
    stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;
    stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;
    stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;

    let extra = StatxExtraFields {
        stx_mask: buf.stx_mask,
        stx_btime: buf.stx_btime,
    };

    Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))
}


//link的属性获取,与stat类似
pub fn lstat(p: &amp;Path) -&gt; io::Result&lt;FileAttr&gt; {
    let p = cstr(p)?;

        if let Some(ret) = unsafe { try_statx(
            libc::AT_FDCWD,
            p.as_ptr(),
            libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,
            libc::STATX_ALL,
        ) } {
            return ret;
        }

    let mut stat: stat64 = unsafe { mem::zeroed() };
    cvt(unsafe { lstat64(p.as_ptr(), &amp;mut stat) })?;
    Ok(FileAttr::from_stat64(stat))
}


//相关的类型结构的方法实现
impl FilePermissions {
    pub fn readonly(&amp;self) -&gt; bool {
        // check if any class (owner, group, others) has write permission
        self.mode &amp; 0o222 == 0
    }

    pub fn set_readonly(&amp;mut self, readonly: bool) {
        if readonly {
            // remove write permission for all classes; equivalent to `chmod a-w &lt;file&gt;`
            self.mode &amp;= !0o222;
        } else {
            // add write permission for all classes; equivalent to `chmod a+w &lt;file&gt;`
            self.mode |= 0o222;
        }
    }
    pub fn mode(&amp;self) -&gt; u32 {
        self.mode as u32
    }
}

impl FileType {
    pub fn is_dir(&amp;self) -&gt; bool {
        self.is(libc::S_IFDIR)
    }
    pub fn is_file(&amp;self) -&gt; bool {
        self.is(libc::S_IFREG)
    }
    pub fn is_symlink(&amp;self) -&gt; bool {
        self.is(libc::S_IFLNK)
    }

    pub fn is(&amp;self, mode: mode_t) -&gt; bool {
        self.mode &amp; libc::S_IFMT == mode
    }
}

<span class="boring">}</span></code></pre></pre>
<p>以下两个函数涉及到了从外部C函数传入的字符串与RUST字符串的转换，值得仔细学习。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//读取链接的path
pub fn readlink(p: &amp;Path) -&gt; io::Result&lt;PathBuf&gt; {
    let c_path = cstr(p)?;
    let p = c_path.as_ptr();

    //因为需要用C语言的字符串存放读回的内容，
    //所以用Vec来申请内存
    let mut buf = Vec::with_capacity(256);

    loop {
        //读到buf里，限制了读的长度
        let buf_read =
            cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;

        //读成功, 设置Vec，使得Vec正确反映读的内容
        //此处是RUST与C交互的额外的设置内容，很易出错
        unsafe {
            //直接用set_len完成Vec的len初始化
            buf.set_len(buf_read);
        }

        //将Vec转化为OsString
        if buf_read != buf.capacity() {
            //不能有额外的容量
            buf.shrink_to_fit();

            //创建PathBuf并返回
            return Ok(PathBuf::from(OsString::from_vec(buf)));
        }

        // 如果正好是vec的容量，证明link的内容可能长过容量，
        // reserve(1)后再次读
        buf.reserve(1);
    }
}

//返回绝对路径
pub fn canonicalize(p: &amp;Path) -&gt; io::Result&lt;PathBuf&gt; {
    //这里需要自行申请内存，防止不安全
    let path = CString::new(p.as_os_str().as_bytes())?;
    let buf;
    unsafe {
        //返回绝对路径
        let r = libc::realpath(path.as_ptr(), ptr::null_mut());
        if r.is_null() {
            return Err(io::Error::last_os_error());
        }
        //将返回的C字符串用以生成Vec
        buf = CStr::from_ptr(r).to_bytes().to_vec();
        //负责释放
        libc::free(r as *mut _);
    }
    //生成PathBuf
    Ok(PathBuf::from(OsString::from_vec(buf)))
}
<span class="boring">}</span></code></pre></pre>
<p>文件的其他属性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl File {
    //文件属性获取
    pub fn file_attr(&amp;self) -&gt; io::Result&lt;FileAttr&gt; {
        let fd = self.as_raw_fd();

            if let Some(ret) = unsafe { try_statx(
                fd,
                b&quot;\0&quot; as *const _ as *const c_char,
                libc::AT_EMPTY_PATH | libc::AT_STATX_SYNC_AS_STAT,
                libc::STATX_ALL,
            ) } {
                return ret;
            }

        let mut stat: stat64 = unsafe { mem::zeroed() };
        cvt(unsafe { fstat64(fd, &amp;mut stat) })?;
        Ok(FileAttr::from_stat64(stat))
    }

    //完成文件内存与磁盘同步
    pub fn fsync(&amp;self) -&gt; io::Result&lt;()&gt; {
        cvt_r(|| unsafe { os_fsync(self.as_raw_fd()) })?;
        return Ok(());

        unsafe fn os_fsync(fd: c_int) -&gt; c_int {
            libc::fsync(fd)
        }
    }

    //仅完成文件的数据与磁盘同步，不包括文件属性
    pub fn datasync(&amp;self) -&gt; io::Result&lt;()&gt; {
        cvt_r(|| unsafe { os_datasync(self.as_raw_fd()) })?;
        return Ok(());

        unsafe fn os_datasync(fd: c_int) -&gt; c_int {
            libc::fdatasync(fd)
        }
    }

    //删除文件内容
    pub fn truncate(&amp;self, size: u64) -&gt; io::Result&lt;()&gt; {
        use crate::convert::TryInto;
        let size: off64_t =
            size.try_into().map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
        cvt_r(|| unsafe { ftruncate64(self.as_raw_fd(), size) }).map(drop)
    }

    //复制fd，并形成新的File
    pub fn duplicate(&amp;self) -&gt; io::Result&lt;File&gt; {
        self.0.duplicate().map(File)
    }

    //设置文件权限
    pub fn set_permissions(&amp;self, perm: FilePermissions) -&gt; io::Result&lt;()&gt; {
        cvt_r(|| unsafe { libc::fchmod(self.as_raw_fd(), perm.mode) })?;
        Ok(())
    }
}

//用于创建目录
pub struct DirBuilder {
    mode: mode_t,
}


impl DirBuilder {
    pub fn new() -&gt; DirBuilder {
        DirBuilder { mode: 0o777 }
    }

    //创建一个目录
    pub fn mkdir(&amp;self, p: &amp;Path) -&gt; io::Result&lt;()&gt; {
        let p = cstr(p)?;
        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;
        Ok(())
    }

    //设置创建目录的权限
    pub fn set_mode(&amp;mut self, mode: u32) {
        self.mode = mode as mode_t;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="操作系统无关文件系统模块分析"><a class="header" href="#操作系统无关文件系统模块分析">操作系统无关文件系统模块分析</a></h2>
<p>引入linux的fs类型结构及实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::sys::fs as fs_imp;
<span class="boring">}</span></code></pre></pre>
<p>RUST标准库对外接口的类型结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//及linux文件系统中File的封装
pub struct File {
    inner: fs_imp::File,
}

//文件元数据，即FileAttr的封装
pub struct Metadata(fs_imp::FileAttr);

//打开的目录类型结构，即linux的fs同名结构封装
pub struct ReadDir(fs_imp::ReadDir);

//目录中的项目类型结构，也即简单封装
pub struct DirEntry(fs_imp::DirEntry);

//创建/打开文件的执行者类型结构，也即简单封装
pub struct OpenOptions(fs_imp::OpenOptions);

//文件权限
pub struct Permissions(fs_imp::FilePermissions);

//文件类型
pub struct FileType(fs_imp::FileType);

//目录创建执行类型结构
pub struct DirBuilder {
    inner: fs_imp::DirBuilder,
    //是否为多级目录
    recursive: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>相关的与文件读写无关的实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl File {
    //只读文件打开, RUST的文件打开，打开模式的输入，
    //用不同的函数表示不同的打开方式
    pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; {
        //见后继的OpenOptions的分析
        OpenOptions::new().read(true).open(path.as_ref())
    }

    //创建一个文件
    pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; {
        //文件设置为可写，文件存在则删除内容，文件不在就创建
        OpenOptions::new().write(true).create(true).truncate(true).open(path.as_ref())
    }

    //创建一个文件打开选项
    pub fn options() -&gt; OpenOptions {
        OpenOptions::new()
    }

    //同步文件到磁盘
    pub fn sync_all(&amp;self) -&gt; io::Result&lt;()&gt; {
        self.inner.fsync()
    }

    //只同步文件数据到磁盘
    pub fn sync_data(&amp;self) -&gt; io::Result&lt;()&gt; {
        self.inner.datasync()
    }

    //设置文件为指定大小
    pub fn set_len(&amp;self, size: u64) -&gt; io::Result&lt;()&gt; {
        self.inner.truncate(size)
    }

    //获取文件属性
    pub fn metadata(&amp;self) -&gt; io::Result&lt;Metadata&gt; {
        self.inner.file_attr().map(Metadata)
    }

    //复制文件描述符，生成新的File变量
    pub fn try_clone(&amp;self) -&gt; io::Result&lt;File&gt; {
        Ok(File { inner: self.inner.duplicate()? })
    }

    //设置文件权限
    pub fn set_permissions(&amp;self, perm: Permissions) -&gt; io::Result&lt;()&gt; {
        self.inner.set_permissions(perm.0)
    }
}

//文件创建/打开的执行类型结构
impl OpenOptions {
    //对操作系统相关的同名结构的Adapter
    pub fn new() -&gt; Self {
        OpenOptions(fs_imp::OpenOptions::new())
    }

    pub fn read(&amp;mut self, read: bool) -&gt; &amp;mut Self {
        self.0.read(read);
        self
    }

    pub fn write(&amp;mut self, write: bool) -&gt; &amp;mut Self {
        self.0.write(write);
        self
    }

    pub fn append(&amp;mut self, append: bool) -&gt; &amp;mut Self {
        self.0.append(append);
        self
    }

    pub fn truncate(&amp;mut self, truncate: bool) -&gt; &amp;mut Self {
        self.0.truncate(truncate);
        self
    }

    pub fn create(&amp;mut self, create: bool) -&gt; &amp;mut Self {
        self.0.create(create);
        self
    }

    pub fn create_new(&amp;mut self, create_new: bool) -&gt; &amp;mut Self {
        self.0.create_new(create_new);
        self
    }

    //利用一个类型结构完成打开文件的各种选项，比用一个参数表达更清晰
    //易掌握
    pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; io::Result&lt;File&gt; {
        self._open(path.as_ref())
    }

    fn _open(&amp;self, path: &amp;Path) -&gt; io::Result&lt;File&gt; {
        fs_imp::File::open(path, &amp;self.0).map(|inner| File { inner })
    }
}

// ReadDir适配设计模式
impl Iterator for ReadDir {
    type Item = io::Result&lt;DirEntry&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;io::Result&lt;DirEntry&gt;&gt; {
        self.0.next().map(|entry| entry.map(DirEntry))
    }
}


impl DirBuilder {
    pub fn new() -&gt; DirBuilder {
        DirBuilder { inner: fs_imp::DirBuilder::new(), recursive: false }
    }

    pub fn recursive(&amp;mut self, recursive: bool) -&gt; &amp;mut Self {
        self.recursive = recursive;
        self
    }

    //创建一个目录
    pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; io::Result&lt;()&gt; {
        self._create(path.as_ref())
    }

    fn _create(&amp;self, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
        //如果是多级，则进入下一级，否则创建新目录
        if self.recursive { self.create_dir_all(path) } else { self.inner.mkdir(path) }
    }

    //创建多级目录
    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
        if path == Path::new(&quot;&quot;) {
            return Ok(());
        }

        match self.inner.mkdir(path) {
            Ok(()) =&gt; return Ok(()),
            Err(ref e) if e.kind() == io::ErrorKind::NotFound =&gt; {}
            Err(_) if path.is_dir() =&gt; return Ok(()),
            Err(e) =&gt; return Err(e),
        }
        match path.parent() {
            Some(p) =&gt; self.create_dir_all(p)?,
            None =&gt; {
                return Err(io::const_io_error!(
                    io::ErrorKind::Uncategorized,
                    &quot;failed to create whole tree&quot;,
                ));
            }
        }
        match self.inner.mkdir(path) {
            Ok(()) =&gt; Ok(()),
            Err(_) if path.is_dir() =&gt; Ok(()),
            Err(e) =&gt; Err(e),
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>RUST标准库对外文件操作函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//删除文件
pub fn remove_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;()&gt; {
    fs_imp::unlink(path.as_ref())
}

//获取文件属性
pub fn metadata&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Metadata&gt; {
    fs_imp::stat(path.as_ref()).map(Metadata)
}

//链接属性
pub fn symlink_metadata&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Metadata&gt; {
    fs_imp::lstat(path.as_ref()).map(Metadata)
}

//重命名
pub fn rename&lt;P: AsRef&lt;Path&gt;, Q: AsRef&lt;Path&gt;&gt;(from: P, to: Q) -&gt; io::Result&lt;()&gt; {
    fs_imp::rename(from.as_ref(), to.as_ref())
}

//创建硬链接
pub fn hard_link&lt;P: AsRef&lt;Path&gt;, Q: AsRef&lt;Path&gt;&gt;(original: P, link: Q) -&gt; io::Result&lt;()&gt; {
    fs_imp::link(original.as_ref(), link.as_ref())
}

//创建软链接
pub fn soft_link&lt;P: AsRef&lt;Path&gt;, Q: AsRef&lt;Path&gt;&gt;(original: P, link: Q) -&gt; io::Result&lt;()&gt; {
    fs_imp::symlink(original.as_ref(), link.as_ref())
}

//读取链接内容
pub fn read_link&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;PathBuf&gt; {
    fs_imp::readlink(path.as_ref())
}

//生成绝对路径
pub fn canonicalize&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;PathBuf&gt; {
    fs_imp::canonicalize(path.as_ref())
}

//创建一个目录
pub fn create_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;()&gt; {
    DirBuilder::new().create(path.as_ref())
}

//创建多级目录
pub fn create_dir_all&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;()&gt; {
    DirBuilder::new().recursive(true).create(path.as_ref())
}

//删除空目录
pub fn remove_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;()&gt; {
    fs_imp::rmdir(path.as_ref())
}

//删除整个目录
pub fn remove_dir_all&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;()&gt; {
    fs_imp::remove_dir_all(path.as_ref())
}

//打开目录，准备用Iterator的方式读
pub fn read_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;ReadDir&gt; {
    fs_imp::readdir(path.as_ref()).map(ReadDir)
}

//设置文件权限
pub fn set_permissions&lt;P: AsRef&lt;Path&gt;&gt;(path: P, perm: Permissions) -&gt; io::Result&lt;()&gt; {
    fs_imp::set_perm(path.as_ref(), perm.0)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust的io操作"><a class="header" href="#rust的io操作">RUST的IO操作</a></h1>
<p>IO是一门语言中内容最多，最繁杂的一个课题，其关心的主要内容:</p>
<ol>
<li>操作系统文件同步IO操作</li>
<li>操作系统网络/设备同步IO操作</li>
<li>操作系统多路异步IO操作，包括文件/设备/网络</li>
<li>采用一套编程模型抽象与IO相关的缓存操作</li>
<li>程序不同模块间通信采取与4相同的抽象接口</li>
<li>...</li>
</ol>
<p>值得注意，在服务器后端的应用中，实际上采用多路异步IO是标准的实现方式，异步IO内容稍微复杂，将在后继的异步IO章节里单独说明。
RUST的标准库中的IO内容实际上仅仅提供同步IO的实现。要注意的是，虽然标准库仅提供了同步IO，但异步IO实际上仍然可以将这些同步IO的实现作为基本组件来简化工作。</p>
<p>在同步IO设计中，符合自然视角的IO对象设计，线程安全设计，缓存设计是难点。</p>
<p>IO对象设计：<br />
最自然的IO对象设计是针对每一个不同的IO分类设计不同的IO对象类型，不同的IO对象实现相同的操作 trait，仅在独特之处进行方法扩充。</p>
<p>线程安全设计：<br />
每一个IO对象实际上都存在多线程操作的可能，IO对象的类型结构应该是一个RUST线程安全类型结构。</p>
<p>缓存设计：
不是所有的IO对象类型都需要缓存，设计缓存的作用主要是：</p>
<ol>
<li>可以将一些底层的IO操作封装在缓存实现中，简化上层模块IO实现。</li>
<li>提升IO效率，对某些非实时IO操作，可以达到一定数目后批量性写入，或批量性读出</li>
<li>更好的模块性，可以将缓存作为不同模块的IO管道，重用已有模块，例如重用压缩/解压缩模块</li>
<li>用作数据序列化格式转换的执行类型，以及数据序列化的内存存储，方便各种操作</li>
</ol>
<p>缓存设计的一些需求：</p>
<ol>
<li>缓存自身应该作为一种IO对象，</li>
<li>缓存封装原始IO对象，使用adapter模式完成对原始IO对象的IO操作</li>
<li>针对不同的IO对象的缓存基础设施结构，支持不同的IO对象的缓存设计</li>
<li>迭代器设计以应用函数式编程。</li>
</ol>
<p>先以标准输入的IO对象来阐明RUST的同步IO实现的代码:</p>
<h2 id="rust标准库stdin的代码分析"><a class="header" href="#rust标准库stdin的代码分析">RUST标准库Stdin的代码分析</a></h2>
<p>RUST语言库实现了线程安全的标准输入。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/io/stdio.rs
pub struct Stdin {
    //标准输入可认为是静态的
    inner: &amp;'static Mutex&lt;BufReader&lt;StdinRaw&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Mutex&lt;T&gt;</code>请参考前文的分析。
原始的标准输入源IO对象类型StdinRaw定义相关代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//linux系统的标准输入的类型结构
//因为标准输入的文件描述符不必关闭，
//所以此处用了单元类型
//路径: library/std/src/sys/unix/stdio.rs
pub struct Stdin(());

impl Stdin {
    //创建函数
    pub const fn new() -&gt; Stdin {
        Stdin(())
    }
}

//RUST对操作系统的扩展
//路径: library/std/src/io/stdio.rs
//此处stdio是sys::stdio
struct StdinRaw(stdio::Stdin); 

//StdinRaw的工厂函数
const fn stdin_raw() -&gt; StdinRaw {
    StdinRaw(stdio::Stdin::new())
}
<span class="boring">}</span></code></pre></pre>
<p>RUST专门为读入设计的缓存类型结构<code>BufReader&lt;R&gt;</code>定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径: library/std/src/io/buffer/bufreader.rs
//在实现了Read trait的输入源IO对象类型基础上创建读缓存结构
pub struct BufReader&lt;R&gt; {
    //输入源IO对象类型，
    //BufReader拥有其所有权
    inner: R,
    //缓存，在self创建的时候一般没有初始化
    //位于堆内存
    buf: Box&lt;[MaybeUninit&lt;u8&gt;]&gt;,
    //缓存中未被读取的数据起始位置
    pos: usize,
    //从输入源已经读入缓存的数据终止位置
    cap: usize,
    //buf中已经初始化过的数据的终止位置
    init: usize,
}

impl&lt;R: Read&gt; BufReader&lt;R&gt; {
    //创建一个默认空间的缓存
    pub fn new(inner: R) -&gt; BufReader&lt;R&gt; {
        //DEFAULT_BUF_SIZE RUST当前定义为8*1024
        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)
    }

    pub fn with_capacity(capacity: usize, inner: R) -&gt; BufReader&lt;R&gt; {
        //从堆中申请相应空间的内存
        let buf = Box::new_uninit_slice(capacity);
        //创建BufReader类型变量
        BufReader { inner, buf, pos: 0, cap: 0, init: 0 }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对于所有的输入IO对象类型，必须实现Read trait:
定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径: library/std/src/io/mod.rs
//在异步IO时，此Read可以用于最底层的支持
pub trait Read {
    //从输入IO对象类型中读出数据到buf中，成功则返回读到的长度
    //否则返回IO错误，IO错误的情况下，buf中一定没有数据
    //此函数可能被阻塞，如果需要阻塞又没办法时，会返回Err
    //返回0一般表示已经读到文件尾部或fd已经关闭，或者buf空间为0
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;

    //利用向量读的方式读，除此之外，与read相同, IoSliceMut见后继说明
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt; {
        //默认不支持iovec的方式，使用read来模拟实现
        default_read_vectored(|b| self.read(b), bufs)
    }

    //是否实现向量读的方式,一般应优选向量读
    fn is_read_vectored(&amp;self) -&gt; bool {
        false
    }

    //此方法会循环调用read直至读到文件尾(EOF)
    //一直读到文件尾部，此方法内部可以自由扩充Vec，Vec中的有效内容代表已经读到
    //的数据。
    //遇到错误会立刻返回，读到的数据仍然在Vec中
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; {
        default_read_to_end(self, buf)
    }

    //类似与read_to_end，但这里确定读到的是字符串,且符合utf-8的编码
    //其他与read_to_end相同
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; {
        default_read_to_string(self, buf)
    }

    //精确读与buf长度相同的字节，否则返回错误
    //如果长度不够且到达尾部，会返回错误
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;()&gt; {
        default_read_exact(self, buf)
    }

    //在有缓存的情况下，用以下函数将数据读到缓存里
    //一般ReadBuf由缓存类型结构创建
    fn read_buf(&amp;mut self, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        default_read_buf(|b| self.read(b), buf)
    }

    //精确的将要求容量字节到缓存里面
    fn read_buf_exact(&amp;mut self, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        while buf.remaining() &gt; 0 {
            let prev_filled = buf.filled().len();
            match self.read_buf(buf) {
                Ok(()) =&gt; {}
                Err(e) if e.kind() == ErrorKind::Interrupted =&gt; continue,
                Err(e) =&gt; return Err(e),
            }

            if buf.filled().len() == prev_filled {
                return Err(Error::new(ErrorKind::UnexpectedEof, &quot;failed to fill buffer&quot;));
            }
        }

        Ok(())
    }

    //借用的一种实现方式，专为Read使用
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized,
    {
        self
    }

    //将本身转换为一个字节流的迭代器
    //后继用迭代器的方法完成读
    fn bytes(self) -&gt; Bytes&lt;Self&gt;
    where
        Self: Sized,
    {
        Bytes { inner: self }
    }

    //将两个读的源串接
    fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;
    where
        Self: Sized,
    {
        Chain { first: self, second: next, done_first: false }
    }

    //以self为基础生成一个字节数有限制的输入源
    fn take(self, limit: u64) -&gt; Take&lt;Self&gt;
    where
        Self: Sized,
    {
        Take { inner: self, limit }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对于文件类及缓存类IO对象类型，一般也都实现了在IO流中定位特定位置的 Seek trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SeekFrom {
    /// 从头部开始向尾部偏移字节数.
    Start(u64),
 
    //从尾部开始向头部偏移字节数
    End(i64),

    //从当前位置开始向尾部偏移字节数
    Current(i64),
}
pub trait Seek {
    //定位到IO流的指定偏移位置，如果需要从当前位置向头部偏移
    //则返回错误
    //成功则返回从头部计算的的偏移字节数
    fn seek(&amp;mut self, pos: SeekFrom) -&gt; Result&lt;u64&gt;;

    //重新定位到头部
    fn rewind(&amp;mut self) -&gt; Result&lt;()&gt; {
        self.seek(SeekFrom::Start(0))?;
        Ok(())
    }

    //返回IO流的总长度
    fn stream_len(&amp;mut self) -&gt; Result&lt;u64&gt; {
        //保存当前位置
        let old_pos = self.stream_position()?;
        //重定位到尾
        let len = self.seek(SeekFrom::End(0))?;

        if old_pos != len {
            //返回到当前位置
            self.seek(SeekFrom::Start(old_pos))?;
        }

        Ok(len)
    }

    //返回当前位置
    fn stream_position(&amp;mut self) -&gt; Result&lt;u64&gt; {
        self.seek(SeekFrom::Current(0))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>针对std::sys::Stdio的Read trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/sys/unix/stdio.rs
//实现Read trait
impl io::Read for Stdin {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //标准输入不必关闭，因此这里生成的OwnedFd不能调用drop
        //所以用ManuallyDrop来实现这一点
        //自动解引用调用FileDesc::read方法
        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read(buf) }
    }

    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read_vectored(bufs) }
    }

    fn is_read_vectored(&amp;self) -&gt; bool {
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<p>针对StdioRaw的Read trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/io/stdio.rs
//支持函数,处理输入输出的错误
fn handle_ebadf&lt;T&gt;(r: io::Result&lt;T&gt;, default: T) -&gt; io::Result&lt;T&gt; {
    match r {
        //如果错误是fd无效，则返回默认值
        Err(ref e) if stdio::is_ebadf(e) =&gt; Ok(default),
        r =&gt; r,
    }
}

//RUST的IO对象类型通常是一个逐级封装的结构
//StdinRaw采用了adapter的模式实现Read trait
impl Read for StdinRaw {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //直接调用内部封装的stdin同名方法
        handle_ebadf(self.0.read(buf), 0)
    }

    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        handle_ebadf(self.0.read_vectored(bufs), 0)
    }

    fn is_read_vectored(&amp;self) -&gt; bool {
        self.0.is_read_vectored()
    }

    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; {
        handle_ebadf(self.0.read_to_end(buf), 0)
    }

    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; {
        handle_ebadf(self.0.read_to_string(buf), 0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>RUST语言的Stdin实质是<code>BufReader&lt;StdinRaw&gt;</code>的线程安全版本。<br />
BufReader需要实现基于缓存的 BufRead trait, 以充分利用缓存：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径: library/std/src/io/mod.rs 
pub trait BufRead: Read {
    //从输入源IO对象读入并填充缓存，并将内部的缓存
    //以字节切片引用方式返回
    fn fill_buf(&amp;mut self) -&gt; Result&lt;&amp;[u8]&gt;;

    //有amt的字节被从缓存读出，对self的参数做针对性改变
    fn consume(&amp;mut self, amt: usize);

    //缓存是否还存在未被读出的数据
    fn has_data_left(&amp;mut self) -&gt; Result&lt;bool&gt; {
        self.fill_buf().map(|b| !b.is_empty())
    }

    //将buf读到buf中，直到有数据为输入的参数
    fn read_until(&amp;mut self, byte: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; {
        read_until(self, byte, buf)
    }

    //从缓存中读出一行
    fn read_line(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; {
        //借助read_until简单实现
        unsafe { append_to_string(buf, |b| read_until(self, b'\n', b)) }
    }

    //返回一个迭代器，将buf按输入的参数做分离
    fn split(self, byte: u8) -&gt; Split&lt;Self&gt;
    where
        Self: Sized,
    {
        Split { buf: self, delim: byte }
    }

    //返回一个迭代器，将buf按行进行迭代
    fn lines(self) -&gt; Lines&lt;Self&gt;
    where
        Self: Sized,
    {
        Lines { buf: self }
    }
}

//上面trait的支持函数
fn read_until&lt;R: BufRead + ?Sized&gt;(r: &amp;mut R, delim: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; {
    let mut read = 0;
    loop {
        let (done, used) = {
            //先将数据读入r的缓存中，available是新读入的内容
            let available = match r.fill_buf() {
                Ok(n) =&gt; n,
                Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; continue,
                Err(e) =&gt; return Err(e),
            };
            //在buf中定位第一个分隔符
            match memchr::memchr(delim, available) {
                //找到
                Some(i) =&gt; {
                    //将分隔符之前的内容置入buf中
                    buf.extend_from_slice(&amp;available[..=i]);
                    (true, i + 1)
                }
                //没找到
                None =&gt; {
                    //将所有内容置入buf中
                    buf.extend_from_slice(available);
                    (false, available.len())
                }
            }
        };
        //更新r以反应已经读出的内容
        r.consume(used);
        //得到读到的字节总数
        read += used;
        //看是否已经读到分隔符，或者内容已经读空
        if done || used == 0 {
            //返回读到的字节总数目
            return Ok(read);
        }
    }
}

//BufRead::read_lines的Iterator类型支持结构
pub struct Lines&lt;B&gt; {
    buf: B,
}

impl&lt;B: BufRead&gt; Iterator for Lines&lt;B&gt; {
    type Item = Result&lt;String&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;String&gt;&gt; {
        let mut buf = String::new();
        //调用read_line
        match self.buf.read_line(&amp;mut buf) {
            Ok(0) =&gt; None,
            Ok(_n) =&gt; {
                if buf.ends_with('\n') {
                    //将'\n'删除
                    buf.pop();
                    if buf.ends_with('\r') {
                        //将'\r'删除
                        buf.pop();
                    }
                }
                Some(Ok(buf))
            }
            Err(e) =&gt; Some(Err(e)),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>利用缓存从IO输入源读取数据时，RUST专门设计了ReadBuf的类型结构：
对于不同的数据，可能设计不同的缓存结构，BufReader仅仅是其中的一种。<br />
但从输入源读入到缓存涉及的数据基本是固定不变的，即要读入的字节切片，字节切片已经读入的字节数，及RUST语法带来的字节切片中已经初始化的字节数，因此设计了ReadBuf以完成缓存读入的抽象类型结构体。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/readbuf.rs
pub struct ReadBuf&lt;'a&gt; {
    //用作缓存的内存块切片引用，由
    //外部的缓存类型提供，此块内存
    //第一次总是MaybeUninit
    buf: &amp;'a mut [MaybeUninit&lt;u8&gt;],
    //已经读入的数据，buf[0..filled]是读入的数据
    filled: usize,
    //已经assume_init的数据,buf[0..initialized]
    //是初始化过的数据
    //代码中需要保证filled应该小于initialized
    initialized: usize,
}

impl&lt;'a&gt; ReadBuf&lt;'a&gt; {
    //用一个已经初始化的内存块创建一个ReadBuf，
    //此内存块应该已经初始化完毕
    pub fn new(buf: &amp;'a mut [u8]) -&gt; ReadBuf&lt;'a&gt; {
        let len = buf.len();

        ReadBuf {
            //强制转换为[MaybeUninit&lt;u8&gt;]类型
            buf: unsafe { (buf as *mut [u8]).as_uninit_slice_mut().unwrap() },
            //没有读入数据
            filled: 0,
            //此buf实际上已经初始化
            initialized: len,
        }
    }

    //用未初始化的内存块创建ReadBuf
    pub fn uninit(buf: &amp;'a mut [MaybeUninit&lt;u8&gt;]) -&gt; ReadBuf&lt;'a&gt; {
        ReadBuf { buf, filled: 0, initialized: 0 }
    }

    pub fn capacity(&amp;self) -&gt; usize {
        self.buf.len()
    }

    //返回已经读到的字节切片引用
    pub fn filled(&amp;self) -&gt; &amp;[u8] {
        unsafe { MaybeUninit::slice_assume_init_ref(&amp;self.buf[0..self.filled]) }
    }

    //返回已经读到的字节切片可变引用
    pub fn filled_mut(&amp;mut self) -&gt; &amp;mut [u8] {
        unsafe { MaybeUninit::slice_assume_init_mut(&amp;mut self.buf[0..self.filled]) }
    }

    //返回已经初始化的字节切片引用
    pub fn initialized(&amp;self) -&gt; &amp;[u8] {
        unsafe { MaybeUninit::slice_assume_init_ref(&amp;self.buf[0..self.initialized]) }
    }

    //返回已经初始化的字节切片可变引用
    pub fn initialized_mut(&amp;mut self) -&gt; &amp;mut [u8] {
        unsafe { MaybeUninit::slice_assume_init_mut(&amp;mut self.buf[0..self.initialized]) }
    }

    //返回没有读入字节的缓存部分的可变引用切片
    pub unsafe fn unfilled_mut(&amp;mut self) -&gt; &amp;mut [MaybeUninit&lt;u8&gt;] {
        &amp;mut self.buf[self.filled..]
    }

    //返回没有做assume_init的缓存部分的可变引用切片
    pub fn uninitialized_mut(&amp;mut self) -&gt; &amp;mut [MaybeUninit&lt;u8&gt;] {
        &amp;mut self.buf[self.initialized..]
    }

    //对所有的未读入字节的缓存做assume_init
    pub fn initialize_unfilled(&amp;mut self) -&gt; &amp;mut [u8] {
        self.initialize_unfilled_to(self.remaining())
    }

    //从未读到字节的起始字节开始设置若干个字节assume_init
    pub fn initialize_unfilled_to(&amp;mut self, n: usize) -&gt; &amp;mut [u8] {
        assert!(self.remaining() &gt;= n);

        //获取没有读入内容却已经初始化的字节数
        let extra_init = self.initialized - self.filled;
        //判断是否需要额外做初始化
        if n &gt; extra_init {
            //获取需要初始化的字节数
            let uninit = n - extra_init;
            //获取需要初始化的字节切片
            let unfilled = &amp;mut self.uninitialized_mut()[0..uninit];

            //完成初始化为0
            for byte in unfilled.iter_mut() {
                byte.write(0);
            }

            unsafe {
                //设置为已经初始化
                self.assume_init(n);
            }
        }

        let filled = self.filled;

        //返回初始化但没有读到内容的字节切片
        &amp;mut self.initialized_mut()[filled..filled + n]
    }

    //空闲的字节数目
    pub fn remaining(&amp;self) -&gt; usize {
        self.capacity() - self.filled
    }

    //清除已读的内容，仅需要设置filled数值即可
    pub fn clear(&amp;mut self) {
        self.set_filled(0); // The assertion in `set_filled` is optimized out
    }

    //增加已读内容字节数
    pub fn add_filled(&amp;mut self, n: usize) {
        self.set_filled(self.filled + n);
    }

    //设置已经读入内容的字节数
    pub fn set_filled(&amp;mut self, n: usize) {
        assert!(n &lt;= self.initialized);

        self.filled = n;
    }

    //设置已经初始化的字节数目
    pub unsafe fn assume_init(&amp;mut self, n: usize) {
        self.initialized = cmp::max(self.initialized, self.filled + n);
    }

    //将内容拷贝入已读内容之后作为新读入的内容
    pub fn append(&amp;mut self, buf: &amp;[u8]) {
        assert!(self.remaining() &gt;= buf.len());

        unsafe {
            //需要用MaybeUninit的方法来完成内容更新
            MaybeUninit::write_slice(&amp;mut self.unfilled_mut()[..buf.len()], buf);
        }

        //更新初始化的字节数及读入内容的字节数
        unsafe { self.assume_init(buf.len()) }
        self.add_filled(buf.len());
    }

    //获取filled参数
    pub fn filled_len(&amp;self) -&gt; usize {
        self.filled
    }

    //获取初始化的参数
    pub fn initialized_len(&amp;self) -&gt; usize {
        self.initialized
    }
}
<span class="boring">}</span></code></pre></pre>
<p>BufRead的基础方法，BufRead trait, Read trait实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/buffer/bufreader.rs
impl&lt;R&gt; BufReader&lt;R&gt; {
    //获取内部的输入源引用
    pub fn get_ref(&amp;self) -&gt; &amp;R {
        &amp;self.inner
    }

    //获取内部输入源的可变引用
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut R {
        &amp;mut self.inner
    }

    pub fn buffer(&amp;self) -&gt; &amp;[u8] {
        //将已经读入缓存，但未从缓存读出的内容以切片返回，且完成初始化操作
        unsafe { MaybeUninit::slice_assume_init_ref(&amp;self.buf[self.pos..self.cap]) }
    }

    //缓存内存空间大小
    pub fn capacity(&amp;self) -&gt; usize {
        self.buf.len()
    }

    //消费self并取出内部输入源
    pub fn into_inner(self) -&gt; R {
        self.inner
    }

    //丢弃已经读入缓存的内容,此处似乎用drop更符合rust
    //用discar实际上是类似C的方式了
    fn discard_buffer(&amp;mut self) {
        self.pos = 0;
        self.cap = 0;
    }
}

//为数据读入缓存设计的trait
impl&lt;R: Read&gt; BufRead for BufReader&lt;R&gt; {
    fn fill_buf(&amp;mut self) -&gt; io::Result&lt;&amp;[u8]&gt; {
        //判断缓存中是否还有未读的内容
        if self.pos &gt;= self.cap {
            //没有，则清理缓存，并从输入源读入新的内容
            debug_assert!(self.pos == self.cap);

            //利用self.buf创建ReadBuf类型结构体变量完成读
            let mut readbuf = ReadBuf::uninit(&amp;mut self.buf);

            unsafe {
                //传递buf中已经assmue_init过的字节数
                readbuf.assume_init(self.init);
            }

            //调用输入源IO对象的read_buf完成缓存读
            self.inner.read_buf(&amp;mut readbuf)?;

            //根据readbuf的参数修改self参数
            self.cap = readbuf.filled_len();
            self.init = readbuf.initialized_len();

            //更新初始位置
            self.pos = 0;
        }
        //返回缓存内的有效内容
        Ok(self.buffer())
    }

    //对已经从缓存读出的数据完成参数调整
    fn consume(&amp;mut self, amt: usize) {
        self.pos = cmp::min(self.pos + amt, self.cap);
    }
}

impl&lt;R: Read&gt; Read for BufReader&lt;R&gt; {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //判断缓存是否为空且要读出的数据长度大于缓存容量
        if self.pos == self.cap &amp;&amp; buf.len() &gt;= self.buf.len() {
            //是，将缓存参数复位
            self.discard_buffer();
            //旁路缓存，直接将数据读入参数中的buf
            return self.inner.read(buf);
        }
        //缓存内有数据，或者要读出的数据长度小于缓存容量
        let nread = {
            //先填充缓存
            let mut rem = self.fill_buf()?;
            //实质是&amp;[u8] as Read::read(buf)，
            rem.read(buf)?
        };
        //调整参数反应已经从缓存读出的字节数
        self.consume(nread);
        Ok(nread)
    }

    fn read_buf(&amp;mut self, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; io::Result&lt;()&gt; {
        //见read的逻辑
        if self.pos == self.cap &amp;&amp; buf.remaining() &gt;= self.buf.len() {
            self.discard_buffer();
            return self.inner.read_buf(buf);
        }

        //获取原有的已读字节
        let prev = buf.filled_len();

        //填充缓存
        let mut rem = self.fill_buf()?;
        //&amp;[u8] as Read::read_buf()
        rem.read_buf(buf)?;

        //获得本次读的字节数，更新参数
        self.consume(buf.filled_len() - prev); //slice impl of read_buf known to never unfill buf

        Ok(())
    }

    //精确读取给定长度的内容
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;()&gt; {
        //判断缓存中是否已经有足够的已读字节
        if self.buffer().len() &gt;= buf.len() {
            //有，从缓存拷贝到buf
            buf.copy_from_slice(&amp;self.buffer()[..buf.len()]);
            //调整本身参数
            self.consume(buf.len());
            return Ok(());
        }

        //没有，用默认精确读
        crate::io::default_read_exact(self, buf)
    }

    //向量读方法
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        //获取总体要读的字节数
        let total_len = bufs.iter().map(|b| b.len()).sum::&lt;usize&gt;();
        //判断缓存是否为空,且读取总字节数大于缓存长度
        if self.pos == self.cap &amp;&amp; total_len &gt;= self.buf.len() {
            //清空缓存
            self.discard_buffer();
            //直接读入参数给出的buf
            return self.inner.read_vectored(bufs);
        }
        //缓存不为空或读取总长度小于缓存长度
        let nread = {
            //填充缓存
            let mut rem = self.fill_buf()?;
            //&amp;[u8]::read_vectored
            rem.read_vectored(bufs)?
        };
        //更新缓存参数
        self.consume(nread);
        Ok(nread)
    }

    fn is_read_vectored(&amp;self) -&gt; bool {
        self.inner.is_read_vectored()
    }

    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; {
        //先将缓存内容读到buf中
        let nread = self.cap - self.pos;
        buf.extend_from_slice(&amp;self.buffer());
        //清空缓存
        self.discard_buffer();
        //再将内部输入源的内容全部读出到输入的buf中，
        //返回本次操作的总长度
        Ok(nread + self.inner.read_to_end(buf)?)
    }

    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; {
        //判断是否为空字符串
        if buf.is_empty() {
            //空字符串，则直接用append_to_string完成即可
            unsafe { crate::io::append_to_string(buf, |b| self.read_to_end(b)) }
        } else {
            //不是空字符串
            //先将内容读入创建的缓存中
            let mut bytes = Vec::new();
            self.read_to_end(&amp;mut bytes)?;
            //从缓存生成字符串,并连接到输入字符串尾部
            let string = crate::str::from_utf8(&amp;bytes).map_err(|_| {
                io::const_io_error!(
                    io::ErrorKind::InvalidData,
                    &quot;stream did not contain valid UTF-8&quot;,
                )
            })?;
            *buf += string;
            Ok(string.len())
        }
    }
}

//Seek trait的实现
impl&lt;R: Seek&gt; Seek for BufReader&lt;R&gt; {
    fn seek(&amp;mut self, pos: SeekFrom) -&gt; io::Result&lt;u64&gt; {
        let result: u64;
        if let SeekFrom::Current(n) = pos {
            //从当前位置偏移
            //获取剩余未读的字节数
            let remainder = (self.cap - self.pos) as i64;
            
            //如果偏移字节大于缓存内未读的字节 
            if let Some(offset) = n.checked_sub(remainder) {
                //需要对输入源进行偏移
                result = self.inner.seek(SeekFrom::Current(offset))?;
            } else {
                //偏移字节小于缓存内未读的字节
                //此时需要将缓存内已读的字节清空，
                self.inner.seek(SeekFrom::Current(-remainder))?;
                self.discard_buffer();
                //将输入源偏移到新的位置
                result = self.inner.seek(SeekFrom::Current(n))?;
            }
        } else {
            //不是从当前位置偏移，则直接在输入源做偏移
            result = self.inner.seek(pos)?;
        }
        //偏移后需要清空缓存
        self.discard_buffer();
        Ok(result)
    }

    fn stream_position(&amp;mut self) -&gt; io::Result&lt;u64&gt; {
        //获得未被读出的字节数
        let remainder = (self.cap - self.pos) as u64;
        //从底层IO对象获得当前位置，再减掉未被读出的字节
        self.inner.stream_position().map(|pos| {
            pos.checked_sub(remainder).expect(
                &quot;overflow when subtracting remaining buffer size from inner stream position&quot;,
            )
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上涉及的一些支持函数代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/mod.rs
//Read trait精确读若干字节的默认实现。精确读的例子是处理有总长度字段的协议包头。只有读出包头才能知道整个数据包的长度
//因此一般先读一个固定长度的数据包报文头
pub(crate) fn default_read_exact&lt;R: Read + ?Sized&gt;(this: &amp;mut R, mut buf: &amp;mut [u8]) -&gt; Result&lt;()&gt; {
    //循环直到读到要求的字节数目
    while !buf.is_empty() {
        match this.read(buf) {
            //输入源已经没有内容
            Ok(0) =&gt; break,
            //根据读到的内容更新buf
            Ok(n) =&gt; {
                //这个交换是比较经典的编码技巧
                let tmp = buf;
                buf = &amp;mut tmp[n..];
            }
            //如果是操作系统的原因造成中断，则继续循环
            Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
            //其他错误返回
            Err(e) =&gt; return Err(e),
        }
    }
    //判断是否读到字节数目
    if !buf.is_empty() {
        //否，仅因为输入源已经没有内容的错误
        Err(error::const_io_error!(ErrorKind::UnexpectedEof, &quot;failed to fill whole buffer&quot;))
    } else {
        Ok(())
    }
}

//Read trait中read_buf的默认函数
pub(crate) fn default_read_buf&lt;F&gt;(read: F, buf: &amp;mut ReadBuf&lt;'_&gt;) -&gt; Result&lt;()&gt;
where
    F: FnOnce(&amp;mut [u8]) -&gt; Result&lt;usize&gt;,
{
    //对buf中没读入的空间先全部初始化，然后做读操作
    let n = read(buf.initialize_unfilled())?;
    //根据读入字节更新ReadBuf参数
    buf.add_filled(n);
    Ok(())
}

//Read trait中默认的read_to_end的方法实现
pub(crate) fn default_read_to_end&lt;R: Read + ?Sized&gt;(r: &amp;mut R, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; {
    let start_len = buf.len();
    let start_cap = buf.capacity();

    //初始化但没有读入内容的字节数为0
    let mut initialized = 0; // Extra initialized bytes from previous loop iteration
    loop {
        if buf.len() == buf.capacity() {
            //buf已经没有空间，
            //对buf进行扩充
            buf.reserve(32); // buf is full, need more space
        }

        //将buf中没有填充内容的部分生成切片，并创建ReadBuf
        let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());

        // 将read_buf的参数设置正确
        unsafe {
            //设置ReadBuf的初始化字节数
            read_buf.assume_init(initialized);
        }

        //调用输入源的read_buf读入内容
        match r.read_buf(&amp;mut read_buf) {
            Ok(()) =&gt; {}
            //操作系统的原因中断，继续循环
            Err(e) if e.kind() == ErrorKind::Interrupted =&gt; continue,
            //出错则返回
            Err(e) =&gt; return Err(e),
        }

        //判断输入源是否已经全部被读入
        if read_buf.filled_len() == 0 {
            //已经全部读入，则返回
            return Ok(buf.len() - start_len);
        }

        //输入源仍然可能有数据没有被读入
        //根据ReadBuf更新已经初始化但没有读入内容的字节数
        initialized = read_buf.initialized_len() - read_buf.filled_len();
        //根据读入字节的数目修改Vec的参数
        let new_len = read_buf.filled_len() + buf.len();

        unsafe {
            //设置Vec的参数反应已经读入的内容
            buf.set_len(new_len);
        }

        //前面最多只能读到buf.capacity()
        //判断初始传入的buf是否已经读满
        if buf.len() == buf.capacity() &amp;&amp; buf.capacity() == start_cap {
            let mut probe = [0u8; 32];

            loop {
                //每次循环最多读取32个字节的额外内容
                match r.read(&amp;mut probe) {
                    //输入源已经没有内容
                    Ok(0) =&gt; return Ok(buf.len() - start_len),
                    //输入源还有内容
                    Ok(n) =&gt; {
                        //对buf做扩展并放置新的内容
                        buf.extend_from_slice(&amp;probe[..n]);
                        //重新进入上级循环
                        break;
                    }
                    Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; continue,
                    Err(e) =&gt; return Err(e),
                }
            }
        }
    }
}

//Read trait的默认read_to_string的函数
pub(crate) fn default_read_to_string&lt;R: Read + ?Sized&gt;(
    r: &amp;mut R,
    buf: &amp;mut String,
) -&gt; Result&lt;usize&gt; {
    //对读入做是否为字符的判断，并且在判断非字符的时候将String恢复为初始值
    unsafe { append_to_string(buf, |b| default_read_to_end(r, b)) }
}

//上个函数的支持函数
pub(crate) unsafe fn append_to_string&lt;F&gt;(buf: &amp;mut String, f: F) -&gt; Result&lt;usize&gt;
where
    F: FnOnce(&amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt;,
{
    //利用Guard保证错误处理
    let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };
    //对g.buf做更新
    let ret = f(g.buf);
    //对g.buf新增的内容判断是否为字符串
    if str::from_utf8(&amp;g.buf[g.len..]).is_err() {
        //不是字符串,返回错误
        ret.and_then(|_| {
            Err(error::const_io_error!(
                ErrorKind::InvalidData,
                &quot;stream did not contain valid UTF-8&quot;
            ))
        })
        //此处用Guard的结构保证了g.buf会被恢复成输入时的状态 
    } else {
        //是字符串，对g做更新，返回读到的字节数
        g.len = g.buf.len();
        ret
    }
    //Guard保证了buf里面内容的正确，但有些不够直接
}
//上面函数的Guard相关内容
//这个结构是为了使用drop
struct Guard&lt;'a&gt; {
    buf: &amp;'a mut Vec&lt;u8&gt;,
    len: usize,
}

impl Drop for Guard&lt;'_&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            //对buf的len做修改
            self.buf.set_len(self.len);
        }
    }
}

//直接从输入源内容创建String，
pub fn read_to_string&lt;R: Read&gt;(mut reader: R) -&gt; Result&lt;String&gt; {
    let mut buf = String::new();
    reader.read_to_string(&amp;mut buf)?;
    Ok(buf)
}
//操作系统不支持向量读写的方式时的默认实现
//用输入源提供的read来实现
pub(crate) fn default_read_vectored&lt;F&gt;(read: F, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize&gt;
where
    F: FnOnce(&amp;mut [u8]) -&gt; Result&lt;usize&gt;,
{
    //[]实际上是[u8;0]
    let buf = bufs.iter_mut().find(|b| !b.is_empty()).map_or(&amp;mut [][..], |b| &amp;mut **b);
    read(buf)
}
<span class="boring">}</span></code></pre></pre>
<p>以上完成了所有RUST的对外类型结构Stdin的相关类型的代码分析。现在回到Stdin本身：
再次看一下Stdin的类型结构的相关实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/stdio.rs
//RUST的对外的标准输入结构
pub struct Stdin {
    inner: &amp;'static Mutex&lt;BufReader&lt;StdinRaw&gt;&gt;,
}

//Stdin的Mutex.lock返回的借用类型结构
pub struct StdinLock&lt;'a&gt; {
    inner: MutexGuard&lt;'a, BufReader&lt;StdinRaw&gt;&gt;,
}

//获取标准输入
pub fn stdin() -&gt; Stdin {
    //在本文写作的时候SyncOnceCell已经改为OnceLock
    //但内容基本没有变化，SyncOnceCell是适配在多线程的情况下只完成
    //一次初始化的类型结构，是OnceCell的线程安全版本
    //INSTANCE保证一个进程内只有一个Stdin变量被初始化
    static INSTANCE: SyncOnceCell&lt;Mutex&lt;BufReader&lt;StdinRaw&gt;&gt;&gt; = SyncOnceCell::new();
    Stdin {
        //如果未初始化，则进行初始化，如果已经初始化，则获取Mutex的引用
        //并返回基于此引用创建的Stdin变量
        inner: INSTANCE.get_or_init(|| {
            Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin_raw()))
        }),
    }
}

impl Stdin {
    pub fn lock(&amp;self) -&gt; StdinLock&lt;'static&gt; {
        //对标准输入上锁，并获取临界变量
        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }
    }

    pub fn read_line(&amp;self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; {
        //StdinLock的适配器实现,见下面分析
        self.lock().read_line(buf)
    }

    //返回一个每次读入一行的迭代器
    pub fn lines(self) -&gt; Lines&lt;StdinLock&lt;'static&gt;&gt; {
        //StdinLock的适配器实现
        self.lock().lines()
    }
}

//实现Read trait,即StdinLock的适配器实现
impl Read for Stdin {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //直接是BufReader.read
        self.lock().read(buf)
    }
    
    //以下与read的实现类似，函数体略
    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt;;
    fn is_read_vectored(&amp;self) -&gt; bool;
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt;; 
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; ;
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;()&gt; ;
}

//Mutex加锁后的返回
impl StdinLock&lt;'_&gt; {
    pub(crate) fn as_mut_buf(&amp;mut self) -&gt; &amp;mut BufReader&lt;impl Read&gt; {
        &amp;mut self.inner
    }
}

//以下是BufReader的Read trait的适配实现
impl Read for StdinLock&lt;'_&gt; {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //BufReader::read
        self.inner.read(buf)
    }

    //以下实现与read的实现形式基本类似，函数体略

    fn read_vectored(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt;;
    fn is_read_vectored(&amp;self) -&gt; bool;
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; ;
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; ;
    fn read_exact(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;()&gt; ;
}

//以下是BufReader的BufRead trait的适配实现
impl BufRead for StdinLock&lt;'_&gt; {
    //以下函数体略
    fn fill_buf(&amp;mut self) -&gt; io::Result&lt;&amp;[u8]&gt; ;
    fn consume(&amp;mut self, n: usize) ;
    fn read_until(&amp;mut self, byte: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; io::Result&lt;usize&gt; ;
    fn read_line(&amp;mut self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt; ;
}
<span class="boring">}</span></code></pre></pre>
<p>常用函数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//直接将输入源读入一个string
pub fn read_to_string&lt;R: Read&gt;(mut reader: R) -&gt; Result&lt;String&gt; {
    let mut buf = String::new();
    reader.read_to_string(&amp;mut buf)?;
    Ok(buf)
}
<span class="boring">}</span></code></pre></pre>
<p>一些其他的支持实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//标准输入/输出/错误不能形成OwnedFd, 但可以通过借用
//生成BorrowedFd
impl AsFd for io::Stdin {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        unsafe { BorrowedFd::borrow_raw(libc::STDIN_FILENO) }
    }
}

impl&lt;'a&gt; AsFd for io::StdinLock&lt;'a&gt; {
    fn as_fd(&amp;self) -&gt; BorrowedFd&lt;'_&gt; {
        unsafe { BorrowedFd::borrow_raw(libc::STDIN_FILENO) }
    }
}

//针对字节切片的Read trait实现
impl Read for &amp;[u8] {
    //本质上是完成两个字节数组的拷贝，
    //完成了字节数组的长度处理
    //函数执行后，self会更新反应内容已经读出
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
        //长度小的作为拷贝长度
        let amt = cmp::min(buf.len(), self.len());
        //将本身依据拷贝长度分成两个部分
        let (a, b) = self.split_at(amt);

        if amt == 1 {
            //提高效率
            buf[0] = a[0];
        } else {
            //将self拷贝到buf
            buf[..amt].copy_from_slice(a);
        }

        //更新self，此处易忽略
        *self = b;
        Ok(amt)
    }

    ...
    ...
}

<span class="boring">}</span></code></pre></pre>
<p>标准输入使用的代码例如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stdin = stdio::stdin();
let mut first_string = read_to_string(stdin);
let line = stdin.read_line(first_string);
<span class="boring">}</span></code></pre></pre>
<p>linux的向量读写相关类型结构:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/sys/unix/io.rs
//libc中的iovec的RUST封装,
//iovec用于多个缓存在一次读操作或写操作完成,
//减少将多个缓存移动到一个缓存造成的性能下降
//IoSlice通常用于写
//内存中IoSlice等同于iovec
#[repr(transparent)]
pub struct IoSlice&lt;'a&gt; {
    //libc中用于io读写的结构
    vec: iovec,
    //拥有读写的buf的所有权
    _p: PhantomData&lt;&amp;'a [u8]&gt;,
}

impl&lt;'a&gt; IoSlice&lt;'a&gt; {
    //简化libc中的iovec的结构生成代码
    pub fn new(buf: &amp;'a [u8]) -&gt; IoSlice&lt;'a&gt; {
        IoSlice {
            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },
            _p: PhantomData,
        }
    }

    //向前至还未使用的buf的第一个字节
    pub fn advance(&amp;mut self, n: usize) {
        if self.vec.iov_len &lt; n {
            panic!(&quot;advancing IoSlice beyond its length&quot;);
        }

        unsafe {
            //调整iovec参数
            self.vec.iov_len -= n;
            self.vec.iov_base = self.vec.iov_base.add(n);
        }
    }

    //生成读写的缓存buf
    pub fn as_slice(&amp;self) -&gt; &amp;[u8] {
        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }
    }
}

//通常应用于读入
pub struct IoSliceMut&lt;'a&gt; {
    vec: iovec,
    _p: PhantomData&lt;&amp;'a mut [u8]&gt;,
}

//见IoSlice的相关结构的分析
impl&lt;'a&gt; IoSliceMut&lt;'a&gt; {
    pub fn new(buf: &amp;'a mut [u8]) -&gt; IoSliceMut&lt;'a&gt; {
        IoSliceMut {
            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },
            _p: PhantomData,
        }
    }

    pub fn advance(&amp;mut self, n: usize) {
        if self.vec.iov_len &lt; n {
            panic!(&quot;advancing IoSliceMut beyond its length&quot;);
        }

        unsafe {
            self.vec.iov_len -= n;
            self.vec.iov_base = self.vec.iov_base.add(n);
        }
    }

    pub fn as_slice(&amp;self) -&gt; &amp;[u8] {
        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }
    }

    pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [u8] {
        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }
    }
}

//IoSlice/IoSliceMut的使用如下
impl FileDesc {
    ...

    //一次读入多个buf
    pub fn read_vectored(&amp;self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        let ret = cvt(unsafe {
            libc::readv(
                self.as_raw_fd(),
                bufs.as_ptr() as *const libc::iovec,
                cmp::min(bufs.len(), max_iov()) as c_int,
            )
        })?;
        Ok(ret as usize)
    }

    //一次写入多个buf
    pub fn write_vectored(&amp;self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        let ret = cvt(unsafe {
            libc::writev(
                self.as_raw_fd(),
                bufs.as_ptr() as *const libc::iovec,
                cmp::min(bufs.len(), max_iov()) as c_int,
            )
        })?;
        Ok(ret as usize)
    }
    ...
}

//RUST对linux向量读写的扩展
//直接对操作系统的基础类型结构封装
pub struct IoSliceMut&lt;'a&gt;(sys::io::IoSliceMut&lt;'a&gt;);

unsafe impl&lt;'a&gt; Send for IoSliceMut&lt;'a&gt; {}
unsafe impl&lt;'a&gt; Sync for IoSliceMut&lt;'a&gt; {}


impl&lt;'a&gt; IoSliceMut&lt;'a&gt; {
    //见上面的linux的IoSliceMut的分析
    pub fn new(buf: &amp;'a mut [u8]) -&gt; IoSliceMut&lt;'a&gt; {
        IoSliceMut(sys::io::IoSliceMut::new(buf))
    }

    //见上面的linux的IoSliceMut的分析
    pub fn advance(&amp;mut self, n: usize) {
        self.0.advance(n)
    }

    pub fn advance_slices(bufs: &amp;mut &amp;mut [IoSliceMut&lt;'a&gt;], n: usize) {
        // 需要前移的IoSliceMut成员数目
        let mut remove = 0;
        // 计算前移的总体字节数
        let mut accumulated_len = 0;
        for buf in bufs.iter() {
            //是否应该前移到此成员
            if accumulated_len + buf.len() &gt; n {
                //找到
                break;
            } else {
                //否，找下一个
                accumulated_len += buf.len();
                remove += 1;
            }
        }

        //此处的逻辑是：
        //必须获得&amp;mut [IoSliceMut]的所有权，但不能用 = *bufs的方式实现
        //此时只能用replace来完成
        //要获得*bufs的所有权，只能用replace的方法，
        *bufs = &amp;mut replace(bufs, &amp;mut [])[remove..];
        if !bufs.is_empty() {
            bufs[0].advance(n - accumulated_len)
        }
    }
}

impl&lt;'a&gt; Deref for IoSliceMut&lt;'a&gt; {
    type Target = [u8];

    fn deref(&amp;self) -&gt; &amp;[u8] {
        self.0.as_slice()
    }
}

impl&lt;'a&gt; DerefMut for IoSliceMut&lt;'a&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [u8] {
        self.0.as_mut_slice()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上是Stdin相关的IO类型结构及其函数，方法</p>
<h2 id="rust标准库stdout代码分析"><a class="header" href="#rust标准库stdout代码分析">RUST标准库Stdout代码分析</a></h2>
<p>RUST实现了线程安全的标准输入类型结构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Stdout {
    //可重入的内部可变性类型
    //LineWriter是缓存类型结构
    inner: Pin&lt;&amp;'static ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>ReentrantMutex&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>请参考前文
原始的标准输出目的IO对象类型StdoutRaw定义相关代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//linux系统的标准输出的类型结构
//因为标准输出的文件描述符不必关闭，
//所以此处用了单元类型
//路径: library/std/src/sys/unix/stdio.rs
pub struct Stdout(());

impl Stdout {
    //创建函数
    pub const fn new() -&gt; Stdout {
        Stdout(())
    }
}

//RUST对操作系统的扩展
//路径: library/std/src/io/stdio.rs
//此处stdio是sys::stdio
struct StdoutRaw(stdio::Stdout); 

//StdoutRaw的工厂函数
const fn stdout_raw() -&gt; StdoutRaw {
    StdoutRaw(stdio::Stdout::new())
}
<span class="boring">}</span></code></pre></pre>
<p>RUST专门为行输出设计的缓存类型IO类型结构<code>LineWriter&lt;W&gt;</code>定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//LineWriter是BufWriter的一个adapter
//针对行输出做出优化
pub struct LineWriter&lt;W: Write&gt; {
    inner: BufWriter&lt;W&gt;,
}

//输出缓存类型结构
pub struct BufWriter&lt;W: Write&gt; {
    //输出目的IO对象类型结构变量
    //本结构体拥有其所有权
    inner: W,
    //缓存
    buf: Vec&lt;u8&gt;,
    //是否在输出的过程中出现线程panic
    panicked: bool,
}
//BufWriter创建函数
impl&lt;W: Write&gt; BufWriter&lt;W&gt; {
    //基于输出目的IO对象变量创建缓存
    pub fn new(inner: W) -&gt; BufWriter&lt;W&gt; {
        //DEFAULT_BUF_SIZE是8*1024
        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)
    }

    //创建指定容量的BufWriter
    pub fn with_capacity(capacity: usize, inner: W) -&gt; BufWriter&lt;W&gt; {
        BufWriter { inner, buf: Vec::with_capacity(capacity), panicked: false }
    }
    ...
}
//LineWriter的创建函数
impl&lt;W: Write&gt; LineWriter&lt;W&gt; {
    pub fn new(inner: W) -&gt; LineWriter&lt;W&gt; {
        //创建一个缓存为1024的LineWriter
        LineWriter::with_capacity(1024, inner)
    }

    //创建指定容量的LineWriter
    pub fn with_capacity(capacity: usize, inner: W) -&gt; LineWriter&lt;W&gt; {
        //指定内部的BufWriter的容量
        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>所有的输出IO对象类型都必须实现Write trait,定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Write {
    //将buf写入输出目的，返回写入的字节数
    //此写操作可能阻塞，或返回错误，
    //此函数完成后，输出可能保存在操作系统的缓存中
    //需要调用flush才能确保真正的完成输出
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;

    //以向量的形式写
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize&gt; {
        //默认不支持向量，使用write方法来进行模拟
        default_write_vectored(|b| self.write(b), bufs)
    }

    //是否支持向量写
    fn is_write_vectored(&amp;self) -&gt; bool {
        false
    }

    //确保缓存内的输出已经输出到输出目的
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    //确保缓存内的所有内容都已经写入输出目的
    fn write_all(&amp;mut self, mut buf: &amp;[u8]) -&gt; Result&lt;()&gt; {
        //主要因为单次write可能会在没有写完时返回
        //所以循环以确保写完后再返回
        while !buf.is_empty() {
            match self.write(buf) {
                //写入0字节代表未知错误
                Ok(0) =&gt; {
                    return Err(error::const_io_error!(
                        ErrorKind::WriteZero,
                        &quot;failed to write whole buffer&quot;,
                    ));
                }
                //写入n字节，则调整未写入的缓存
                Ok(n) =&gt; buf = &amp;buf[n..],
                //被中断打断的错误继续做循环
                Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
                //其他错误返回
                Err(e) =&gt; return Err(e),
            }
        }
        //已经写入了缓存的所有内容
        Ok(())
    }

    //vetor的write_all版本
    fn write_all_vectored(&amp;mut self, mut bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;()&gt; {
        //确保vector中有内容
        IoSlice::advance_slices(&amp;mut bufs, 0);
        //循环防止单次写入被中断
        while !bufs.is_empty() {
            match self.write_vectored(bufs) {
                Ok(0) =&gt; {
                    return Err(error::const_io_error!(
                        ErrorKind::WriteZero,
                        &quot;failed to write whole buffer&quot;,
                    ));
                }
                //写入则调整未写入的vetor
                Ok(n) =&gt; IoSlice::advance_slices(&amp;mut bufs, n),
                Err(ref e) if e.kind() == ErrorKind::Interrupted =&gt; {}
                Err(e) =&gt; return Err(e),
            }
        }
        //已经完全写入
        Ok(())
    }

    //写入格式化内容
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        struct Adapter&lt;'a, T: ?Sized + 'a&gt; {
            inner: &amp;'a mut T,
            error: Result&lt;()&gt;,
        }

        impl&lt;T: Write + ?Sized&gt; fmt::Write for Adapter&lt;'_, T&gt; {
            fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
                match self.inner.write_all(s.as_bytes()) {
                    Ok(()) =&gt; Ok(()),
                    Err(e) =&gt; {
                        self.error = Err(e);
                        Err(fmt::Error)
                    }
                }
            }
        }

        let mut output = Adapter { inner: self, error: Ok(()) };
        //见“智能指针(四)”中关于fmt的章节
        match fmt::write(&amp;mut output, fmt) {
            Ok(()) =&gt; Ok(()),
            Err(..) =&gt; {
                // check if the error came from the underlying `Write` or not
                if output.error.is_err() {
                    output.error
                } else {
                    Err(error::const_io_error!(ErrorKind::Uncategorized, &quot;formatter error&quot;))
                }
            }
        }
    }

    //获取输入目的类型变量的引用
    fn by_ref(&amp;mut self) -&gt; &amp;mut Self
    where
        Self: Sized,
    {
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>io::sys::unix::Stdout的Write的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：library/std/src/sys/unix/stdio.rs
impl io::Write for Stdout {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        //标准输出文件不必关闭，因此不能调用FileDesc的drop
        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDOUT_FILENO)).write(buf) }
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        unsafe {
            ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDOUT_FILENO)).write_vectored(bufs)
        }
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        true
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>针对StdoutRaw的Read trait实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//即sys::Stdout的Write trait的adapter
impl Write for StdoutRaw {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        handle_ebadf(self.0.write(buf), buf.len())
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        let total = bufs.iter().map(|b| b.len()).sum();
        handle_ebadf(self.0.write_vectored(bufs), total)
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        self.0.is_write_vectored()
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        handle_ebadf(self.0.flush(), ())
    }

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        handle_ebadf(self.0.write_all(buf), ())
    }

    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;()&gt; {
        handle_ebadf(self.0.write_all_vectored(bufs), ())
    }

    fn write_fmt(&amp;mut self, fmt: fmt::Arguments&lt;'_&gt;) -&gt; io::Result&lt;()&gt; {
        handle_ebadf(self.0.write_fmt(fmt), ())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>BufWriter的相关实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;W: Write&gt; BufWriter&lt;W&gt; {
    //将缓存中的内容输出到内部的输入目的IO对象变量中,即使在调用此方法前，
    //缓存中的内容对调用者都被认为已经成功输出
    pub(in crate::io) fn flush_buf(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        struct BufGuard&lt;'a&gt; {
            //BufWriter中的buf
            buffer: &amp;'a mut Vec&lt;u8&gt;,
            //写入内部输出目的IO对象的字节数
            written: usize,
        }

        impl&lt;'a&gt; BufGuard&lt;'a&gt; {
            fn new(buffer: &amp;'a mut Vec&lt;u8&gt;) -&gt; Self {
                Self { buffer, written: 0 }
            }

            /// The unwritten part of the buffer
            fn remaining(&amp;self) -&gt; &amp;[u8] {
                &amp;self.buffer[self.written..]
            }

            /// 记录已经输出的字节数
            fn consume(&amp;mut self, amt: usize) {
                self.written += amt;
            }

            /// 是否所有的缓存数据都已经输出
            fn done(&amp;self) -&gt; bool {
                self.written &gt;= self.buffer.len()
            }
        }

        impl Drop for BufGuard&lt;'_&gt; {
            fn drop(&amp;mut self) {
                if self.written &gt; 0 {
                    //确保缓存删除已经输出的数据
                    self.buffer.drain(..self.written);
                }
            }
        }

        //利用BufGuard来更新self.buf
        let mut guard = BufGuard::new(&amp;mut self.buf);
        //缓存如果还有数据则一直循环
        while !guard.done() {
            //如果写的过程遇到线程panic，
            //此处提取做标记
            self.panicked = true;
            //调用内部输出目的对象完成写
            let r = self.inner.write(guard.remaining());
            //清除panic标记
            self.panicked = false;

            match r {
                //没有输出内容
                Ok(0) =&gt; {
                    //必须返回IO出错，因为缓存的内容已经被
                    //认为写成功
                    return Err(io::const_io_error!(
                        ErrorKind::WriteZero,
                        &quot;failed to write the buffered data&quot;,
                    ));
                }
                //buffer中需要反映已经写出的内容
                Ok(n) =&gt; guard.consume(n),
                Err(ref e) if e.kind() == io::ErrorKind::Interrupted =&gt; {}
                Err(e) =&gt; return Err(e),
            }
        }
        Ok(())
    }

    //将字节切片写入缓存
    pub(super) fn write_to_buf(&amp;mut self, buf: &amp;[u8]) -&gt; usize {
        //得到缓存空闲空间,并取空闲空间与切片长度小者
        let available = self.spare_capacity();
        let amt_to_buffer = available.min(buf.len());

        unsafe {
            //将字节切片写入缓存
            self.write_to_buffer_unchecked(&amp;buf[..amt_to_buffer]);
        }

        //返回写入字节
        amt_to_buffer
    }

    //获得内部输出目的对象的引用
    pub fn get_ref(&amp;self) -&gt; &amp;W {
        &amp;self.inner
    }

    //获得内部输出目的对象的可变引用
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut W {
        &amp;mut self.inner
    }

    //获得内部缓存的字节切片引用
    pub fn buffer(&amp;self) -&gt; &amp;[u8] {
        &amp;self.buf
    }

    //获得内部缓存的字节切片的可变引用
    pub(in crate::io) fn buffer_mut(&amp;mut self) -&gt; &amp;mut Vec&lt;u8&gt; {
        &amp;mut self.buf
    }

    //缓存总容量
    pub fn capacity(&amp;self) -&gt; usize {
        self.buf.capacity()
    }

    //消费self，获取内部输出目的IO对象
    pub fn into_inner(mut self) -&gt; Result&lt;W, IntoInnerError&lt;BufWriter&lt;W&gt;&gt;&gt; {
        //需要先将缓存内容全部输出
        match self.flush_buf() {
            Err(e) =&gt; Err(IntoInnerError::new(self, e)),
            //此处获得self.buf的所有权，然后生命周期终结
            Ok(()) =&gt; Ok(self.into_parts().0),
        }
    }

    //into_inner的支持方法，处理panic
    pub fn into_parts(mut self) -&gt; (W, Result&lt;Vec&lt;u8&gt;, WriterPanicked&gt;) {
        //获取self.buf的所有权
        let buf = mem::take(&amp;mut self.buf);
        //将buf所有权返回，由调用者处理
        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };

        //获取self.inner的所有权
        let inner = unsafe { ptr::read(&amp;mut self.inner) };
        //不调用self的drop，防止对self.inner的drop调用
        mem::forget(self);

        (inner, buf)
    }

    #[cold]
    #[inline(never)]
    fn write_cold(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        //判断输出是否大于缓存可用空间
        if buf.len() &gt; self.spare_capacity() {
            //大于，则先将缓存输出
            self.flush_buf()?;
        }

        //再次判断是否大于缓存空间
        if buf.len() &gt;= self.buf.capacity() {
            //大于,则直接输出到内部IO对象
            self.panicked = true;
            let r = self.get_mut().write(buf);
            self.panicked = false;
            r
        } else {
            //不大于，则输入到内部的缓存中
            unsafe {
                self.write_to_buffer_unchecked(buf);
            }

            Ok(buf.len())
        }
    }

    #[cold]
    #[inline(never)]
    fn write_all_cold(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        if buf.len() &gt; self.spare_capacity() {
            self.flush_buf()?;
        }

        if buf.len() &gt;= self.buf.capacity() {
            self.panicked = true;
            //直接调用的情况下必须用write_all
            let r = self.get_mut().write_all(buf);
            self.panicked = false;
            r
        } else {
            unsafe {
                self.write_to_buffer_unchecked(buf);
            }

            Ok(())
        }
    }

    unsafe fn write_to_buffer_unchecked(&amp;mut self, buf: &amp;[u8]) {
        debug_assert!(buf.len() &lt;= self.spare_capacity());
        //就是直接做拷贝
        let old_len = self.buf.len();
        let buf_len = buf.len();
        let src = buf.as_ptr();
        let dst = self.buf.as_mut_ptr().add(old_len);
        ptr::copy_nonoverlapping(src, dst, buf_len);
        //拷贝完毕后设置内部的buf参数
        self.buf.set_len(old_len + buf_len);
    }

    fn spare_capacity(&amp;self) -&gt; usize {
        //获取内部可用空间
        self.buf.capacity() - self.buf.len()
    }
}


//实现Write trait
impl&lt;W: Write&gt; Write for BufWriter&lt;W&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        //判断输出的字符切片长度是否小于缓存空间
        if buf.len() &lt; self.spare_capacity() {
            //小于，直接写入缓存
            unsafe {
                self.write_to_buffer_unchecked(buf);
            }

            Ok(buf.len())
        } else {
            //否则，调用write_cold
            self.write_cold(buf)
        }
    }

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        if buf.len() &lt; self.spare_capacity() {
            unsafe {
                self.write_to_buffer_unchecked(buf);
            }

            Ok(())
        } else {
            //调用write_all_code
            self.write_all_cold(buf)
        }
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        //判断内部IO对象是否支持向量写
        if self.get_ref().is_write_vectored() {
            //支持,
            // We have to handle the possibility that the total length of the buffers overflows
            // `usize` (even though this can only happen if multiple `IoSlice`s reference the
            // same underlying buffer, as otherwise the buffers wouldn't fit in memory). If the
            // computation overflows, then surely the input cannot fit in our buffer, so we forward
            // to the inner writer's `write_vectored` method to let it handle it appropriately.
            //获取总的字节长度
            let saturated_total_len =
                bufs.iter().fold(0usize, |acc, b| acc.saturating_add(b.len()));

            //总字节长度是否大于可用空间
            if saturated_total_len &gt; self.spare_capacity() {
                self.flush_buf()?;
            }

            //再次判断是否能用缓存
            if saturated_total_len &gt;= self.buf.capacity() {
                //不能，则直接用write_vectored输出
                self.panicked = true;
                let r = self.get_mut().write_vectored(bufs);
                self.panicked = false;
                r
            } else {
                //否则，将内容写入缓存
                unsafe {
                    bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));
                };

                Ok(saturated_total_len)
            }
        } else {
            //不支持向量写
            let mut iter = bufs.iter();
            //找到第一个不为空的IoSlice
            let mut total_written = if let Some(buf) = iter.by_ref().find(|&amp;buf| !buf.is_empty()) {
                if buf.len() &gt; self.spare_capacity() {
                    self.flush_buf()?;
                }
                if buf.len() &gt;= self.buf.capacity() {
                    // so it's better to write it directly, bypassing the buffer.
                    self.panicked = true;
                    let r = self.get_mut().write(buf);
                    self.panicked = false;
                    //return的情况下，不必保证两个分支
                    //类型一致
                    return r;
                } else {
                    unsafe {
                        //写入buf
                        self.write_to_buffer_unchecked(buf);
                    }

                    buf.len()
                }
            } else {
                return Ok(0);
            };
            debug_assert!(total_written != 0);
            //iter位置已经移动
            for buf in iter {
                //判断buf是否有足够空间
                if buf.len() &lt;= self.spare_capacity() {
                    unsafe {
                        self.write_to_buffer_unchecked(buf);
                    }

                    total_written += buf.len();
                } else {
                    //没有，则结束
                    break;
                }
            }
            //返回已经写入的总长度
            Ok(total_written)
        }
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        true
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        //先完成buf写入内部IO对象，再调用内部Io对象的flush方法。
        self.flush_buf().and_then(|()| self.get_mut().flush())
    }
}

//Seek trait实现
impl&lt;W: Write + Seek&gt; Seek for BufWriter&lt;W&gt; {
    fn seek(&amp;mut self, pos: SeekFrom) -&gt; io::Result&lt;u64&gt; {
        //先将缓存内容写入
        self.flush_buf()?;
        //再调用底层IO对象的seek
        self.get_mut().seek(pos)
    }
}

impl&lt;W: Write&gt; Drop for BufWriter&lt;W&gt; {
    fn drop(&amp;mut self) {
        if !self.panicked {
            //生命周期终止时将buf写入内部输出IO对象
            let _r = self.flush_buf();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>LineWrite的所有实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;W: Write&gt; LineWriter&lt;W&gt; {
    //获取内部IO对象的引用
    pub fn get_ref(&amp;self) -&gt; &amp;W {
        self.inner.get_ref()
    }

    //获取内部IO对象的可变引用
    pub fn get_mut(&amp;mut self) -&gt; &amp;mut W {
        self.inner.get_mut()
    }

    //消费掉self，获得内部IO对象的引用
    pub fn into_inner(self) -&gt; Result&lt;W, IntoInnerError&lt;LineWriter&lt;W&gt;&gt;&gt; {
        self.inner.into_inner().map_err(|err| err.new_wrapped(|inner| LineWriter { inner }))
    }
}

//Write trait实现， 对BufReader的Adapter
impl&lt;W: Write&gt; Write for LineWriter&lt;W&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        LineWriterShim::new(&amp;mut self.inner).write(buf)
    }

    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        self.inner.flush()
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        LineWriterShim::new(&amp;mut self.inner).write_vectored(bufs)
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        self.inner.is_write_vectored()
    }

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        LineWriterShim::new(&amp;mut self.inner).write_all(buf)
    }

    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;()&gt; {
        LineWriterShim::new(&amp;mut self.inner).write_all_vectored(bufs)
    }

    fn write_fmt(&amp;mut self, fmt: fmt::Arguments&lt;'_&gt;) -&gt; io::Result&lt;()&gt; {
        LineWriterShim::new(&amp;mut self.inner).write_fmt(fmt)
    }
}

//支持类型LineWriterShim
pub struct LineWriterShim&lt;'a, W: Write&gt; {
    buffer: &amp;'a mut BufWriter&lt;W&gt;,
}

impl&lt;'a, W: Write&gt; LineWriterShim&lt;'a, W&gt; {
    pub fn new(buffer: &amp;'a mut BufWriter&lt;W&gt;) -&gt; Self {
        Self { buffer }
    }

    fn inner(&amp;self) -&gt; &amp;W {
        self.buffer.get_ref()
    }

    fn inner_mut(&amp;mut self) -&gt; &amp;mut W {
        self.buffer.get_mut()
    }

    fn buffered(&amp;self) -&gt; &amp;[u8] {
        self.buffer.buffer()
    }

    fn flush_if_completed_line(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        //判断buf的尾部字符
        match self.buffered().last().copied() {
            //如果是行结束符，将缓存输出
            Some(b'\n') =&gt; self.buffer.flush_buf(),
            _ =&gt; Ok(()),
        }
    }
}

impl&lt;'a, W: Write&gt; Write for LineWriterShim&lt;'a, W&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        //查找buf中的分行符
        let newline_idx = match memchr::memrchr(b'\n', buf) {
            //没找到
            None =&gt; {
                //将buf中可能的行输出
                self.flush_if_completed_line()?;
                //将内容写入缓存
                return self.buffer.write(buf);
            }
            //找到，设置新行的启动位置
            Some(newline_idx) =&gt; newline_idx + 1,
        };

        //输出缓存内容
        self.buffer.flush_buf()?;

        //获取本行的内容
        let lines = &amp;buf[..newline_idx];

        //本行内容直接写入底层的IO对象
        let flushed = self.inner_mut().write(lines)?;

        //判断是否写入了内容
        if flushed == 0 {
            //没有写入，返回0
            return Ok(0);
        }

        //判断本行是否完全输出，tail为需要写入缓存的字节切片
        let tail = if flushed &gt;= newline_idx {
            //完全输出,tail为没有输出的字节切片
            &amp;buf[flushed..]
        } else if newline_idx - flushed &lt;= self.buffer.capacity() {
            //没有完全输出，且未输出的内容小于缓存容量
            //tail为本行没有输出的内容
            &amp;buf[flushed..newline_idx]
        } else {
            //没有完全输出，且未输出内容大于缓存容量
            //tail为本行缓存容量的字节切片
            let scan_area = &amp;buf[flushed..];
            let scan_area = &amp;scan_area[..self.buffer.capacity()];
            match memchr::memrchr(b'\n', scan_area) {
                Some(newline_idx) =&gt; &amp;scan_area[..newline_idx + 1],
                None =&gt; scan_area,
            }
        };

        //将tail写入缓存
        let buffered = self.buffer.write_to_buf(tail);
        Ok(flushed + buffered)
    }

    //adapter
    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        self.buffer.flush()
    }

    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; {
        //判断是否支持向量读写
        if !self.is_write_vectored() {
            //不支持，将第一个向量写入self并返回
            return match bufs.iter().find(|buf| !buf.is_empty()) {
                Some(buf) =&gt; self.write(buf),
                None =&gt; Ok(0),
            };
        }

        //找到buf中最后一个换行符
        //最后一个换行符前的数据都可以输出，
        //符合行输出的规则
        let last_newline_buf_idx = bufs
            .iter()
            .enumerate()
            .rev()
            .find_map(|(i, buf)| memchr::memchr(b'\n', buf).map(|_| i));

        
        let last_newline_buf_idx = match last_newline_buf_idx {
            //没有换行符 
            None =&gt; {
                //先输出可能的行
                self.flush_if_completed_line()?;
                //将bufs写入内部缓存
                return self.buffer.write_vectored(bufs);
            }
            //有，获得切片下标
            Some(i) =&gt; i,
        };

        //先将缓存已有内容输出
        self.buffer.flush_buf()?;

        //将切片分为带输出及存入缓存的两个部分
        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);

        //直接调用底层IO对象将内容输出,此处认为换行应该是IoSlice的尾部？
        let flushed = self.inner_mut().write_vectored(lines)?;

        //如果无法输出
        if flushed == 0 {
            //通知调用者
            return Ok(0);
        }

        //判断是否全部的slice都已经输出
        let lines_len = lines.iter().map(|buf| buf.len()).sum();
        if flushed &lt; lines_len {
            //没有，则返回输出长度
            return Ok(flushed);
        }

        //将剩余的内容写入缓存中
        let buffered: usize = tail
            .iter()
            .filter(|buf| !buf.is_empty())
            .map(|buf| self.buffer.write_to_buf(buf))
            .take_while(|&amp;n| n &gt; 0)
            .sum();

        Ok(flushed + buffered)
    }

    fn is_write_vectored(&amp;self) -&gt; bool {
        self.inner().is_write_vectored()
    }

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        match memchr::memrchr(b'\n', buf) {
            //没有换行符
            None =&gt; {
                //将buffer的行输出，然后将内容写入缓存
                self.flush_if_completed_line()?;
                self.buffer.write_all(buf)
            }
            //有换行符
            Some(newline_idx) =&gt; {
                //将换行符前的内容都输出，换行符后的内容写入缓存
                let (lines, tail) = buf.split_at(newline_idx + 1);

                if self.buffered().is_empty() {
                    self.inner_mut().write_all(lines)?;
                } else {
                    self.buffer.write_all(lines)?;
                    self.buffer.flush_buf()?;
                }

                self.buffer.write_all(tail)
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以上完成了所有RUST的对外类型结构Stdout的相关类型的代码分析。现在回到Stdout本身：
再次看一下Stdout的类型结构的相关实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径： library/std/src/io/stdio.rs
pub struct Stdout {
    //可重入的内部可变性类型
    //LineWriter是缓存类型结构
    inner: Pin&lt;&amp;'static ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;&gt;,
}
//Mutex返回的借用结构
pub struct StdoutLock&lt;'a&gt; {
    inner: ReentrantMutexGuard&lt;'a, RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;,
}

//保证Stdout在一个进程中只初始化一次
static STDOUT: SyncOnceCell&lt;ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;&gt; = SyncOnceCell::new();

pub fn stdout() -&gt; Stdout {
    Stdout {
        //如果没有初始化，则进行初始化，如果已经初始化，则加锁，获得引用
        //并构建Stdout
        inner: Pin::static_ref(&amp;STDOUT).get_or_init_pin(
            || unsafe { ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))) },
            |mutex| unsafe { mutex.init() },
        ),
    }
}

pub fn cleanup() {
    if let Some(instance) = STDOUT.get() {
        if let Some(lock) = Pin::static_ref(instance).try_lock() {
            //将前个LineWriter做drop操作
            //生成一个缓存空间为0的LineWriter
            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());
        }
    }
}

impl Stdout {
    //获得一个借用
    pub fn lock(&amp;self) -&gt; StdoutLock&lt;'static&gt; {
        //创建StdoutLock
        StdoutLock { inner: self.inner.lock() }
    }
}

//Write trait实现，
//是StdoutLock的adapter
//但是有一个线程安全操作
impl Write for &amp;Stdout {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        self.lock().write(buf)
    }
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; ;
    fn is_write_vectored(&amp;self) -&gt; bool ;
    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; ;
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; ;
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;()&gt; ;
    fn write_fmt(&amp;mut self, args: fmt::Arguments&lt;'_&gt;) -&gt; io::Result&lt;()&gt; ;
}

//LineWriter的adapter
impl Write for StdoutLock&lt;'_&gt; {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
        self.inner.borrow_mut().write(buf)
    }
    fn write_vectored(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;usize&gt; ;
    fn is_write_vectored(&amp;self) -&gt; bool ;
    fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; ;
    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; ;
    fn write_all_vectored(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; io::Result&lt;()&gt; ;
}
<span class="boring">}</span></code></pre></pre>
<p>Stderr与Stdout类似，请自行分析。</p>
<p>以下可以作为stdout的使用例。是测试时使用的线程局部信息输出流的实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//线程局部流
type LocalStream = Arc&lt;Mutex&lt;Vec&lt;u8&gt;&gt;&gt;;

//线程局部流定义
thread_local! {
    static OUTPUT_CAPTURE: Cell&lt;Option&lt;LocalStream&gt;&gt; = {
        Cell::new(None)
    }
}

//已经使用了OUTPUT_CAPTURE机制
static OUTPUT_CAPTURE_USED: AtomicBool = AtomicBool::new(false);

//设置输出的缓存
pub fn set_output_capture(sink: Option&lt;LocalStream&gt;) -&gt; Option&lt;LocalStream&gt; {
    if sink.is_none() &amp;&amp; !OUTPUT_CAPTURE_USED.load(Ordering::Relaxed) {
        // OUTPUT_CAPTURE is definitely None since OUTPUT_CAPTURE_USED is false.
        return None;
    }
    OUTPUT_CAPTURE_USED.store(true, Ordering::Relaxed);
    OUTPUT_CAPTURE.with(move |slot| slot.replace(sink))
}

//测试信息打印函数
fn print_to&lt;T&gt;(args: fmt::Arguments&lt;'_&gt;, global_s: fn() -&gt; T, label: &amp;str)
where
    T: Write,
{
    if OUTPUT_CAPTURE_USED.load(Ordering::Relaxed)
        &amp;&amp; OUTPUT_CAPTURE.try_with(|s| {
            s.take().map(|w| {
                let _ = w.lock().unwrap_or_else(|e| e.into_inner()).write_fmt(args);
                s.set(Some(w));
            })
        }) == Ok(Some(()))
    {
        // Successfully wrote to capture buffer.
        return;
    }

    if let Err(e) = global_s().write_fmt(args) {
        panic!(&quot;failed printing to {label}: {e}&quot;);
    }
}

//向标准输出打印
pub fn _print(args: fmt::Arguments&lt;'_&gt;) {
    print_to(args, stdout, &quot;stdout&quot;);
}
//向标准错误打印
pub fn _eprint(args: fmt::Arguments&lt;'_&gt;) {
    print_to(args, stderr, &quot;stderr&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="网络io"><a class="header" href="#网络io">网络IO</a></h2>
<p>因为异步编程成为网络IO的共识，而异步框架如tokio等对网络IO库做了重写，标准库中的网络IO显得不再那么重要，本书将省略网络IO的分析。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust异步编程"><a class="header" href="#rust异步编程">RUST异步编程</a></h1>
<p>协程编程目前已经逐步成为高并发，高性能编程的共识方案。语言或库对协程的支持使得程序员在编写多IO的程序时不必再去学习复杂的IO多路复用，以一种自然的直线思维方完成代码编写，但在运行时实际上使用IO多路复用的机制。协程机制将线程方案下的简单逻辑与IO多路复用的高性能巧妙融合在一起。<br />
RUST对协程的支持采用的方案是语言仅仅提供最基础的语法async/await，Future trait。其余则留给框架编程人员自由发挥。</p>
<h2 id="rust的协程"><a class="header" href="#rust的协程">RUST的协程</a></h2>
<p>RUST的协程的一个举例如下：</p>
<pre><pre class="playground"><code class="language-rust">use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).await?;

    loop {
        let (mut socket, _) = listener.accept().await?;
        
        //此处类似go的协程，对于每一个接收到的tcp连接
        //都可以spawn一个tokio的task完成对其的处理
        //此处的tokio的task
        tokio::spawn(async move {
            let mut buf = [0; 1024];

            
            loop {
                let n = match socket.read(&amp;mut buf).await {
                    // socket closed
                    Ok(n) if n == 0 =&gt; return,
                    Ok(n) =&gt; n,
                    Err(e) =&gt; {
                        eprintln!(&quot;failed to read from socket; err = {:?}&quot;, e);
                        return;
                    }
                };

                // Write the data back
                if let Err(e) = socket.write_all(&amp;buf[0..n]).await {
                    eprintln!(&quot;failed to write to socket; err = {:?}&quot;, e);
                    return;
                }
            }
        });
    }
}</code></pre></pre>
<p>如上代码，可以看到，针对每个tcp连接都形成一个tokio的协程任务, 在此任务中的代码几乎与同步IO的代码相同，仅仅多了几个<code>.await</code>, 这个代码形式相比于IO多路复用，显得简单，明了，程序员也不用再费力去学习IO多路复用的知识。</p>
<h2 id="rust协程支持的设计"><a class="header" href="#rust协程支持的设计">RUST协程支持的设计</a></h2>
<p>理解RUST针对异步IO协程的标准库支持，需要从整个协程实现的需求去考虑，否则无法理解清晰。
在一个进程内实现协程，实际上与操作系统实现线程管理的理念是近似的，只是在一些方面对协程做出了限制和简化，以匹配其轻量级的需求。</p>
<ol>
<li>协程的设计必然需要一个代码执行流重入的解决方案。RUST协程采用可重入的函数+状态这种设计来做重入,具体如下例：</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//协程中异步函数编译后代码的示意
//除了完全可重入的函数外，其他所有可能
//导致协程退出执行，等待调度的函数都会编译成
//如下示意的形式
fn poll(&amp;self, cx: &amp;Context) {
    match(self) {
        Start: {
            //这个区间的代码都是同步代码
            //不会出现协程退出函数，等待调度
            ...
            ...
        }
        //第一个异步函数做.await的调用位置
        Await1: {
            self.state = Await1;
            //这个区间的代码都是同步代码
            //不会出现协程退出函数，等待调度
            ...
            ...
        }
        //第二个异步函数做.await的调用位置
        Await2: {
            self.state = Await2;
            //这个区间的代码都是同步代码
            //不会出现协程退出函数，等待调度
            ...
            ...
        }
        ...
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>显然，这样的函数不应该由程序员来实现，事实上，async定义的函数及block会自动的被编译器编译成如上所示的形式。对于async中的异步函数或块做.await调用会自动的生成AwaitN状态。程序重入时也只可能利用这些状态逐级的进入到async的poll函数调用链，直到最后进入可完全重入的，无状态的poll函数(一般就是async实现的对系统调用的异步化封装)，这样就在用户空间实现了协程代码流的重入。</p>
<ol start="2">
<li>协程的设计必然需要一个协程调度器，根据调度器设计实现的协程任务类型结构、集合类型机构及函数、方法。</li>
<li>针对所有协程相关的操作系统资源必须建立相应的类型结构封装，类型结构应缓存在等待此资源的协程信息及操作信息，一般用多路IO复用侦听这些资源的事件，当事件发生时，如果此事件导致协程满足继续运行条件，则向调度器发送唤醒协程通知</li>
<li>调度器不停的轮询或等待协程唤醒事件，调用协程的入口poll函数执行协程</li>
</ol>
<p>RUST在标准库中没有实现统一的异步框架，而只是实现了最基础的支持：</p>
<ol>
<li><code>Future</code> trait，定义了异步代码的编译后的对外形态</li>
<li><code>async</code> 自动实现了Future trait的类型，并将async block, async fn编译成了适合重入poll方法</li>
<li><code>.await</code> 负责在async内部对下一级的async block或async fn的调用，帮助编译器生成具体的Future类型的状态</li>
<li><code>Poll&lt;T&gt;, Ready&lt;T&gt;, Waker/Context&lt;'a&gt;/RawWaker</code>是Future trait的支持结构，但也抽象了唤醒协程所使用的基本机制。</li>
</ol>
<h3 id="future-trait-分析"><a class="header" href="#future-trait-分析">Future trait 分析</a></h3>
<p>Future的定义如下:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Future {
    /// 是后继poll方法返回的类型，
    /// 对于async block，编译器会根据表达式的值来确定Output
    /// 对于async fn, Output即函数返回值
    type Output;

    //实现Future的类型结构会保存重入后正确执行的执行状态
    //在poll中如果返回Poll::Pending，会对类型结构的状态做正确的赋值
    //这样，再进入poll后，就可以根据self的状态及附带的参数回到上一次代码执行的位置
    //此处，poll使用Pin是编译器内部要求，大致上，self由于要在中断时保存执行状态，一定需要定义一些
    //内部变量，而有些内部变量很可能会引用其他的内部变量，这就必须要用Pin来防止self内存发生移动
    //Context实际存放唤醒调用本Future的协程的所有信息及操作。当poll阻塞时，可以将这个信息
    //缓存到资源类型结构里，以便资源满足时对协程进行唤醒
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

//Future的支持类型结构
pub enum Poll&lt;T&gt; {
    //表示轮询结束，并返回轮询结构变量
    Ready(T),

    //轮询不满足条件，需要暂时中止
    //条件满足时再次轮询
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>对于Future的支持结构 Context的分析如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Context由调度器实现设计，在调度协程的根Future根据该协程的信息及调度
//需求生成，然后传入Future的poll函数，并且传入后继的每一个Future的poll
//函数，poll函数会从传入的cx获取唤醒本协程的实体，将之缓存到导致协程挂起
//的系统资源结构体中。以便系统资源事件处理时，利用其唤醒协程。
pub struct Context&lt;'a&gt; {
    //waker用于作为唤醒协程，会被clone后
    //缓存于导致协程挂起的资源的类型结构体里面
    //当协程运行条件满足时，被用于唤醒协程
    waker: &amp;'a Waker,
    // Ensure we future-proof against variance changes by forcing
    // the lifetime to be invariant (argument-position lifetimes
    // are contravariant while return-position lifetimes are
    // covariant).
    _marker: PhantomData&lt;fn(&amp;'a ()) -&gt; &amp;'a ()&gt;,
}

//Context的支持结构
pub struct Waker {
    waker: RawWaker,
}

//RawWaker保存了与某一协程调度相关的信息及唤醒协程需要的函数指针列表
//RawWaker实际上完全是一个C语言习惯的类型定义，由此可见，RUST语言类型
//实际上完全兼容C语言
pub struct RawWaker {
    /// 通过data，可以获得协程的信息，调度器唤醒协程需要的其他信息
    /// 可以认为这个data类似于C语言的 void*
    data: *const (),
    /// waker实现的函数列表，可以认为这个函数列表类似一个trait
    /// 这里没有办法采用trait的机制，因此使用了函数指针来实现接口
    vtable: &amp;'static RawWakerVTable,
}

impl RawWaker {
    //由调度器根据自身设计的需要创建Waker
    pub const fn new(data: *const (), vtable: &amp;'static RawWakerVTable) -&gt; RawWaker {
        RawWaker { data, vtable }
    }

    pub fn data(&amp;self) -&gt; *const () {
        self.data
    }

    pub fn vtable(&amp;self) -&gt; &amp;'static RawWakerVTable {
        self.vtable
    }
}

//唤醒协程需要的接口函数列表
pub struct RawWakerVTable {
    //参数即RawWaker中的data
    //由调度器实现如何根据已有的数据复制一个RawWaker
    clone: unsafe fn(*const ()) -&gt; RawWaker,

    //唤醒协程，可以消费掉传入的指针
    wake: unsafe fn(*const ()),

    //唤醒协程, 不能消费传入的指针
    wake_by_ref: unsafe fn(*const ()),

    //释放传入的指针
    drop: unsafe fn(*const ()),
}

//创建一个函数指针列表
impl RawWakerVTable {
    pub const fn new(
        clone: unsafe fn(*const ()) -&gt; RawWaker,
        wake: unsafe fn(*const ()),
        wake_by_ref: unsafe fn(*const ()),
        drop: unsafe fn(*const ()),
    ) -&gt; Self {
        Self { clone, wake, wake_by_ref, drop }
    }
}

impl&lt;'a&gt; Context&lt;'a&gt; {
    //创建Context
    pub fn from_waker(waker: &amp;'a Waker) -&gt; Self {
        Context { waker, _marker: PhantomData }
    }

    pub fn waker(&amp;self) -&gt; &amp;'a Waker {
        &amp;self.waker
    }
}

impl Waker {
    pub fn wake(self) {
        let wake = self.waker.vtable.wake;
        let data = self.waker.data;

        //data会被后继的wake函数释放
        //不能再调用self的drop，会导致重复释放
        crate::mem::forget(self);

        unsafe { (wake)(data) };
    }

    pub fn wake_by_ref(&amp;self) {
        unsafe { (self.waker.vtable.wake_by_ref)(self.waker.data) }
    }

    //如果两者是对同一个协程的唤醒，则相等
    pub fn will_wake(&amp;self, other: &amp;Waker) -&gt; bool {
        self.waker == other.waker
    }

    pub unsafe fn from_raw(waker: RawWaker) -&gt; Waker {
        Waker { waker }
    }

    pub fn as_raw(&amp;self) -&gt; &amp;RawWaker {
        &amp;self.waker
    }
}

impl Clone for Waker {
    #[inline]
    fn clone(&amp;self) -&gt; Self {
        Waker {
            //依赖于传入的clone函数完成
            waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },
        }
    }
}

impl Drop for Waker {
    fn drop(&amp;mut self) {
        //需要释放内部的data
        unsafe { (self.waker.vtable.drop)(self.waker.data) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Future trait的实现有两种方式：
一种是在代码中明确实现，这种情况一般发生于调用系统调用时，此时Future中的poll方法是没有状态的，可以反复重入。例如tokio中如下实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//ScheduledIo是IO资源的类型结构
impl ScheduledIo {
    ...

    //此函数由Future的poll函数调用，并传入cx
    //此函数是没有状态的，
    //连续执行并不会对执行流造成影响
    pub(super) fn poll_readiness(
        &amp;self,
        cx: &amp;mut Context&lt;'_&gt;,
        direction: Direction,
    ) -&gt; Poll&lt;ReadyEvent&gt; {
        let curr = self.readiness.load(Acquire);

        let ready = direction.mask() &amp; Ready::from_usize(READINESS.unpack(curr));

        if ready.is_empty() {
            //这里waiters保存了cx的waker
            let mut waiters = self.waiters.lock();
            let slot = match direction {
                Direction::Read =&gt; &amp;mut waiters.reader,
                Direction::Write =&gt; &amp;mut waiters.writer,
            };

            //从cx中复制一个waker，放入self.waiters中
            match slot {
                Some(existing) =&gt; {
                    if !existing.will_wake(cx.waker()) {
                        *existing = cx.waker().clone();
                    }
                }
                None =&gt; {
                    *slot = Some(cx.waker().clone());
                }
            }

            let curr = self.readiness.load(Acquire);
            let ready = direction.mask() &amp; Ready::from_usize(READINESS.unpack(curr));
            
            if waiters.is_shutdown {
                Poll::Ready(ReadyEvent {
                    tick: TICK.unpack(curr) as u8,
                    ready: direction.mask(),
                })
            } else if ready.is_empty() {
                Poll::Pending
            } else {
                Poll::Ready(ReadyEvent {
                    tick: TICK.unpack(curr) as u8,
                    ready,
                })
            }
        } else {
            Poll::Ready(ReadyEvent {
                tick: TICK.unpack(curr) as u8,
                ready,
            })
        }
    }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>另一种是通过async语法，由编译器自动实现。编译器以async包含的代码为基础生成Future的poll函数及实现Future trait的状态机类型结构。这一个课题官方的异步编程手册及course.rs的异步教程中有大量内容，请大家参考，本文不再赘述。</p>
<h2 id="rust的io多路复用"><a class="header" href="#rust的io多路复用">RUST的IO多路复用</a></h2>
<p>协程的基础仍然是IO多路复用，因此本章给出一个简略的说明。<br />
IO多路复用的基础在于操作系统提供的支持IO多路复用的系统调用，在linux系统即为select, poll, epoll等系统调用，目前一般使用epoll。IO多路复用的思想实际很简单，linux中的IO事件即fd事件，fd事件有读、写及异常，分别代表fd有内容可读，fd可写，fd异常。在有事件发生时，对fd可以进行对应的操作。<br />
IO多路复用的另一个基础是所有的fd可以设置为非阻塞状态，即在读/写如果没有达到期望时(读入要求的字节数目或写出要求的字节数目)，不会等待，而是直接返回一个错误标志。
IO多路复用程序一般针对多个fd注册需要操作的多个fd事件及超时时间，然后用epoll调用阻塞等待这些事件。epoll返回时，调用程序会轮询所有的IO是否发生注册的事件及超时事件，如果事件发生则进行相应处理。所有事件处理完毕后根据需求进行下一次事件注册，然后再次调用epoll。如此可以用一个线程处理所有的IO，减少了多线程导致的线程切换开销，规避了不同线程操作临界区时的复杂的锁操作。</p>
<p>以下代码出自mio库。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//路径：src/sys/unix/selector.rs
//多路复用的核心结构，对于linux就是一个fd
pub struct Selector {
    ep: RawFd,
}

impl Selector {
    //创建一个多路复用的核心文件
    pub fn new() -&gt; io::Result&lt;Selector&gt; {
        //执行exec是需要主动关闭此文件
        let flag = libc::EPOLL_CLOEXEC;

        //详细请参考epoll的相关指南，此系统调用生成了一个epoll的fd
        syscall!(epoll_create1(flag)).map(|ep| Selector {
            ep,
        })
    }

    //做多路复用的阻塞调用，等待多个IO事件，并给定等待的超时时间
    pub fn select(&amp;self, events: &amp;mut Events, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;()&gt; {
        const MAX_SAFE_TIMEOUT: u128 = libc::c_int::max_value() as u128;

        let timeout = timeout
            .map(|to| cmp::min(to.as_millis(), MAX_SAFE_TIMEOUT) as libc::c_int)
            .unwrap_or(-1);

        //清除所有的事件，具体见线面Events的分析
        events.clear();
        syscall!(epoll_wait(
            self.ep,
            //调用返回时操作系统会填充此结构
            events.as_mut_ptr(),
            //最多一次接收的事件数目
            events.capacity() as i32,
            timeout,
        ))
        .map(|n_events| {
            //设置events为正确长度，此处重要，因为操作系统
            //不知道RUST的语法
            unsafe { events.set_len(n_events as usize) };
        })
    }

    //向多路复用增加一个等待事件
    pub fn register(&amp;self, fd: RawFd, token: Token, interests: Interest) -&gt; io::Result&lt;()&gt; {
        //生成一个epoll_event的结构变量
        let mut event = libc::epoll_event {
            events: interests_to_epoll(interests),
            //用来做事件的唯一标识,此标识被设置进操作系统，
            //事件发生后，操作系统会返回此标识
            u64: usize::from(token) as u64,
        };

        //将事件注册到epoll等待的事件中去
        syscall!(epoll_ctl(self.ep, libc::EPOLL_CTL_ADD, fd, &amp;mut event)).map(|_| ())
    }
    ....
}


impl Drop for Selector {
    fn drop(&amp;mut self) {
        if let Err(err) = syscall!(close(self.ep)) {
            error!(&quot;error closing epoll: {}&quot;, err);
        }
    }
}

//支持类型结构及函数、方法

//对于某些操作系统，多路复用的系统调用需要对每个事件设置唯一标识
//以便应用程序与系统能够彼此确定唯一的事件
pub struct Token(pub usize);

impl From&lt;Token&gt; for usize {
    fn from(val: Token) -&gt; usize {
        val.0
    }
}

//用来表示对读/写/异常事件的兴趣
//此处用一个独立的数据结构是RUST处于安全考虑的习惯
pub struct Interest(NonZeroU8);

//读事件及写事件的位
const READABLE: u8 = 0b0_001;
const WRITABLE: u8 = 0b0_010;

impl Interest {
    /// 读事件
    pub const READABLE: Interest = Interest(unsafe { NonZeroU8::new_unchecked(READABLE) });

    /// 写事件
    pub const WRITABLE: Interest = Interest(unsafe { NonZeroU8::new_unchecked(WRITABLE) });

    //增加希望处理的事件
    pub const fn add(self, other: Interest) -&gt; Interest {
        Interest(unsafe { NonZeroU8::new_unchecked(self.0.get() | other.0.get()) })
    }

    //移除不希望处理的事件
    pub fn remove(self, other: Interest) -&gt; Option&lt;Interest&gt; {
        NonZeroU8::new(self.0.get() &amp; !other.0.get()).map(Interest)
    }

    //是否希望处理读
    pub const fn is_readable(self) -&gt; bool {
        (self.0.get() &amp; READABLE) != 0
    }

    //是否希望处理写
    pub const fn is_writable(self) -&gt; bool {
        (self.0.get() &amp; WRITABLE) != 0
    }

}

impl ops::BitOr for Interest {
    type Output = Self;

    fn bitor(self, other: Self) -&gt; Self {
        self.add(other)
    }
}

impl ops::BitOrAssign for Interest {
    fn bitor_assign(&amp;mut self, other: Self) {
        self.0 = (*self | other).0;
    }
}

//将Interest转化为epoll的对应事件标志设置
fn interests_to_epoll(interests: Interest) -&gt; u32 {
    let mut kind = EPOLLET;

    if interests.is_readable() {
        kind = kind | EPOLLIN | EPOLLRDHUP;
    }

    if interests.is_writable() {
        kind |= EPOLLOUT;
    }

    kind as u32
}

//epoll返回后的事件集
pub type Event = libc::epoll_event;
pub type Events = Vec&lt;Event&gt;;

pub mod event {
    use std::fmt;

    use crate::sys::Event;
    use crate::Token;

    //由Event获得Token,用于比较确定唯一的事件
    //此token是应用在注册是设置进操作系统的
    pub fn token(event: &amp;Event) -&gt; Token {
        Token(event.u64 as usize)
    }

    //判断event是否是读事件
    pub fn is_readable(event: &amp;Event) -&gt; bool {
        (event.events as libc::c_int &amp; libc::EPOLLIN) != 0
            || (event.events as libc::c_int &amp; libc::EPOLLPRI) != 0
    }

    //判断event是否是写事件
    pub fn is_writable(event: &amp;Event) -&gt; bool {
        (event.events as libc::c_int &amp; libc::EPOLLOUT) != 0
    }

    //判断event是否是异常事件
    pub fn is_error(event: &amp;Event) -&gt; bool {
        (event.events as libc::c_int &amp; libc::EPOLLERR) != 0
    }

    //判断event是否是输入fd关闭事件
    pub fn is_read_closed(event: &amp;Event) -&gt; bool {
        event.events as libc::c_int &amp; libc::EPOLLHUP != 0
            || (event.events as libc::c_int &amp; libc::EPOLLIN != 0
                &amp;&amp; event.events as libc::c_int &amp; libc::EPOLLRDHUP != 0)
    }

    //判断event是否是输出fd关闭事件
    pub fn is_write_closed(event: &amp;Event) -&gt; bool {
        event.events as libc::c_int &amp; libc::EPOLLHUP != 0
            || (event.events as libc::c_int &amp; libc::EPOLLOUT != 0
                &amp;&amp; event.events as libc::c_int &amp; libc::EPOLLERR != 0)
            || event.events as libc::c_int == libc::EPOLLERR
    }

    //判断是否有优先级
    pub fn is_priority(event: &amp;Event) -&gt; bool {
        (event.events as libc::c_int &amp; libc::EPOLLPRI) != 0
    }

}
<span class="boring">}</span></code></pre></pre>
<p>以上的使用实例如下：</p>
<pre><pre class="playground"><code class="language-rust">const MAXEVENTS = 32;
fn main() {
    let events = Events::with_capacity(MAXEVENTS);
    let pool = Selector::new()?;

    pool.register(stdin().as_raw_fd(), Token::from(0), Interest::READABLE)?
    pool.register(stdout().as_raw_fd(), Token::from(1), Interest::WRITABLE)?
    pool.register(stderr().as_raw_fd(), Token::from(3)，Interest::WRITABLE)?

    loop {
        pool.select(&amp;events, None)?

        for(event in events.iter()) {
            match event.token() {
                Token::from(0) =&gt; {...},
                Token::from(1) =&gt; {...},
                Token::from(2) =&gt; {...}
            }
        }
    }
}</code></pre></pre>
<p>通常的情况下，如果IO文件众多，则针对每种类型的文件，需要涉及更合理的类型结构及其函数及方法来进行实现。但整体上多路复用的架构就是如上所述。虽然偏底层，但从实例的代码来看，并不是多复杂的一个知识。<br />
IO多路复用编程的最大问题实际上是对底层抽象不够，编程者仍然要处理大量的底层IO的细节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后记"><a class="header" href="#后记">后记</a></h1>
<p>终于写完了这本书，可以长舒一口气了。研究RUST标准库的代码是一件有趣而辛苦的工作，为什么会有这个类型结构？在一个大系统中这个类型结构应该怎样使用是最造成困扰，甚至要花上几天的时间才能够彻底搞清楚。这是系统性的给出一个类型分析所必须付出的代价。<br />
标准库中的代码，很多都展现了RUST的独特美感，让人有幸运的感觉，如果没有动念写这本书，这些代码估计就错过了。<br />
在分析代码的过程中，也发现了两个标准库代码的bug，向rust-lang项目提交了一个issue, 一个PR，都被承认并进行了相关修改，更加觉得不枉辛苦。<br />
希望这本书能对读者学习RUST起到较大的帮助，RUST是一门可以减少程序员浪费青春的语言，想起那些因为C语言的灵活及垃圾的安全性而消耗的自己的青春，就对RUST出现的过晚而遗憾不已。<br />
但好菜不怕晚，强烈建议每个程序员都对RUST做深入学习及应用，一定会给自己的职业生涯带来巨大的利益。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
